//IUARCTO JOB (FB3),'ARCTOOLS',CLASS=A,MSGCLASS=H,                              
//       NOTIFY=&SYSUID,REGION=0M,TIME=1440                                     
//*      TYPRUN=HOLD                                                            
//HSMSTEP1 EXEC PGM=IEBGENER                                                    
//*                                                                             
//********************************************************************          
//* THESE ARE THE SAMPLE PROGRAMS FOR DFSMShsm.  THIS JOB            *          
//* CREATES A PDS NAMED HSM.SAMPLE.TOOL CONTAINING THE FOLLOWING     *          
//* PROGRAMS:                                                        *          
//*                                                                  *          
//* DCOLREXX - SAMPLE REXX EXEC TO SCAN DFHSM DCOLLECT DATA          *          
//*            (originally in ARCUTILP mapping macro comment area)   *          
//* SPLITCDS - ALLOCATES DATA SETS NECESSARY TO ANALYZE THE      @01C*          
//*            MCDS/BCDS AND INVOKES SPLITER TO DO THE ANALYSIS  @01C*          
//* SPLITER  - SAMPLE REXX EXEC FOR KEYRANGES TO SPLIT MCDS/BCDS     *          
//*                                                             1@03D*          
//* PREMERGE - SAMPLE JCL TO ASSIST IN PLANNING OF A CDS MERGE   @05A*          
//* HALTER   - REXX program to ALTER the Management Class and    @02A*          
//*            Storage Class of a Migrated Data Set.             @02A*          
//* GENMASK  - REXX program to convert a list of data set masks  @ZJA*          
//*            to an assembler subprogram that can be included   @ZJA*          
//*            in dataset-related installation exits.            @ZJA*          
//* QUERYSET - REXX program to issue QUERY SETSYS from extended  @ZJA*          
//*            console with CART support.  Results are returned  @ZJA*          
//*            in variables that can then be processed.          @ZJA*          
//* SCANBLOG - REXX program to scan a week of backup activity    @ZJA*          
//*            logs and provide summary results                  @ZJA*          
//* SCANMLOG - REXX program to scan a week of migration activity @ZJA*          
//*            logs and provide summary results                  @ZJA*          
//* SCANFSR  - REXX program to scan FSR data in SMF and provide  @ZJA*          
//*            summary results                                   @ZJA*          
//* FSRSTAT  - REXX program to scan FSR data in SMF and provide  @06A*          
//*            statistical results                               @06A*          
//* FINDKRDS - Sample REXX exec that will read the MCDS and      @08A*          
//*            identify all migrated VSAM keyrange data sets.    @08A*          
//* BCDSKEYR - Sample JCL to identify VSAM key range data sets   @09A*          
//*            that were backed up using HSM as the data mover.  @09A*          
//*                                                                  *          
//* THE FOLLOWING REXX EXECS ARE PART OF THE ABARS UTILITIES         *          
//* PACKAGE.                                                     @04A*          
//*                                                                  *          
//* ABARPOST - DRIVER EXEC FOR ABARPOST FUNCTION                 @04A*          
//* ARAUDIT  - CALL DR10 TO SETUP GLOBAL PARAMETERS              @04A*          
//* ARECPROC - DRIVER EXEC FOR ARECPROC FUNCTION                 @04A*          
//* ARECSNGL - PROVIDES SINGLE DATA SET RESTORE FUNCTION         @04A*          
//* DRAUDIT  - CREATES AUDIT SUMMARY REPORT                      @04A*          
//* DRBACKUP - DRIVER EXEC FOR DRBACKUP FUNCTION                 @04A*          
//* DRSCAN   - DRIVER EXEC FOR DRSCAN FUNCTION                   @04A*          
//* DRSEO    - SIMILAR TO DRSCAN BUT LISTS CANDIDATE FOR EXCLUDE @04A*          
//* DR10     - ABARS UTILITIES GLOBAL VARIABLES                  @04A*          
//* DR11     - PERFORMS EDITS ON PARMS PASSED TO DRBACKUP        @04A*          
//* DR12     - READS DCOLLECT DATA FOR AGGREGATE STRUCTURE       @04A*          
//* DR13     - COPIES INPUT DATA SET TO SELECTION DATA SET       @04A*          
//* DR14     - GET ACTIVITY LOG NAME FOR AGGREGATE               @04A*          
//* DR14AM   - DR14 WHEN USING AUTOMATE FUNCTION                 @04A*          
//* DR14NV   - DR14 WHEN USING NETVIEW FUNCTION                  @04A*          
//* DR15     - CREATE REVISED INPUT                              @04A*          
//* DR151    - CALLED BY DR15                                    @04A*          
//* DR152    - CALLED BY DR15                                    @04A*          
//* DR16     - PREVENTS ABACKUP FROM ATTEMPTING EXECUTION        @04A*          
//* DR21     - PARSES THE ABARS ACTIVITY LOG                     @04A*          
//* DR211    - CALLED BY DR21                                    @04A*          
//* DR22     - WRITES REPORT TO LOG DDNAME                       @04A*          
//* DR31     - READ, PARSE, CREATE, AND EXECUTE ARECOVER CMD     @04A*          
//* DR32     - READS THE ARECOVER LOG AND TRACKS ARECOVERS       @04A*          
//* DR41     - CREATES AUDIT DETAIL REPORT                       @04A*          
//* DR51     - READ ACTIVITY LOG AND LIST DATA SET INFORMATION   @04A*          
//* DR61     - REPORT OF DATASET LOCATION FOR AGGREGATE          @04A*          
//* DR70     - ARECSNGL PARMS VALIDATION                         @04A*          
//* DR71     - SETUP RESTART DATASET FOR AGGREGATE RESTORE       @04A*          
//* DR711    - DFSMS/HSM PREFIX                                  @04A*          
//* DR72     - CREATE ARECOVER COMMAND FOR RESTART               @04A*          
//*                                                                  *          
//* FOLLOWING ARE FIELDS IDENTIFIED THAT MUST BE CHANGED TO EXECUTE  *          
//* THIS BATCH JOB:                                              @01C*          
//*                                                                  *          
//* ?JOBPARM  - JOB CARD WITH APPROPRIATE INFORMATION FOR YOUR       *          
//*             INSTALLATION.                                    @01C*          
//********************************************************************          
//* $42=OW04515,120,042194,THP5: NEW MEMBER: HALTER              @42A*          
//* $03=OW06826,120,091494,THP6: REMOVE SPLITDOC (SUPPLEMENTAL       *          
//*                              DOCUMENTATION FOR SPLIT MCDS/BCDS). *          
//*                                                              @03A*          
//* $04=OW15346,130,083095,THB7: ADD ABARS UTILITIES AND FIX         *          
//*                              PROBLEM IN SPLITTER                 *          
//* $WI=HSMWI,140,082096,THP5: HALTER updated to use IDCAMS      @WIA*          
//*                            ALTER STORCLAS MGMTCLAS directly  @WIA*          
//* $RI=HSMRI,140,090296,THWG: CHANGE FORMAT OF SPLITCDS OUTPUT  @RIA*          
//* $ZJ-HSMZJ,150,100598,THP5: ADD NEW EXECS                     @ZJA*          
//* $05=OW37110,140,052099,THLC: ADD PREMERGE JOB                @05A*          
//* $06=OW38584,160,052199,THP5: INCREASE SPLITCDS TEMP TO 6552  @06A*          
//*                              LRECL (6544+8 RDW)              @06A*          
//* $07=OW41372,150,112999,THP6: Apar OW41372, SPLIITER exec change  *          
//*                              to correct problem associated with  *          
//*                              changing CDS key ranges or number   *          
//*                              of clusters in CDS's.           @07A*          
//* $ZL=HSMZL,130,061901,THGS: K170713 - Update comments.        @ZLA*          
//* $08=OW49809,160,060501,THA5: Find migrated VSAM keyrange     @08A*          
//*                              datasets with FINDKRDS.         @08A*          
//* $09=OW57104,130,011402,THP6: Apar OW57104, fix bug in KEYRNGID   *          
//*                              exec regarding data mover check.    *          
//*                              Also, added new member BCDSKEYR.    *          
//*                              It is can be used to indicate VSAM  *          
//*                              key range data sets that were backed*          
//*                              up by HSM.                      @09A*          
//* $FQ=HSMFQ,190,072606,THI9-16: FSR Improvements               @FQA*          
//* $ZR=HSMZR,1A0,021507,THI9-15: K1A0324, Update comments       @ZRA*          
//* $ZR=HSMZR,1A0,092807,THMV:    K1A1549 SPLITER EXEC           @ZRA*          
//* $ZR=HSMZR,1A0,101507,THMV:    K1A1619, Update comments       @ZRA*          
//* $FV=HSMFV,D10,090810,THMB:    KFI0650 message update         @FVA*          
//* $EY=HSMEY,230,022516,THJC:    Access Method Encryption       @EYA*          
//* $FY=HSMFY,230,012317,THJC: ZFS Enhancements                  @FYA*/         
//* $EX=OA52810,230,100917,THAM:  ENCRYPTION INFO IN CDS RECORDS @EXA*          
//* $SZ=HSMSZ,240,091418,THAM: SPLITER Tool Enhancement          @SZA*          
//*                            RTC 240571                        @SZA*          
//* $10=OA54965,240,122017,THI9-6: VSAMDB support                @10A*          
//* $C8=OA59466,240,040120,THL9: TCT Compression Support         @C8A*          
//********************************************************************          
//*                                                                             
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD UNIT=SYSDA,                                                       
//            DSN=HSM.SAMPLE.TOOL(DCOLREXX),                                    
//            DISP=(NEW,CATLG),                                                 
//            DCB=(RECFM=FB,LRECL=80),                                          
//            SPACE=(CYL,(3,1,20))                                              
//SYSIN    DD DUMMY                                                             
//SYSUT1   DD DATA,DLM='$$'                                                     
        /***********************************************************/           
        /* HERE IS AN EXAMPLE TSO/E REXX EXEC THAT READS RECORDS   */           
        /* PRODUCED BY DCOLLECT AND CREATES A SIMPLE REPORT.       */           
        /*                                                         */           
        /* THERE ARE MANY MEANS OF PROCESSING THIS DATA, REXX IS   */           
        /* JUST ONE OF THEM.                                       */           
        /*                                                         */           
        /* FOR MORE EXAMPLES OF REPORTS THAT CAN BE CREATED FROM   */           
        /* THESE RECORDS, SEE THE FOLLOWING PUBLICATIONS:          */           
        /*                                                         */           
        /* DFSMS ACCESS METHOD SERVICES FOR CATALOGS (SC26 - 7326) */           
        /*                                                     @ZLC*/           
        /*                                                         */           
        /* NOTE: THE REXX LANGUAGE IS A GENERAL-USE PROGRAMMING    */           
        /*       INTERFACE.                                        */           
        /***********************************************************/           
                                                                                
        /***********************************************************/           
        /* OPEN THE INPUT FILE (CONTAINING DCOLLECT RECORDS)       */           
        /***********************************************************/           
         INNAME = "TC37378.NOV17.DATA"                                          
         "ALLOC F(INFILE) DA("INNAME") SHR"                                     
         IF RC^= 0 THEN DO                                                      
            SAY  'ALLOCATION OF ('INNAME') FAILED'                              
            EXIT 8                                                              
            END                                                                 
                                                                                
        /***********************************************************/           
        /* OPEN THE OUTPUT FILE (CONTAINING YOUR REPORT)           */           
        /***********************************************************/           
         OUTNAME = "TC37378.NOV17.REPORT"                                       
         "ALLOC F(OUTFILE) DA("OUTNAME")"                                       
         IF RC^= 0 THEN DO                                                      
            SAY  'ALLOCATION OF ('OUTNAME') FAILED'                             
            EXIT 12                                                             
            END                                                                 
                                                                                
        /***********************************************************/           
        /* PROCESS EACH RECORD UNTIL END-OF-FILE REACHED           */           
        /***********************************************************/           
         EOF = 'NO'                                                             
         DO WHILE EOF='NO'                                                      
           "EXECIO 1 DISKR INFILE"                                              
           IF RC^= 0 THEN                                                       
              EOF = 'YES'                                                       
           ELSE DO                                                              
              PARSE PULL RECORD                                                 
        /***********************************************************/           
        /* DETERMINE THE RECORD TYPE (M,B,C,T)                     */           
        /***********************************************************/           
              DCURCTYP=SUBSTR(RECORD,5,2)                                       
                 SELECT                                                         
        /***********************************************************/           
        /* PROCESS MIGRATED DATA SET INFORMATION RECORD            */           
        /***********************************************************/           
                 WHEN(DCURCTYP='M ') THEN DO                                    
                                     CALL UMRECORD                              
                                     CALL DISPLAYUM                             
                                     END                                        
        /***********************************************************/           
        /* PROCESS BACKUP VERSION INFORMATION RECORD               */           
        /***********************************************************/           
                 WHEN(DCURCTYP='B ') THEN DO                                    
                                     CALL UBRECORD                              
                                     CALL DISPLAYUB                             
                                     END                                        
        /***********************************************************/           
        /* PROCESS DASD CAPACITY PLANNING RECORD                   */           
        /***********************************************************/           
                 WHEN(DCURCTYP='C ') THEN DO                                    
                                     CALL UCRECORD                              
                                     CALL DISPLAYUC                             
                                     END                                        
        /***********************************************************/           
        /* PROCESS TAPE CAPACITY PLANNING RECORD                   */           
        /***********************************************************/           
                 WHEN(DCURCTYP='T ') THEN DO                                    
                                     CALL UTRECORD                              
                                     CALL DISPLAYUT                             
                                     END                                        
        /***********************************************************/           
        /* DO NOT PROCESS OTHER RECORD TYPES                       */           
        /***********************************************************/           
                 OTHERWISE SAY "UNKNOWN RECORD TYPE="DCURCTYP                   
                 END                                                            
              END                                                               
         END                                                                    
         "FREEALL"                                                              
         EXIT                                                                   
        /***********************************************************/           
        /* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */           
        /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */           
        /***********************************************************/           
         UMRECORD:                                                              
               UMDSNAM = SUBSTR(RECORD,25,44)                                   
               UMFLAG1 = BITSTR(SUBSTR(RECORD,69,1))                            
               UMLEVEL = SUBSTR(UMFLAG1,1,2)                                    
               UMCHIND = SUBSTR(UMFLAG1,3,1)                                    
               UMSDSP = SUBSTR(UMFLAG1,4,1)                 /* @EYA*/           
               UMDEVCL = SUBSTR(RECORD,70,1)                                    
               UMDSORG = C2X(SUBSTR(RECORD,71,2))                               
               UMDSIZE = C2D(SUBSTR(RECORD,73,4))                               
               UMTIME  = C2X(SUBSTR(RECORD,77,4))                               
               UMDATE = C2X(SUBSTR(RECORD,81,4))                                
               UMDATCL = SUBSTR(RECORD,87,30)                                   
               UMSTGCL = SUBSTR(RECORD,119,30)                                  
               UMMGTCL = SUBSTR(RECORD,151,30)                                  
               UMRECRD = C2X(SUBSTR(RECORD,181,1))                              
               UMRECOR = C2X(SUBSTR(RECORD,182,1))                              
               UMBKLNG = C2D(SUBSTR(RECORD,183,2))                              
               UMFLAG2 = BITSTR(SUBSTR(RECORD,185,1))                           
               UMRACFD = SUBSTR(UMFLAG2,1,1)                                    
               UMGDS   = SUBSTR(UMFLAG2,2,1)                                    
               UMREBLK = SUBSTR(UMFLAG2,3,1)                                    
               UMPDSE  = SUBSTR(UMFLAG2,4,1)                                    
               UMSMSM  = SUBSTR(UMFLAG2,5,1)                                    
               UMCOMPR  = SUBSTR(UMFLAG2,6,1)               /* @EYA*/           
               UMLFS  = SUBSTR(UMFLAG2,7,1)                 /* @EYA*/           
               UMENCRP  = SUBSTR(UMFLAG2,8,1)               /* @EYA*/           
               UMPDSEV = C2D(SUBSTR(RECORD,186,1))          /* @EYA*/           
               UMNMIG  = C2D(SUBSTR(RECORD,187,2))                              
               UMALLSP = C2D(SUBSTR(RECORD,189,4))                              
               UMUSESP = C2D(SUBSTR(RECORD,193,4))                              
               UMRECSP = C2D(SUBSTR(RECORD,197,4))                              
               UMCREDT = C2X(SUBSTR(RECORD,201,4))                              
               UMEXPDT = C2X(SUBSTR(RECORD,205,4))                              
               UMLBKDT = C2X(SUBSTR(RECORD,209,8))                              
               UMLRFDT = C2X(SUBSTR(RECORD,217,4))                              
               UM_USER_DATASIZE = C2D(SUBSTR(RECORD,221,4)) /* @EYA*/           
               UM_COMP_DATASIZE = C2D(SUBSTR(RECORD,225,4)) /* @EYA*/           
               UMFRVOL = SUBSTR(RECORD,229,6)               /* @EYA*/           
               UMLRECL  = C2X(SUBSTR(RECORD,235,4))         /* @EYA*/           
               UMFLAG3  = BITSTR(SUBSTR(RECORD,239,1))      /* @EYA*/           
               UMEMPTY = SUBSTR(UMFLAG3,1,1)                /* @EYA*/           
               UM_CA_RECLAIM_ELIG = SUBSTR(UMFLAG3,2,1)     /* @EYA*/           
               UMZFS = SUBSTR(UMFLAG3,3,1)                  /* @FYA*/           
               UMENCRDP = SUBSTR(UMFLAG3,4,1)               /* @EXA*/           
               UM_BSON = SUBSTR(UMFLAG3,5,1)                /* @10A*/           
               UM_JSON = SUBSTR(UMFLAG3,6,1)                /* @10A*/           
               UM_CLD_COMP = SUBSTR(UMFLAG3,7,1)            /* @C8A*/           
               UM_CLD_ENCRYPT = SUBSTR(UMFLAG3,8,1)         /* @C8A*/           
               UMFLAG4   = BITSTR(SUBSTR(RECORD,240,1))     /* @EYA*/           
               UMALLSP_FMB =  SUBSTR(UMFLAG4,1,1)           /* @EYA*/           
               UMUSESP_FMB = SUBSTR(UMFLAG4,2,1)            /* @EYA*/           
               UMRECSP_FMB = SUBSTR(UMFLAG4,3,1)            /* @EYA*/           
               UMDSIZE_FMB = SUBSTR(UMFLAG4,4,1)            /* @EYA*/           
               UM_FMB = SUBSTR(UMFLAG4,5,1)                 /* @EYA*/           
               UM_CLD_COMP_PERCENT=C2D(SUBSTR(RECORD,321,1)) /*                 
                                                               @C8A*/           
               UMENCRPT = C2X(SUBSTR(RECORD,353,2))         /* @EXA*/           
               UMENCRPL = SUBSTR(RECORD,355,64)             /* @EXA*/           
               UMENCRPR = SUBSTR(RECORD,419,30)             /* @EXA*/           
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS MIGRATED DATA SET INFORMATION RECORD -          */           
        /*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */           
        /***********************************************************/           
         DISPLAYUM:                                                             
         PUSH "M:DSN="UMDSNAM "MIGLEVEL="UMLEVEL "CHANGED="UMCHIND              
         "EXECIO 1  DISKW OUTFILE"                                              
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS BACKUP VERSION INFORMATION RECORD               */           
        /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */           
        /***********************************************************/           
         UBRECORD:                                                              
               UBDSNAM = SUBSTR(RECORD,25,44)                                   
               UBFLAG1 = BITSTR(SUBSTR(RECORD,69,1))                            
               UBINCAT = SUBSTR(UBFLAG1,1,1)                /* @EYA*/           
               UBNOENQ = SUBSTR(UBFLAG1,2,1)                /* @EYA*/           
               UBBWO = SUBSTR(UBFLAG1,3,1)                  /* @EYA*/           
               UBNQN1 = SUBSTR(UBFLAG1,4,1)                 /* @EYA*/           
               UBNQN2 = SUBSTR(UBFLAG1,5,1)                 /* @EYA*/           
               UBDEVCL = SUBSTR(RECORD,70,1)                                    
               UBDSORG = C2X(SUBSTR(RECORD,71,2))                               
               UBDSIZE = C2D(SUBSTR(RECORD,73,4))                               
               UBTIME  = C2X(SUBSTR(RECORD,77,4))                               
               UBDATE = C2X(SUBSTR(RECORD,81,4))                                
               UBDATCL = SUBSTR(RECORD,87,30)                                   
               UBSTGCL = SUBSTR(RECORD,119,30)                                  
               UBMGTCL = SUBSTR(RECORD,151,30)                                  
               UBRECRD = C2X(SUBSTR(RECORD,181,1))                              
               UBRECOR = C2X(SUBSTR(RECORD,182,1))                              
               UBBKLNG = C2D(SUBSTR(RECORD,183,2))                              
               UBFLAG2 = BITSTR(SUBSTR(RECORD,185,1))                           
               UBRACFD = SUBSTR(UBFLAG2,1,1)                                    
               UBGDS   = SUBSTR(UBFLAG2,2,1)                                    
               UBREBLK = SUBSTR(UBFLAG2,3,1)                                    
               UBPDSE  = SUBSTR(UBFLAG2,4,1)                                    
               UBSMSM  = SUBSTR(UBFLAG2,5,1)                                    
               UBCOMPR = SUBSTR(UBFLAG2,6,1)                /* @EYA*/           
               UBLFS = SUBSTR(UBFLAG2,7,1)                  /* @EYA*/           
               UBNEWNAME = SUBSTR(UBFLAG2,8,1)              /* @EYA*/           
               UBFLAG3 = BITSTR(SUBSTR(RECORD,186,1))       /* @EYA*/           
               UBNOSPHERE = SUBSTR(UBFLAG3,1,1)             /* @EYA*/           
               UBGVCN = SUBSTR(UBFLAG3,2,1)                 /* @EYA*/           
               UBF_RETAIN_SPCD = SUBSTR(UBFLAG3,3,1)        /* @EYA*/           
               UBF_NEVER_EXP = SUBSTR(UBFLAG3,4,1)          /* @EYA*/           
               UBENCRP = SUBSTR(UBFLAG3,5,1)                /* @EYA*/           
               UBZFS = SUBSTR(UBFLAG3,6,1)                  /* @FYA*/           
               UBENCRDP = SUBSTR(UBFLAG3,7,1)               /* @EXA*/           
               UB_RETAINDAYS = C2D(SUBSTR(RECORD,187,2))    /* @EYA*/           
               UBALLSP = C2D(SUBSTR(RECORD,189,4))                              
               UBUSESP = C2D(SUBSTR(RECORD,193,4))                              
               UBRECSP = C2D(SUBSTR(RECORD,197,4))                              
               UB_USER_DATASIZE = C2D(SUBSTR(RECORD,201,4)) /* @EYA*/           
               UB_COMP_DATASIZE = C2D(SUBSTR(RECORD,205,4)) /* @EYA*/           
               UBFRVOL = SUBSTR(RECORD,209,6)               /* @EYA*/           
               UBFLAG4   = BITSTR(SUBSTR(RECORD,215,1))     /* @EYA*/           
               UBALLSP_FMB =  SUBSTR(UMFLAG4,1,1)           /* @EYA*/           
               UBUSESP_FMB = SUBSTR(UMFLAG4,2,1)            /* @EYA*/           
               UBRECSP_FMB = SUBSTR(UMFLAG4,3,1)            /* @EYA*/           
               UBDSIZE_FMB = SUBSTR(UMFLAG4,4,1)            /* @EYA*/           
               UB_FMB = SUBSTR(UMFLAG4,5,1)                 /* @EYA*/           
               UB_BSON = SUBSTR(UBFLAG4,6,1)                /* @10A*/           
               UB_JSON = SUBSTR(UBFLAG4,7,1)                /* @10A*/           
               UBPDSEV = C2D(SUBSTR(RECORD,216,1))          /* @EYA*/           
               UBENCRPT = C2X(SUBSTR(RECORD,229,2))         /* @EXA*/           
               UBENCRPL = SUBSTR(RECORD,231,64)             /* @EXA*/           
               UBENCRPR = SUBSTR(RECORD,295,30)             /* @EXA*/           
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS BACKUP VERSION INFORMATION RECORD               */           
        /*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */           
        /***********************************************************/           
         DISPLAYUB:                                                             
         PUSH "B:DSN="UBDSNAM "SMS MGMTCLASS="UBMGTCL                           
         "EXECIO  1 DISKW OUTFILE"                                              
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS DASD CAPACITY PLANNING RECORD                   */           
        /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */           
        /***********************************************************/           
         UCRECORD:                                                              
               UCVOLSR = SUBSTR(RECORD,25,6)                                    
               UCCOLDT = C2X(SUBSTR(RECORD,31,4))                               
               UCFLAG1 = BITSTR(SUBSTR(RECORD,35,1))                            
               UCLEVEL = SUBSTR(UCFLAG1,1,2)                                    
               UCTOTAL = C2D(SUBSTR(RECORD,37,4))                               
               UCTGOCC = C2D(SUBSTR(RECORD,41,1))                               
               UCTROCC = C2D(SUBSTR(RECORD,42,1))                               
               UCBFOCC = C2D(SUBSTR(RECORD,43,1))                               
               UCAFOCC = C2D(SUBSTR(RECORD,44,1))                               
               UCNOMIG = C2D(SUBSTR(RECORD,45,1))                               
               UCNINTV = C2D(SUBSTR(RECORD,46,1))                               
               UCINTVM = C2D(SUBSTR(RECORD,47,1))                               
         RETURN                                                                 
         DISPLAYUC:                                                             
         PUSH "C:VOLSER="UCVOLSR "MIGLEVEL="UCLEVEL "DATE="UCCOLDT              
         "EXECIO  1 DISKW OUTFILE"                                              
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS TAPE CAPACITY PLANNING RECORD                   */           
        /*   CONVERT THE RECORD INTO INDIVIDUAL FIELD VARIABLES.   */           
        /***********************************************************/           
         UTRECORD:                                                              
               UTSTYPE = SUBSTR(RECORD,25,1)                                    
               UTFULL  = C2D(SUBSTR(RECORD,29,4))                               
               UTPART  = C2D(SUBSTR(RECORD,33,4))                               
               UTEMPTY = C2D(SUBSTR(RECORD,37,4))                               
         RETURN                                                                 
        /***********************************************************/           
        /* PROCESS TAPE CAPACITY PLANNING RECORD                   */           
        /*   WRITE THE FORMATTED FIELDS TO YOUR REPORT             */           
        /***********************************************************/           
         DISPLAYUT:                                                             
         PUSH "T:TAPE VOLUME TYPE="UTSTYPE UTFULL UTPART UTEMPTY                
         "EXECIO  1 DISKW OUTFILE"                                              
         RETURN                                                                 
        /***********************************************************/           
        /* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */           
        /* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */           
        /***********************************************************/           
         BITSTR:                                                                
           IF BIT.F ^= "1111"  THEN DO                                          
              BIT.0="0000"; BIT.1="0001"; BIT.2="0010"; BIT.3="0011"            
              BIT.4="0100"; BIT.5="0101"; BIT.6="0110"; BIT.7="0111"            
              BIT.8="1000"; BIT.9="1001"; BIT.A="1010"; BIT.B="1011"            
              BIT.C="1100"; BIT.D="1101"; BIT.E="1110"; BIT.F="1111"            
           END                                                                  
           CH=C2X(ARG(1))                                                       
           BS=''                                                                
           DO I=1 TO LENGTH(CH)                                                 
              Q=SUBSTR(CH,I,1)                                                  
              BS=BS||BIT.Q                                                      
           END                                                                  
        RETURN BS                                                               
$$                                                                              
//HSMSTEP2 EXEC PGM=IEBUPDTE,PARM=NEW                                           
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD DSN=HSM.SAMPLE.TOOL,                                              
//            DISP=OLD                                                          
//SYSIN    DD DATA,DLM='$$'                                                     
./ ADD NAME=SPLITER                                                             
/* REXX - SPLITER                                    */                         
/*********************************************************************/         
/* This REXX exec will REPRO a number of records from the specified  */         
/* Control Data Set (CDSNAME) into a temporary file.  Then read the  */         
/* records from the temporary file into storage.  The MCDS or BCDS   */         
/* record images are then analyzed to determine suggested 2-way,     */         
/* 3-way or 4-way splits for the Control data set and displays       */         
/* these results to file SYSTSPRT.  All records in the specified     */         
/* Control Data Set are analyzed before the results are displayed.   */         
/*                                                                   */         
/* Note: The REXX language is a general-use programming interface.   */         
/*                                                               @01C*/         
/*                                                               @06C*/         
/*********************************************************************/         
NUMERIC DIGITS 12                                                               
IO=1000      /* number of records per I/O request to read */                    
LINE.=0         /*                                    @01A*/                    
SIZE.=0         /*                                    @01A*/                    
TOTAL_SIZE=0    /* Total size of input file in bytes      */                    
REC_COUNT=0     /* Total number of records in input file  */                    
M=1; AVG=500    /* Initial analysis group# average size   */                    
X00=X2C('00')   /* Keys from x'00' - x'1F' are in MCDS        @ZRA */           
X20=X2C('20')   /* Keys from x'20' - x'31' are in BCDS        @ZRA */           
X32=X2C('32')   /* Keys from x'32' - x'3F' are in OCDS        @ZRA */           
X3F=X2C('3F')   /* Keys over x'3F' are MCA, MCD, MCB, OR MCC  @ZRC */           
MCA=X2C('11'); MCD=X2C('00')  /* MCHTYPE of MCA and MCD   */                    
MCB=X2C('20'); MCC=X2C('24')  /* MCHTYPE of MCB and MCC   */                    
MCA_COUNT = 0; MCD_COUNT=0    /* Number of MCA and MCD's  */                    
MCB_COUNT = 0; MCC_COUNT=0    /* Number of MCC and MCB's  @06A*/                
FROMKEY=0; CDS_TYPE_DETERMINED=0  /* Init fields            @ZRA*/              
MCDS_FLAG=0; BCDS_FLAG=0      /* Init CDS FLAGS             @ZRA*/              
OCDS_FLAG=0; STOP=0           /* Init CDS FLAG & STOP flag  @ZRA*/              
EOF_REC=('Z9999999999999999999999999999999999999999999') /* @ZRA*/              
LIMIT1=24; LIMIT2=2*LIMIT1   /* number of analysis groups */                    
START=1                       /* Start number of the first record               
                                 to process each loop.           @SZA*/         
DO N=1 TO LIMIT2                                                                
   SIZE.N=0; LOWKEY.N=''; CUMPERCENT.N=100                                      
END                                                                             
  /*****************************************************/                       
CALL READ_LINES                                              /* @01C*/          
DO WHILE LINE.0 > 0                                                             
   DO N=START TO LINE.0 WHILE STOP=0   /* Dynamic START number   @SZC*/         
      IF OCDS_FLAG = 0 THEN  /* Not OCDS data set                @ZRA*/         
       CALL PROCESS_LINE     /* Process each record */                          
      ELSE                   /*                                  @ZRA*/         
       STOP=1                /* STOP PROCESSING.  THIS IS OCDS   @ZRA*/         
      END                                                                       
   IF N < IO | STOP = 1 THEN  /* if all records read or need to                 
                                 stop processing                 @ZRC*/         
     LINE.0 = 0             /* We're done                        @RIA*/         
   ELSE DO                  /* More records to read              @SZC*/         
     START = 2              /* Next loop start on 2nd record     @SZA*/         
     CALL READ_LINES                                          /* @01C*/         
    END                     /* End more records to read          @SZA*/         
   END                                                                          
  IF OCDS_FLAG = 0 THEN     /* NOT OCDS                          @ZRA*/         
   CALL DISPLAY_RESULTS  /* Show appropriate ranges */                          
  EXIT 0                                                                        
  /*****************************************************/                       
  READ_LINES:                                                                   
    /****************************************************************/          
    /* REPRO 1000 MORE RECORDS TO THE TEMPORARY FILE, THEN READ THEM*/          
    /* INTO VIRTUAL STORAGE FOR PROCESSING. INSTEAD OF ADJUSTING    */          
    /* THE FROMKEY TO THE 1000x+1 RECORD FOR THE NEXT READ OF 1000  */          
    /* RECORDS, PUT IT ON THE LAST RECORD READ IN (i.e. 1000th REC).*/          
    /* THIS GUARANTEES THAT THE NEXT REPRO COMMAND WILL NOT FAIL,   */          
    /* BUT WILL READ AT LEAST 1 RECORD (i.e. THE LAST RECORD FROM   */          
    /* THE LAST READ). THE MAIN PROCESSING LOOP WILL USE THE 'START'*/          
    /* VARIABLE TO SKIP PAST THE FIRST RECORD OF 1000 BECAUSE IT WAS*/          
    /* PROCESSED DURING THE PREVIOUS LOOP. THE VERY FIRST READ IS A */          
    /* CORNER CASE AND IS HANDLED APPROPRIATELY BY PROCESSING FROM  */          
    /* THE VERY FIRST RECORD.                                   @SZC*/          
    /****************************************************************/          
    x = OUTTRAP(ON.)                                                            
    "REPRO INFILE(INDATA) OUTFILE(ATEMP) COUNT("IO")",                          
           "FROMKEY(X'"FROMKEY"')"                                              
    x = OUTTRAP('OFF')                                                          
     IF RC > 4 THEN DO                       /* RC=4 IS OKAY    @RIA*/          
        SAY  'REPRO OF CDS FAILED WITH RC='RC                /* @RIA*/          
        DO N=1 to ON.0; Say ON.n; end                                           
        EXIT 8                                               /* @RIA*/          
        END                                                  /* @RIA*/          
     "EXECIO * DISKR ATEMP ( STEM  LINE."    /* TMPFILE TO VIRT @01A*/          
     MM=LINE.0                                               /* @04C*/          
     IF MM>0 THEN DO                         /* GET NEW FROMKEY @04C*/          
        FROMKEY = C2X(LEFT(LINE.MM,44))      /* FOR NEXT REPRO. @04C*/          
        LAST = X2D(RIGHT(FROMKEY,2))         /* SAVE LAST KEY   @SZC*/          
        FROMKEY = LEFT(FROMKEY,86)||D2X(LAST)                /* @01A*/          
        IF START>1 & MM=1 THEN               /* DONE PROCESSING?@SZA*/          
          LINE.0 = 0                         /* YES, PROPAGATE  @SZA*/          
        END                                  /* END NEW FROMKEY @01A*/          
    "EXECIO 0 DISKR ATEMP ( FINIS"           /* close tempfile  @01A*/          
    RETURN                                   /* END READ_LINES  @01A*/          
PROCESS_LINE:                                                                   
     BYTES =LENGTH(LINE.N)  /* Length of record in bytes */                     
     KEY=LEFT(LINE.N,44)    /* Key of record */                                 
     MCKT=LEFT(KEY,1)          /* MCKTYPE field */                              
     MCHT=SUBSTR(LINE.N,47,1)  /* MCHTYPE field */                              
                                                                                
     IF CDS_TYPE_DETERMINED=0 THEN DO /* CDS TYPE NOT DETERMINED@ZRA*/          
       IF MCHT>=X00 & MCHT<X20 & KEY^=EOF_REC THEN /* MCDS TYPE @ZRA*/          
          MCDS_FLAG = 1                        /* SET MCDS FLAG @ZRA*/          
       ELSE                                    /*               @ZRA*/          
       IF MCHT>=X20 & MCHT<X32 THEN            /* BCDS TYPE     @ZRA*/          
          BCDS_FLAG = 1                        /* SET BCDS FLAG @ZRA*/          
       ELSE                                    /*               @ZRA*/          
       IF MCHT>=X32 & MCHT<=X3F THEN           /* OCDS TYPE     @ZRA*/          
          OCDS_FLAG = 1                        /* SET OCDS FLAG @ZRA*/          
       CDS_TYPE_DETERMINED=1             /* CDS TYPE DETERMINED @ZRA*/          
     END                                 /* END DO              @ZRA*/          
                                                                                
     IF OCDS_FLAG = 1 THEN            /* PROCESSING OCDS        @ZRA*/          
        SAY "OCDS NOT ELIGIBLE FOR PROCESSING WITH SPLITER" /*  @ZRA*/          
     ELSE                            /* PROCESSING MCDS OR BCDS @ZRA*/          
     IF MCKT>X3F | MCKT=MCHT THEN DO /* valid HSM key */                        
        TOTAL_SIZE = TOTAL_SIZE + BYTES                                         
        REC_COUNT = REC_COUNT + 1                                               
        IF MCHT=MCA then MCA_COUNT=MCA_COUNT + 1          /* @06A*/             
        IF MCHT=MCB then MCB_COUNT=MCB_COUNT + 1          /* @06A*/             
        IF MCHT=MCC then MCC_COUNT=MCC_COUNT + 1          /* @06A*/             
        /* DON'T INCREMENT THE MCD COUNT IF THIS IS AN                          
           EOF RECORD.  THE EOF RECORD ALWAYS APPEARS TO                        
           BE AN MCD RECORD NO MATTER WHICH CDS IS BEING                        
           PROCESSED.                                             @ZRA*/        
        IF MCHT=MCD & KEY^=EOF_REC then MCD_COUNT=MCD_COUNT + 1 /*@ZRC*/        
        HIGH_KEY = KEY                                                          
        IF SIZE.M=0          /* For new group, */                               
           THEN LOWKEY.M=KEY /* Initialize Low Key */                           
                                                                                
        SIZE.M=SIZE.M+BYTES                                                     
        IF SIZE.M>=AVG THEN DO /* Group filled        */                        
           IF M<LIMIT2 THEN M=M+1 /* Start new group  */                        
           ELSE DO               /* No more groups    */                        
                DO J=1 TO LIMIT1 /* Merge existing groups */                    
                   J2= 2*J; J1=J2-1                                             
                   SIZE.J = SIZE.J1+ SIZE.J2                                    
                   LOWKEY.J = LOWKEY.J1                                         
                   END           /* Merge existing groups */                    
                DO J=LIMIT1+1 TO LIMIT2 /* CLEAR END */                         
                   SIZE.J = 0                                                   
                   LOWKEY.J = ''                                                
                   END              /* Clear groups    */                       
                M = LIMIT1+1                                                    
                CALL AVERAGE  /* Determine new average */                       
                END         /* No more groups          */                       
           END           /* Group Filled               */                       
     END                 /* Valid HSM key              */                       
     RETURN                                                                     
  /*****************************************************/                       
  /*  Determine new running average for all groups     */                       
  /*****************************************************/                       
AVERAGE:                                                                        
     AVREC = TOTAL_SIZE/REC_COUNT                                               
     SUM=0; DO J=1 TO LIMIT1; SUM=SUM+SIZE.J;  END                              
     AVG = SUM/LIMIT1 - AVREC/2                                                 
     RETURN                                                                     
   /*****************************************************/                      
 DISPLAY_RESULTS:                                                               
   CUM = 0                                                                      
   SAY " GROUP  CUM %     STARTING KEY"                                         
   SAY " =====  =====     ============"                                         
   DO J=1 TO LIMIT2 /* DISPLAY RESULTS */                                       
      IF LOWKEY.J<' ' THEN KEY="X'"C2X(LEFT(LOWKEY.J,21))"'"                    
                     ELSE KEY= LOWKEY.J                                         
         IF SIZE.J > 0 THEN DO                                                  
            CUM = CUM + SIZE.J                                                  
            CUMPERCENT.J = FORMAT(100*CUM/TOTAL_SIZE,5,2)                       
            SAY FORMAT(J,5) format(CUMPERCENT.J,5,1)'   'KEY                    
            END                                                                 
         END        /* DISPLAY RESULTS */                                       
      SAY "HIGHEST KEY FOUND: " HIGH_KEY                                        
  IF REC_COUNT=1 & HIGH_KEY=EOF_REC THEN   /* PRIMER REC ONLY   @ZRA*/          
   SAY " "                                 /*                   @ZRA*/          
  ELSE DO                                  /*                   @ZRA*/          
  P25=1; P33=1; P50=1; P67=1; P75=1                                             
  DO J=1 TO LIMIT2 /* DETERMINE RANGES */                                       
    J2 = J+1                                                                    
    IF CUMPERCENT.J<=50 & CUMPERCENT.J2>50 THEN P50=J                           
    IF CUMPERCENT.J<=33 & CUMPERCENT.J2>33 THEN P33=J                           
    IF CUMPERCENT.J<=67 & CUMPERCENT.J2>67 THEN P67=J                           
    IF CUMPERCENT.J<=25 & CUMPERCENT.J2>25 THEN P25=J                           
    IF CUMPERCENT.J<=75 & CUMPERCENT.J2>75 THEN P75=J                           
    END           /* DETERMINE RANGES */                                        
   /*****************************************************/                      
   /*  DISPLAY SUGGESTED RANGES BASED ON SIZE           */                      
   /*****************************************************/                      
 SAY " "                                                                        
 SAY "TWO-WAY SPLIT: "                                                          
    SAY "   FROMKEY( X'00' ) TOKEY( "RANGE(TO,P50)" )"         /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P50)" ) TOKEY( X'FF' )"       /*@RIC*/         
 SAY " "                                                                        
 SAY "THREE-WAY SPLIT: "                                                        
    SAY "   FROMKEY( X'00' ) TOKEY( "RANGE(TO,P33)" )"         /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P33)" ) TOKEY( "RANGE(TO,P67)" )"              
                                                               /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P67)" ) TOKEY( X'FF' )"       /*@RIC*/         
 SAY " "                                                                        
 SAY "FOUR-WAY SPLIT:"                                                          
    SAY "   FROMKEY( X'00' ) TOKEY( "RANGE(TO,P25)" )"         /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P25)" ) TOKEY( "RANGE(TO,P50)" )"              
                                                               /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P50)" ) TOKEY( "RANGE(TO,P75)" )"              
                                                               /*@RIC*/         
    SAY "   FROMKEY( "RANGE(FROM,P75)" ) TOKEY( X'FF' )"       /*@RIC*/         
 SAY " "                                                                        
 END                                             /*              @ZRA*/         
     AVREC = TOTAL_SIZE % REC_COUNT                                             
 SAY "AVERAGE RECORD SIZE IN BYTES ..... " format(AVREC,11)                     
 SAY "TOTAL NUMBER OF RECORDS .......... " format(REC_COUNT,11)                 
 if MCB_count > 0 | MCC_count > 0 | BCDS_FLAG = 1 Then do    /* @ZRC*/          
 SAY "      NUMBER OF MCB RECORDS....... " format(MCB_COUNT,11)                 
 SAY "      NUMBER OF MCC RECORDS....... " format(MCC_COUNT,11)                 
 end                                                         /* @06A*/          
 else                                                        /* @ZRC*/          
 if MCA_count > 0 | MCD_count > 0 | MCDS_FLAG = 1 then do    /* @ZRA*/          
 SAY "      NUMBER OF MCA RECORDS....... " format(MCA_COUNT,11)                 
 SAY "      NUMBER OF MCD RECORDS....... " format(MCD_COUNT,11)                 
 end                                                         /* @06A*/          
 else                                                        /* @ZRA*/          
 if REC_COUNT=1 & HIGH_KEY=EOF_REC THEN    /* PRIMER REC ONLY   @ZRA*/          
 SAY "CDS IS EMPTY EXCEPT FOR PRIMER RECORD"                 /* @ZRA*/          
 RETURN                                                                         
   /*****************************************************/                      
 RANGE:   PROCEDURE EXPOSE LOWKEY.                                              
      J=ARG(2); J2=J+1                                                          
      X1=LOWKEY.J; X2=LOWKEY.J2; K=0                                            
      DO N=1 TO LENGTH(LOWKEY.J)                                                
         IF SUBSTR(X1,N,1)^=SUBSTR(X2,N,1) & K=0 THEN K=N                       
         END                                                                    
      IF ARG(1)=TO   THEN KEYVALUE=LEFT(X1,K)                                   
      IF ARG(1)=FROM THEN DO                                                    
         Q=SUBSTR(X1,K,1);  Q2=D2C(C2D(Q)+1)                                    
         KEYVALUE=LEFT(X1,K-1)||Q2                                              
         END                                                                    
       /* Since alphanumeric characters are not contiguous                      
          in the EBCDIC coding sequence, we check to see if                     
          any characters in the key require hex notation        @06A*/          
       hexreq = no                                           /* @06A*/          
       STANDARDKEYS ='.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' /* @06A*/          
       do n=1 to length(keyvalue)                            /* @06A*/          
          if pos(substr(keyvalue,n,1),standardkeys)=0 then , /* @06A*/          
             hexreq = yes                                    /* @06A*/          
       end                                                   /* @06A*/          
       IF hexreq =yes THEN KEYVALUE ="X'"C2X(KEYVALUE)"'"    /* @06C*/          
       RETURN KEYVALUE                                                          
./ ADD NAME=SPLITCDS                                                            
//SPLITCDS JOB ?JOBPARM                                                         
//*                                                                             
//********************************************************************          
//*  THIS IS A SAMPLE JOB TO DETERMINE APPROPRIATE KEYRANGES         *          
//*  IF YOU DESIRE TO SPLIT YOUR MCDS OR BCDS INTO 2, 3 OR 4         *          
//*  RANGES.                                                         *          
//*                                                                  *          
//* FOLLOWING ARE FIELDS IDENTIFIED THAT MUST BE CHANGED TO EXECUTE  *          
//* THIS BATCH JOB:                                              @01A*          
//*                                                                  *          
//* ?JOBPARM  - JOB CARD WITH APPROPRIATE INFORMATION FOR YOUR       *          
//*             INSTALLATION.                                    @01A*          
//*                                                                  *          
//* ?CDSNAME  - NAME OF THE CONTROL DATA SET THAT YOU WANT TO        *          
//*             PROCESS.                                         @01C*          
//*                                                                  *          
//*                                                             1@03D*          
//********************************************************************          
//*                                                                             
//************************************************************                  
//*  STEP n-- CONVERT EXPORT COPY TO RECFM=VB SO THAT IT                        
//*           CAN BE READ BY TSO/E REXX.  This step has been                    
//*           DELETED                                     @ZRC                  
//************************************************************                  
//STEP1   EXEC PGM=IKJEFT01                                                     
//************************************************************                  
//*  STEP 1 -- ALLOCATE THE SPECIFIED CONTROL DATA SET AND                      
//*            INVOKE SPLITER ROUTINE TO DETERMINE RECOMMENDED                  
//*            KEYRANGES FOR EACH CDS PORTION.            @01C                  
//*                                                                             
//*           SPLITER - REXX EXEC ... HSM.SAMPLE.TOOL(SPLITER)                  
//*                                                                             
//*           RESULTS WRITTEN TO SYSTSPRT DD CARD.                              
//*                                                                             
//*  THE ATEMP FILE HOLDS 1000 CDS RECORDS, AND WILL BE 3-9      @06A*          
//*  CYLINDERS IN SIZE, DEPENDING ON THE RECORD SIZES. THE       @06A*          
//*  LRECL 6552 HANDLES THE LARGEST RECORD POSSIBLE IN HSM.      @06A*          
//*                                                                             
//* OW02581 CHANGED THE FOLLOWING INDATA AND ATEMP DD CARDS @01C                
//**************************************************************                
//INDATA    DD DSN=?CDSNAME,DISP=SHR                                            
//ATEMP     DD DSNAME=&&ATEMP,DISP=(NEW,PASS),DSORG=PS,                         
//             LRECL=6552,RECFM=VB,SPACE=(CYL,(3,1)),                           
//             UNIT=SYSDA                                                       
//SYSTSPRT  DD SYSOUT=*                                                         
//SYSEXEC   DD DSN=HSM.SAMPLE.TOOL,DISP=SHR                                     
//SYSTSIN   DD *                                                                
  SPLITER                                                                       
/*                                                                              
./ ADD NAME=KEYRNGID                                                            
/* REXX - KEYRNGID                                    @08A*/                    
/*************************************************************** @08A*/         
/* This REXX exec will REPRO a number of records from the MCDS into  */         
/* a temporary file.  Then read the records from the temporary file  */         
/* into storage.  The MCDS record images are analyzed to identify    */         
/* migrated VSAM keyrange datasets. The VSAM keyrange datasets       */         
/* are identified by dataset name and associated datamover in the    */         
/* results. The results are output to file SYSTSPRT.  All records    */         
/* in the MCDS are analyzed before the results are displayed.        */         
/*                                                                   */         
/* Note: The REXX language is a general-use programming interface.   */         
/*                                                               @ZRC*/         
/*********************************************************************/         
IO=1000      /* number of records per I/O request to read */                    
LINE.=0         /*                                        */                    
X3F=X2C('3F')   /* Keys over x'3F' are MCD or MCA         */                    
MCA=X2C('11'); MCD=X2C('00')  /* MCHTYPE of MCA and MCD   */                    
MCA_COUNT = 0; MCD_COUNT=0    /* Number of MCA and MCD's  */                    
FRMKEY=0; HEADER_DONE=0                                                         
                                                                                
CALL READ_LINES                                                                 
DO WHILE LINE.0 > 0                                                             
   DO N=1 TO LINE.0                                                             
      CALL PROCESS_LINE     /* Process each record */                           
      END                                                                       
   IF N < IO THEN           /* If all the records were read      */             
     LINE.0 = 0             /* We're done                        */             
   ELSE                     /* More records to read              */             
     CALL READ_LINES                                                            
   END                                                                          
   IF HEADER_DONE > 0 THEN                                                      
  SAY '========================================================='               
  EXIT 0                                                                        
  /*****************************************************/                       
  READ_LINES:                                                                   
    /****************************************************************/          
    /* REPRO 1000 MORE RECORDS TO THE TEMPORARY FILE, THEN READ THEM*/          
    /* INTO VIRTUAL STORAGE FOR PROCESSING.                         */          
    /****************************************************************/          
    x = OUTTRAP(ON.)                         /* Trapping on         */          
    "REPRO INFILE(INDATA) OUTFILE(ATEMP) COUNT("IO")",                          
           "FROMKEY(X'"FRMKEY"')"                                               
    x = OUTTRAP('OFF')                       /* Trapping on         */          
     IF RC > 4 THEN DO                       /* RC=4 IS OKAY    */              
        SAY  'REPRO OF MCDS FAILED WITH RC='RC                                  
        DO N=1 to ON.0; Say ON.n; end        /* Echo trapped output  */         
        EXIT 8                                                                  
        END                                                                     
     "EXECIO * DISKR ATEMP ( STEM  LINE."    /* TMPFILE TO VIRT     */          
     MM=LINE.0                                                                  
     IF MM>0 THEN DO                         /* GET NEW FROMKEY     */          
        FRMKEY = C2X(LEFT(LINE.MM,44))      /* FOR NEXT REPRO.     */           
        LAST = 1+ X2D(RIGHT(FRMKEY,2))                                          
        FRMKEY = LEFT(FRMKEY,86)||D2X(LAST)                                     
        END                                  /* END NEW FROMKEY     */          
    "EXECIO 0 DISKR ATEMP ( FINIS"           /* close tempfile      */          
    RETURN                                   /* END READ_LINES      */          
PROCESS_LINE:                                                                   
     BYTES =LENGTH(LINE.N)  /* Length of record in bytes */                     
     KEY=LEFT(LINE.N,44)    /* Key of record */                                 
     MCKT=LEFT(KEY,1)          /* MCKTYPE field */                              
     MCHT=SUBSTR(LINE.N,47,1)  /* MCHTYPE field */                              
                                                                                
     IF MCKT>X3F THEN DO                     /* valid HSM MCD key */            
        IF MCHT=MCD then DO                /* MCD record...           */        
          MCD_COUNT=MCD_COUNT + 1                                               
          DKRBYTE=SUBSTR(LINE.N,398,1)     /* Byte with keyrange bit */         
          DKRBYT=X2B(C2X(DKRBYTE))         /* To HEX then to BINARY  */         
          DKEYRG=SUBSTR(DKRBYT,4,1)        /* Get keyrange bit value */         
          IF DKEYRG > 0 THEN DO            /* Is a keyrange...       */         
           IF HEADER_DONE = 0 THEN         /* Header output yet?     */         
             CALL DISPLAY_HEADER           /* No..output header      */         
             DDMVBYTE=SUBSTR(LINE.N,135,1) /* Byte w/datamover bit   */         
             DDMVBYT=X2B(C2X(DDMVBYTE))    /* To HEX then to BINARY  */         
             DDMVBIT=SUBSTR(DDMVBYT,7,1)   /* Get dm bit value ON=DSS*/         
             IF DDMVBIT = 0 THEN       /* HSM/IDCAMS datamover   @09C*/         
               SAY KEY '   IDCAMS'                                              
             ELSE                      /* DFSMSdss is data mover @09C*/         
               SAY KEY '   DFSMSdss'                                            
            END                              /* end - Is a keyrange. */         
        END                                /* end - MCD record        */        
     END                                   /* Valid HSM MCD key       */        
     RETURN                                                                     
DISPLAY_HEADER:                                                                 
  HEADER_DONE = 1                                                               
  SAY 'Dataset name                                    Datamover'               
  SAY '========================================================='               
  RETURN                                                                        
./ ADD NAME=FINDKRDS                                                            
//FINDKRDS JOB ?JOBPARM                                                         
//*                                                                             
//************************************************************** @08A*          
//*  This is a sample job to identify migrated VSAM keyrange         *          
//*  datasets,  output the dataset name to a file and indicate       *          
//*  the datamover that migrated the dataset.                        *          
//*                                                                  *          
//* FOLLOWING ARE FIELDS IDENTIFIED THAT MUST BE CHANGED TO EXECUTE  *          
//* THIS BATCH JOB:                                                  *          
//*                                                                  *          
//* ?JOBPARM  - JOB CARD WITH APPROPRIATE INFORMATION FOR YOUR       *          
//*             INSTALLATION.                                        *          
//*                                                                  *          
//* ?MCDSNAME  - NAME OF THE CONTROL DATA SET (data component name)  *          
//*              THAT YOU WANT TO PROCESS.                           *          
//*                                                                  *          
//* Note: If using RLS to share CDSs defined with SHAREOPTIONS(3,x), *          
//* DFHSM must be shutdown on all sharing hosts for the program to   *          
//* execute successfully.  If it is inconvenient to shutdown DFHSM   *          
//* on all sharing hosts, use the CDS backup copy that is created at *          
//* Autobackup or Backvol CDS time in place of the active MCDS to    *          
//* successfully run the program.  Simply Restore the MCDS backup    *          
//* copy to a new name and then run the Exec against the restored    *          
//* copy.                                                            *          
//************************************************************** @08A*          
//*                                                                             
//************************************************************                  
//STEP1   EXEC PGM=IKJEFT01                                                     
//***************************************************************               
//*  STEP 1 -- Allocate the specified MCDS and invoke KEYRNGID                  
//*            routine to identify any VSAM keyrange dataset that               
//*            has been migrated.                                               
//*                                                                             
//*           KEYRNGID - REXX EXEC ... HSM.SAMPLE.TOOL(KEYRNGID)                
//*                                                                             
//*           RESULTS WRITTEN TO SYSTSPRT DD CARD.                              
//*                                                                             
//*  THE ATEMP FILE HOLDS 1000 CDS RECORDS, AND WILL BE 3-9                     
//*  CYLINDERS IN SIZE, DEPENDING ON THE RECORD SIZES. THE                      
//*  LRECL 6552 HANDLES THE LARGEST RECORD POSSIBLE IN HSM.                     
//*                                                                             
//****************************************************************              
//INDATA    DD DSN=?MCDSNAME,DISP=SHR                                           
//ATEMP     DD DSNAME=&&ATEMP,DISP=(NEW,PASS),DSORG=PS,                         
//             LRECL=6552,RECFM=VB,SPACE=(CYL,(3,1)),                           
//             UNIT=SYSDA                                                       
//SYSTSPRT  DD SYSOUT=*                                                         
//SYSEXEC   DD DSN=HSM.SAMPLE.TOOL,DISP=SHR                                     
//SYSTSIN   DD *                                                                
  KEYRNGID                                                                      
/*                                                                              
./ ADD NAME=BCDSKEYR                                                            
//BCDSKEYR JOB ?JOBPARM                                                         
//*                                                                             
//************************************************************** @09A*          
//* This is a sample job to identify backed up VSAM key range        *          
//* datasets that were backed up using HSM as the data mover.        *          
//*                                                                  *          
//* Following are fields identified that must be changed to execute  *          
//* this batch job:                                                  *          
//*                                                                  *          
//* ?JOBPARM  - Job card with appropriate information for your       *          
//*             installation.                                        *          
//*                                                                  *          
//* ?BCDSNAME - Name of the control data set (data component name)   *          
//*             that you want to process.                            *          
//*                                                                  *          
//* ?BCDSOUT  - Name of the data set that will contain the output    *          
//*             of this job.                                         *          
//*                                                                  *          
//* Note: If using RLS to share CDSs defined with SHAREOPTIONS(3,x), *          
//* DFHSM must be shutdown on all sharing hosts for the program to   *          
//* execute successfully.  If it is inconvenient to shutdown DFHSM   *          
//* on all sharing hosts, use the CDS backup copy that is created at *          
//* Autobackup or Backvol CDS time in place of the active BCDS to    *          
//* successfully run the program.  Simply Restore the BCDS backup    *          
//* copy to a new name and then run the Exec against the restored    *          
//* copy.                                                            *          
//************************************************************** @09A*          
//*                                                                             
//*------------------------------------------------------------------           
//SORT1   EXEC PGM=ICETOOL,REGION=4096K                                         
//*------------------------------------------------------------------           
//TOOLMSG  DD  SYSOUT=*                                                         
//DFSMSG   DD  SYSOUT=*                                                         
//SYSPRINT DD  SYSOUT=*                                                         
//SORKWK01 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))                                   
//SORKWK02 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))                                   
//BCDS     DD  DISP=SHR,DSN=?BCDSNAME                                           
//CMDS     DD  DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,                              
//             DSN=?BCDSOUT,                                                    
//             DCB=(LRECL=500,BLKSIZE=20500,RECFM=VB),                          
//             SPACE=(CYL,(9,9),RLSE)                                           
//*MSGOUT1  DD  SYSOUT=*                                                        
//*SYSOUT   DD  SYSOUT=*                                                        
//TOOLIN    DD *                                                                
   COPY FROM(BCDS) TO(CMDS) USING(CPY1)                                         
/*                                                                              
//CPY1CNTL  DD *                                                                
 OPTION VLSCMP                                                                  
 RECORD TYPE=V                                                                  
 INCLUDE COND=((51,1,BI,EQ,X'24'),AND,(306,1,BI,EQ,B'..1.....'),AND,            
    (156,1,BI,EQ,B'..0.....'))                                                  
/*                                                                              
./ ADD NAME=PREMERGE                                                            
//PREMERGE JOB ?JOBPARM                                                         
//*                                                                             
//*********************************************************************         
//*  THIS IS A SAMPLE JOB THAT MAY ASSIST IN THE PLANNING OF A        *         
//*  CDS MERGE.  THIS JOB WILL COMPARE TWO CDSs AND CREATE A          *         
//*  REPORT THAT WILL LIST THE DUPLICATE KEYS BETWEEN THEM.           *         
//*  THIS JOB WILL NEED TO BE RUN FOR EACH OF THE THREE CDS RECORDS   *         
//*  (MCDSs, BCDSs, AND OCDSs).  THIS JOB COMPARES SINGLE CLUSTER     *         
//*  CDSs, BUT MAY BE MODIFIED TO SUPPORT MORE THAN 2 CDSs BEING      *         
//*  MERGED OR A MULTICLUSTERED CDS ENVIRONMENT.  FOR THIS THE        *         
//*  JOB NEEDS TO BE MODIFIED.  CURRENTLY THERE IS ONLY A SYS1CDS     *         
//*  DD AND A SYS2CDS DD DEFINED.  FOR MULTICLUSTERING OR MORE        *         
//*  THAN 2 CDSs BEING MERGED, DD CARDS WOULD NEED TO BE              *         
//*  ESTABLISHED FOR EACH OF THE CDSs TO BE CONSIDERED.  THEN         *         
//*  COPY COMMANDS WOULD NEED TO BE ADDED TO COPY ALL OF THE          *         
//*  CDSs OR CLUSTERS INTO THE ALLKEYS FILE BEFORE THE SORT IS        *         
//*  DONE. THE REPORT CREATED WILL THEN LIST ALL OF THE DUPLICATE     *         
//*  KEYS BETWEEN THE RECORDS COMPARED.                               *         
//*                                                                   *         
//*  Note:  Before merging the CDSes, it is recommended that AUDIT be *         
//*  run against all CDSes to ensure that all errors are corrected.   *         
//*                                                                   *         
//*  The fields that need to be specified for this job are as         *         
//*  follows:                                                         *         
//*                                                                   *         
//*  ?CDSNAME1 = First host cds for premerge comparison               *         
//*                                                                   *         
//*  ?CDSNAME2 = Second host cds for premerge comparison              *         
//*                                                                   *         
//*  ?REPORTNAME = Output data set name of the report on the          *         
//*                duplicate keys between the CDSs compared           *         
//*                                                                   *         
//*                                                                   *         
//*                                                                   *         
//*  AFTER THE PREMERGE JOB IS RUN, IF ANY DUPLICATE KEYS             *         
//*  ARE FOUND HANDLE THEM AS FOLLOWS:                                *         
//*                                                                   *         
//*                                                                   *         
//*  MCDS duplicates that need to be considered when merging a        *         
//*  second host's CDSs into a copy of a first host's CDSs:           *         
//*                                                                   *         
//*  -(0) migrated data set records                                   *         
//*  Locate identical data sets and delete the migrated data          *         
//*  sets on the second host BEFORE merging the MCDSs so that         *         
//*  the MCA records get deleted and the migration space is           *         
//*  invalidated.                                                     *         
//*                                                                   *         
//*  -(4) migration volume record                                     *         
//*  If there are SMS volumes that have the same name on both         *         
//*  systems and they are system packs where it does not matter       *         
//*  which is kept then nothing should be done.  If, however,         *         
//*  they are not system packs then the data will need to be          *         
//*  moved to a different L0 DASD, L1 DASD, OR L2 TAPE. To deal       *         
//*  with duplicates on DASD a FREEVOL can be performed.  With        *         
//*  duplicates that are on TAPE RECYCLE can be used.                 *         
//*                                                                   *         
//*  -(10) MCRx migration control record                              *         
//*  If there is a host with hostid of "x" on each system, then       *         
//*  a LIST TTOC SELECT(ASSOC) needs to be done on the second         *         
//*  host before merging that CDS into the first. A DELVOL            *         
//*  UNASSIGN needs to be done for each of the ML2 tapes in the       *         
//*  list. These will be available as unassigned ML2s in the target   *         
//*  system.  Alternatively these could be marked full.               *         
//*                                                                   *         
//*                                                                   *         
//*  BCDS duplicates that need to be considered when merging a        *         
//*  second host's CDSs into a copy of a first host's CDSs.           *         
//*                                                                   *         
//*  -(20) data set backup record                                     *         
//*  If multiple data sets of the same name have backup copies        *         
//*  then the backup versions of all the duplicate MCBs will be       *         
//*  lost when the CDSs are merged.  The MCCs, however, will          *         
//*  continue to exist, since they are disconnected from their        *         
//*  MCB.  A BDELETE will need to be done on each and every           *         
//*  backup version of these duplicates before a merge is done.       *         
//*  If the data sets both need to be kept then rename the user       *         
//*  data set on the second system before BDELETEing the backup       *         
//*  versions.                                                        *         
//*                                                                   *         
//*  -(22) dump class definition                                      *         
//*  If there is one dump class defined on both systems               *         
//*  and the definition is different, make the options                *         
//*  of both occurrences of this class the same or change all uses on *         
//*  one system to a different class name, define this new            *         
//*  class, and then delete the one it replaces.                      *         
//*                                                                   *         
//*  -(2C) backup volume record                                       *         
//*  In the case of backup tape duplicates a RECYCLE should be        *         
//*  performed to move data to non-duplicate tapes.                   *         
//*                                                                   *         
//*  -(30) BVR record                                                 *         
//*  There may be many duplicates  among the daily, spill, and        *         
//*  unassigned records.  These duplicates can be ignored             *         
//*  during the merger.                                               *         
//*  After bringing up the merged system a FIXCDS                     *         
//*  BVR REFRESH should be performed followed by a CDS backup         *         
//*  before any backup volumes are used.  The BVR REFRESH will        *         
//*  set on a flag that as the CDS backup concludes successfully      *         
//*  it will build the new format BVR records from the MCT            *         
//*  records of the merged BCDS and remove all old BVR records        *         
//*                                                                   *         
//*  -(OCDS)                                                          *         
//*  In this case duplicates will be addressed by the RECYCLE         *         
//*  command as mentioned in the type 4 and 2C records explained.     *         
//*                                                                   *         
//****************************************************************@ZRC*         
//SORT1   EXEC PGM=ICETOOL,REGION=4096K                                         
//SYSPRINT DD  SYSOUT=*                                                         
//TOOLMSG  DD  SYSOUT=*                                                         
//DFSMSG   DD  SYSOUT=*                                                         
//SYS1CDS  DD  DISP=SHR,                                                        
//             DSN=?CDSNAME1                                                    
//SYS2CDS  DD  DISP=SHR,                                                        
//             DSN=?CDSNAME2                                                    
//* DD cards can be defined for other CDSs to be                                
//* considered for the premerge duplicates                                      
//* report                                                                      
//ALLKEYS  DD  DISP=(MOD,PASS),UNIT=SYSDA,                                      
//             DCB=(LRECL=100,BLKSIZE=0,RECFM=VB),                              
//             SPACE=(CYL,(50,10),RLSE),                                        
//             DSN=&&ALLKEYS                                                    
//SUMKEYS  DD  DISP=(MOD,PASS),UNIT=SYSDA,                                      
//             DCB=(LRECL=100,BLKSIZE=0,RECFM=VB),                              
//             SPACE=(CYL,(50,10),RLSE),                                        
//             DSN=&&SUMKEYS                                                    
//DUPKEYS  DD  DISP=(MOD,PASS),UNIT=SYSDA,                                      
//             DCB=(LRECL=100,BLKSIZE=0,RECFM=VB),                              
//             SPACE=(CYL,(50,10),RLSE),                                        
//             DSN=&&DUPKEYS                                                    
//TEMP     DD  DISP=(NEW,CATLG),UNIT=SYSDA,                                     
//             DSN=&&TEMP1,                                                     
//             DCB=(*.DUPKEYS),                                                 
//             SPACE=(TRK,(1,5),RLSE)                                           
//DISPOUT  DD  DISP=(NEW,CATLG),UNIT=SYSDA,                                     
//             SPACE=(TRK,(1,5),RLSE),                                          
//             DSN=?REPORTNAME                                                  
//MSGOUT1  DD  SYSOUT=*                                                         
//SYSOUT   DD  SYSOUT=*                                                         
//TOOLIN   DD  *                                                                
* copy the keys from the sys1 CDS to the ALLKEYS file                           
   COPY FROM(SYS1CDS) TO(ALLKEYS) USING(ALL1)                                   
* copy the keys from the sys2 CDS to the ALLKEYS file                           
   COPY FROM(SYS2CDS) TO(ALLKEYS) USING(ALL1)                                   
* copy all other instance of this type CDS into ALLKEYS                         
* for consideration in the duplicate keys report                                
                                                                                
* sum the counter fields added to the record keys                               
   SORT FROM(ALLKEYS) TO(SUMKEYS) USING(SUM1)                                   
* copy the duplicate keys                                                       
   COPY FROM(SUMKEYS) TO(DUPKEYS) USING(DUP1)                                   
* prints a report on duplicate keys found, sorted by MCHTYPE                    
   SORT FROM(DUPKEYS) TO(TEMP) USING(SRT1)                                      
   DISPLAY FROM(TEMP) LIST(DISPOUT) -                                           
   LINES(999) -                                                                 
   HEADER('MCHTYPE') ON(51,1,HEX) -                                             
   HEADER('KEY') ON(5,44,CH) -                                                  
   BLANK                                                                        
//ALL1CNTL DD *                                                                 
 OUTREC FIELDS=(1,4,5,64,X'0001')                                               
/*                                                                              
//SUM1CNTL DD *                                                                 
 SORT FIELDS=(5,44,BI,A)                                                        
 SUM FIELDS=(69,2,BI)                                                           
/*                                                                              
//DUP1CNTL DD *                                                                 
 INCLUDE COND=(69,2,BI,GT,X'0001')                                              
 OUTREC FIELDS=(1,4,5,64)                                                       
/*                                                                              
//SRT1CNTL DD  *                                                                
 SORT FIELDS=(51,1,BI,A)                                                        
/*                                                                              
./ ADD NAME=HALTER                                                              
/* REXX - HALTER                                             @02A*/             
/****************************************************************               
 This program modifies the STORCLAS and/or MGMTCLAS of a migrated               
 data set.  These must be 1..8 characters in length.  This program              
 invokes IDCAMS ALTER directly.  These classes are passed to the  @WIC          
 ACS routines during recall to influence the final STORCLAS                     
 and MGMTCLAS.  This program will work for data sets that are                   
 migrated or on Level 0 DASD.                                     @WIC          
 ****************************************************************               
 To invoke from TSO, ISPF 3.4 Line Command, or PGM=IKJEFT01:                    
    HALTER MGMTCLAS(xxxx) STORCLAS(yyyy) dsn                                    
    HALTER MC(xxxx) SC(yyyy) dsn                                                
                                                                                
 You may specify either MGMTCLAS or STORCLAS or both                            
 Data Set Name follows standard TSO conventions, either                         
 specify fully-qualified name in quotes 'SYSPREF.data.set'                      
 or allow TSO to prefix your data set without quotes.                           
 Issuer must be authorized to alter the data sets specified.      @WIC          
 ****************************************************************/              
                                                                                
PARSE ARG PARM                                                                  
parse upper var parm parms                                                      
none='N/A'; sc=none; mc=none                                                    
if pos('STORCLAS(',parms)>0 then do                                             
   parse var parms a 'STORCLAS(' sc ')' b                                       
   parms = a b                                                                  
   end                                                                          
if pos('SC(',parms)>0 then do                                                   
   parse var parms a 'SC(' sc ')' b                                             
   parms = a b                                                                  
   end                                                                          
if sc ^= none then do                                                           
   sc = strip(sc)                                                               
   len_sc = right(length(sc),2,'0')                                             
   if len_sc>='01' & len_sc<='08' then provided_sc = Y                          
   else say "Invalid Length for storage class("sc") ......"parms                
   end                                                                          
if pos('MGMTCLAS(',parms)>0 then do                                             
   parse var parms a 'MGMTCLAS(' mc ')' b                                       
   parms = a b                                                                  
   end                                                                          
if pos('MC(',parms)>0 then do                                                   
   parse var parms a 'MC(' mc ')' b                                             
   parms = a b                                                                  
   end                                                                          
if mc ^= none then do                                                           
   mc = strip(mc)                                                               
   len_mc = right(length(mc),2,'0')                                             
   if len_mc>='01' & len_mc<='08' then provided_mc = Y                          
   else say "Invalid Length for management class("mc") ......"parms             
   provided_mc = Y                                                              
   end                                                                          
dsn = strip(parms)                                                              
idcops = ''                                                                     
if provided_sc = Y then do                                                      
   idcops = idcops 'STORCLAS('sc')'                       /* @WIC*/             
   end                                                                          
if provided_mc = Y then do                                                      
   idcops = idcops 'MGMTCLAS('mc')'                       /* @WIC*/             
   end                                                                          
rc = 0                                                                          
Address TSO "ALTER "dsn" "idcops                          /* @WIC*/             
exit rc                                                                         
./ ADD NAME=ABARPOST                                                            
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name                                            */         
/*                                                                   */         
/*  Output: 1) Abars Activity Log                                    */         
/*          2) ARECOVER statements                                   */         
/*          3) DSN Report with detail                                */         
/*                                                                   */         
/*PROPRIETARY V3 STATEMENT                                           */         
/*Licensed Materials - Property of IBM                               */         
/*5650-ZOS                                                           */         
/*Copyright IBM Corp. 1993,2017                                  @EYC*/         
/*END PROPRIETARY V3 STATEMENT                                       */         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit .                                                             
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
logrc = 0                                                                       
stat = msg('OFF')                                                               
address TSO                                                                     
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
logrc = rc                                                                      
parse var result dcoldsn ardsn detpre .                                         
ardsn = "'" || ardsn || "(" || iagname || ")'"                                  
/*********************************************************************/         
/* locate the activity log                                           */         
/*********************************************************************/         
call dr14 iagname                                                               
logrc = rc                                                                      
logdsn = result                                                                 
/*********************************************************************/         
/* attempt log dataset allocation and parse                          */         
/*   copy the log to sysout, create arecover statements and DSN rpt  */         
/*********************************************************************/         
call dr21 iagname tunit logdsn ardsn detpre                                     
logrc = result                                                                  
/*********************************************************************/         
/* write dsnrpt to LOG ddname                                        */         
/*********************************************************************/         
call dr22 iagname detpre                                                        
logrc = result                                                                  
quit:                                                                           
exit logrc                                                                      
./ ADD NAME=ARAUDIT                                                             
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name                                            */         
/*                                                                   */         
/*  Output: 1) Abars Activity Log                                    */         
/*          2) ARECOVER statements                                   */         
/*          3) DSN Report with detail                                */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname .                                                                   
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
logrc = 0                                                                       
stat = msg('OFF')                                                               
address TSO                                                                     
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn ardsn detpre loglog                                    
ardsn = "'" || ardsn || "(" || iagname || ")'"                                  
/*********************************************************************/         
/* allocate the log of logs dataset and look to see the logs         */         
/* created and how many times the aggregate has been executed        */         
/** and **************************************************************/         
/* allocate the arecover parameters dataset to read the datasets     */         
/* and check for their existence                                 @ZRC*/         
/*********************************************************************/         
call dr41 iagname loglog ardsn                                                  
logrc = result                                                                  
return logrc                                                                    
./ ADD NAME=ARECPROC                                                            
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name                                            */         
/*                                                                   */         
/*  Output: 1) Abars Activity Log                                    */         
/*          2) ARECOVER statements                                   */         
/*          3) DSN Report with detail                                */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname .                                                                   
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
logrc = 0                                                                       
stat = msg('OFF')                                                               
address TSO                                                                     
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn ardsn detpre loglog                                    
ardsn = "'" || ardsn || "(" || iagname || ")'"                                  
/*********************************************************************/         
/* allocate the arecover parameters dataset to execute the           */         
/* arecover command for the aggregate                                */         
/*********************************************************************/         
call dr31 iagname ardsn                                                         
logrc = result                                                                  
/*********************************************************************/         
/* locate the activity log                                           */         
/*********************************************************************/         
call dr14 iagname                                                               
logdsn = result                                                                 
/*********************************************************************/         
/* process the activity log                                          */         
/*********************************************************************/         
call dr32 iagname logdsn loglog                                                 
exit logrc                                                                      
./ ADD NAME=ARECSNGL                                                            
/*REXX****************************************************************/         
/*  Function: Handle subset restore of an aggregate                  */         
/*                                                                   */         
/*  Input: Aggregate Name                                            */         
/*         Indsn sysin                                               */         
/*                                                                   */         
/*  Output: 1) Restart Dataset                                       */         
/*          2) ARECOVER Command                                      */         
/*          3) ARECOVER Activity Log                                 */         
/*                                                                   */         
/*  Copyright IBM Corp. 1995,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/* trace ?R */                                                                  
/*********************************************************************/         
arg iagname .                                                                   
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
logrc = 0                                                                       
stat = msg('OFF')                                                               
address TSO                                                                     
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn ardsn thlq loglog                                      
ardsn = "'" || ardsn || "(" || iagname || ")'"                                  
/*********************************************************************/         
/* parse the parameters supplied for accuracy                        */         
/*********************************************************************/         
call dr70 iagname ardsn                                                         
logrc = result                                                                  
/*********************************************************************/         
/* set up the restart dataset                                        */         
/*********************************************************************/         
call dr71 iagname ardsn thlq                                                    
/*********************************************************************/         
/* allocate the arecover parameters dataset to execute the           */         
/* arecover command for the aggregate                                */         
/*********************************************************************/         
call dr72 iagname ardsn                                                         
logrc = result                                                                  
/*********************************************************************/         
/* locate the activity log                                           */         
/*********************************************************************/         
call dr14 iagname                                                               
logdsn=result                                                                   
/*********************************************************************/         
/* process the activity log                                          */         
/*********************************************************************/         
call dr32 iagname logdsn loglog                                                 
exit logrc                                                                      
/*REXX****************************************************************/         
draudit:                                                                        
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name (s) in input dataset                       */         
/*                                                                   */         
/* Output: audit report of aggregate (s)                             */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec - none                             */         
/*********************************************************************/         
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
errors = 0                                                                      
tdsn = 0                                                                        
tagg = 0                                                                        
lines = 58                                                                      
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
"EXECIO 0 DISKR INCNTL (OPEN"                                                   
"EXECIO 0 DISKW AGSUMM (OPEN"                                                   
/*********************************************************************/         
/*   write the Summary ABARS Activity Log                            */         
/*********************************************************************/         
"execio 1 diskr INCNTL"                                                         
do while (rc = 0)                                                               
   tagg = tagg + 1 /* counting total aggregates */                              
   if lines > 56 then                                                           
      call rpthead                                                              
   parse pull iagname                                                           
   iagname=strip(iagname,b)                                                     
   call araudit iagname                                                         
   parse var result cdsn edsn                                                   
   push '   ' left(iagname,8) right(cdsn,7) right(edsn,7)                       
   "execio 1 diskw AGSUMM"                                                      
   lines = lines + 1                                                            
   errors = errors + edsn                                                       
   tdsn = tdsn + cdsn                                                           
   "execio 1 diskr INCNTL"                                                      
end                                                                             
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
push '0   Aggregates:' left(tagg,7) ' Datasets: ' tdsn ,                        
     ' Errors: ' errors                                                         
"execio 1 diskw AGSUMM"                                                         
/************************************************************/                  
"execio 0 diskr INCNTL (finis"                                                  
"execio 0 diskw agsumm (finis"                                                  
return 0;                                                                       
rpthead:                                                                        
/*********************************************************************/         
/* Write Report Heading                                              */         
/*********************************************************************/         
push "1   ABARS Arecover Aggregate Audit Summary Report      " ,                
      "              " date(usa)                                                
"execio 1 diskw agsumm"                                                         
push "0   Agname   DSNs    Errors "                                             
"execio 1 diskw agsumm"                                                         
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
lines = 4                                                                       
return 0;                                                                       
/*REXX****************************************************************/         
draudit:                                                                        
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name (s) in input dataset                       */         
/*                                                                   */         
/* Output: audit report of aggregate (s)                             */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec - none                             */         
/*********************************************************************/         
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
errors = 0                                                                      
tdsn = 0                                                                        
tagg = 0                                                                        
lines = 58                                                                      
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
"EXECIO 0 DISKR INCNTL (OPEN"                                                   
"EXECIO 0 DISKW AGSUMM (OPEN"                                                   
/*********************************************************************/         
/*   write the Summary ABARS Activity Log                            */         
/*********************************************************************/         
"execio 1 diskr INCNTL"                                                         
do while (rc = 0)                                                               
   tagg = tagg + 1 /* counting total aggregates */                              
   if lines > 56 then                                                           
      call rpthead                                                              
   parse pull iagname                                                           
   iagname=strip(iagname,b)                                                     
   call araudit iagname                                                         
   parse var result cdsn edsn                                                   
   push '   ' left(iagname,8) right(cdsn,7) right(edsn,7)                       
   "execio 1 diskw AGSUMM"                                                      
   lines = lines + 1                                                            
   errors = errors + edsn                                                       
   tdsn = tdsn + cdsn                                                           
   "execio 1 diskr INCNTL"                                                      
end                                                                             
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
push '0   Aggregates:' left(tagg,7) ' Datasets: ' tdsn ,                        
     ' Errors: ' errors                                                         
"execio 1 diskw AGSUMM"                                                         
/************************************************************/                  
"execio 0 diskr INCNTL (finis"                                                  
"execio 0 diskw agsumm (finis"                                                  
return 0;                                                                       
rpthead:                                                                        
/*********************************************************************/         
/* Write Report Heading                                              */         
/*********************************************************************/         
push "1   ABARS Arecover Aggregate Audit Summary Report      " ,                
      "              " date(usa)                                                
"execio 1 diskw agsumm"                                                         
push "0   Agname   DSNs    Errors "                                             
"execio 1 diskw agsumm"                                                         
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
lines = 4                                                                       
return 0;                                                                       
./ ADD NAME=DRAUDIT                                                             
/*REXX****************************************************************/         
draudit:                                                                        
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name (s) in input dataset                       */         
/*                                                                   */         
/* Output: audit report of aggregate (s)                             */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec - none                             */         
/*********************************************************************/         
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
errors = 0                                                                      
tdsn = 0                                                                        
tagg = 0                                                                        
lines = 58                                                                      
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
"EXECIO 0 DISKR INCNTL (OPEN"                                                   
"EXECIO 0 DISKW AGSUMM (OPEN"                                                   
/*********************************************************************/         
/*   write the Summary ABARS Activity Log                            */         
/*********************************************************************/         
"execio 1 diskr INCNTL"                                                         
do while (rc = 0)                                                               
   tagg = tagg + 1 /* counting total aggregates */                              
   if lines > 56 then                                                           
      call rpthead                                                              
   parse pull iagname                                                           
   iagname=strip(iagname,b)                                                     
   call araudit iagname                                                         
   parse var result cdsn edsn                                                   
   push '   ' left(iagname,8) right(cdsn,7) right(edsn,7)                       
   "execio 1 diskw AGSUMM"                                                      
   lines = lines + 1                                                            
   errors = errors + edsn                                                       
   tdsn = tdsn + cdsn                                                           
   "execio 1 diskr INCNTL"                                                      
end                                                                             
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
push '0   Aggregates:' left(tagg,7) ' Datasets: ' tdsn ,                        
     ' Errors: ' errors                                                         
"execio 1 diskw AGSUMM"                                                         
/************************************************************/                  
"execio 0 diskr INCNTL (finis"                                                  
"execio 0 diskw agsumm (finis"                                                  
return 0;                                                                       
rpthead:                                                                        
/*********************************************************************/         
/* Write Report Heading                                              */         
/*********************************************************************/         
push "1   ABARS Arecover Aggregate Audit Summary Report      " ,                
      "              " date(usa)                                                
"execio 1 diskw agsumm"                                                         
push "0   Agname   DSNs    Errors "                                             
"execio 1 diskw agsumm"                                                         
push "    -------- ------- -------"                                             
"execio 1 diskw agsumm"                                                         
lines = 4                                                                       
return 0;                                                                       
./ ADD NAME=DRBACKUP                                                            
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name, Unit Type                                 */         
/*                                                                   */         
/*  Output: Modified Inc/Ex/Acc/All list                             */         
/*          Result of abars abackup execution                        */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit execver input .                                               
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
  stat = msg('OFF')                                                             
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn arecprm thlq .                                         
/*********************************************************************/         
/* Parse input parameters and Flag any problems                      */         
/*********************************************************************/         
  call dr11 iagname tunit execver input                                         
  idsn = result                                                                 
  if result = 16 then                                                           
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* Read Dcollect Records and get the abars selection dataset         */         
/*********************************************************************/         
  call dr12 iagname dcoldsn                                                     
  output = result                                                               
  if result = 16 then                                                           
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* copy input to selection dataset                                   */         
/*********************************************************************/         
  call dr13 iagname idsn output                                                 
  if result ^ = 0 then                                                          
    do                                                                          
      endrc = result                                                            
      return endrc                                                              
    end                                                                         
/*********************************************************************/         
/* Run ABACKUP with Verify Option                                    */         
/*********************************************************************/         
  "HSEND WAIT ABACKUP" iagname tunit "VERIFY"                                   
   endrc = rc                                                                   
/*********************************************************************/         
/* locate the verify log                                             */         
/*********************************************************************/         
  call dr14 iagname                                                             
  logdsn = result                                                               
  if endrc > 0 then    /* from previous Verify Command */                       
    do                                                                          
      say "DRBACKUP: Aggregate Verify Failed, Check Report in" logdsn           
      endrc = 16                                                                
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* read the Read the log and look for datasets to exclude            */         
/*********************************************************************/         
  call dr15 iagname logdsn output thlq                                          
  idsn = result                                                                 
  if result = 16 then                                                           
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* copy revised input to selection dataset                           */         
/*********************************************************************/         
  call dr13 iagname idsn output                                                 
  if result ^ = 0 then                                                          
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* do the abackup from the modified control dataset                  */         
/*********************************************************************/         
   stat = msg(stat)                                                             
  "HSEND WAIT ABACKUP" iagname tunit execver                                    
   endrc = rc                                                                   
quit:                                                                           
/*********************************************************************/         
/* Clear ABARS control dataset #1                                    */         
/*********************************************************************/         
  call dr16 iagname output                                                      
/*********************************************************************/         
exit endrc                                                                      
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name, Unit Type                                 */         
/*                                                                   */         
/*  Output: List of datasets in the aggregate                        */         
/*          and their location                                       */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit execver input .                                               
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
  stat = msg('OFF')                                                             
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn .                                                      
/*********************************************************************/         
/* Verify Input dataset exists                                       */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    parse var input inputx '(' idsn                                             
    if lastpos(')',idsn) ^= 0 then                                              
      idsn = delstr(idsn,lastpos(')',idsn),1)                                   
    msdsn = sysdsn(idsn)                                                        
    if msdsn ^= 'OK' then   /* problem, flag what's wrong */                    
      do                                                                        
        say 'DRSCAN: Input Dataset' idsn '...' || msdsn                         
        return (16)                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Read Dcollect Records and get the abars selection dataset         */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr12 iagname dcoldsn                                                   
    output = result                                                             
    if result = 16 then                                                         
      do                                                                        
        endrc = result                                                          
        signal quit                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* copy input to selection dataset                                   */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr13 iagname idsn output                                               
    if result ^ = 0 then                                                        
      do                                                                        
        endrc = result                                                          
        return endrc                                                            
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Run ABACKUP with Verify Option                                    */         
/*********************************************************************/         
  "HSEND WAIT ABACKUP" iagname tunit "VERIFY"                                   
   endrc = rc                                                                   
/*********************************************************************/         
/* locate the verify log                                             */         
/*********************************************************************/         
  call dr14 iagname                                                             
  logdsn = result                                                               
  if endrc > 0 then    /* from previous Verify Command */                       
    do                                                                          
      say "DRSCAN: Aggregate Verify Failed, Check Report in" logdsn             
      endrc = 16                                                                
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* read the Read the log and look for datasets to exclude            */         
/*********************************************************************/         
  call dr51 iagname logdsn                                                      
  if result ^ = 0 then                                                          
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* Clear ABARS control dataset #1                                    */         
/*********************************************************************/         
quit:                                                                           
if input ^= '' then                                                             
  call dr16 iagname output                                                      
/*********************************************************************/         
exit endrc                                                                      
./ ADD NAME=DRSCAN                                                              
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name, Unit Type                                 */         
/*                                                                   */         
/*  Output: List of datasets in the aggregate                        */         
/*          and their location                                       */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit execver input .                                               
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
  stat = msg('OFF')                                                             
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn .                                                      
/*********************************************************************/         
/* Verify Input dataset exists                                       */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    parse var input inputx '(' idsn                                             
    if lastpos(')',idsn) ^= 0 then                                              
      idsn = delstr(idsn,lastpos(')',idsn),1)                                   
    msdsn = sysdsn(idsn)                                                        
    if msdsn ^= 'OK' then   /* problem, flag what's wrong */                    
      do                                                                        
        say 'DRSCAN: Input Dataset' idsn '...' || msdsn                         
        return (16)                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Read Dcollect Records and get the abars selection dataset         */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr12 iagname dcoldsn                                                   
    output = result                                                             
    if result = 16 then                                                         
      do                                                                        
        endrc = result                                                          
        signal quit                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* copy input to selection dataset                                   */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr13 iagname idsn output                                               
    if result ^ = 0 then                                                        
      do                                                                        
        endrc = result                                                          
        return endrc                                                            
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Run ABACKUP with Verify Option                                    */         
/*********************************************************************/         
  "HSEND WAIT ABACKUP" iagname tunit "VERIFY"                                   
   endrc = rc                                                                   
/*********************************************************************/         
/* locate the verify log                                             */         
/*********************************************************************/         
  call dr14 iagname                                                             
  logdsn = result                                                               
  if endrc > 0 then    /* from previous Verify Command */                       
    do                                                                          
      say "DRSCAN: Aggregate Verify Failed, Check Report in" logdsn             
      endrc = 16                                                                
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* read the Read the log and look for datasets to exclude            */         
/*********************************************************************/         
  call dr51 iagname logdsn                                                      
  if result ^ = 0 then                                                          
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* Clear ABARS control dataset #1                                    */         
/*********************************************************************/         
quit:                                                                           
if input ^= '' then                                                             
  call dr16 iagname output                                                      
/*********************************************************************/         
exit endrc                                                                      
./ ADD NAME=DRSEO                                                               
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name, Unit Type                                 */         
/*                                                                   */         
/*  Output: List of datasets in the aggregate                        */         
/*          and their location                                       */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit execver input .                                               
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
  stat = msg('OFF')                                                             
/*********************************************************************/         
/* setup constants                                                   */         
/*********************************************************************/         
call dr10                                                                       
parse var result dcoldsn .                                                      
/*********************************************************************/         
/* Verify Input dataset exists                                       */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    parse var input inputx '(' idsn                                             
    if lastpos(')',idsn) ^= 0 then                                              
      idsn = delstr(idsn,lastpos(')',idsn),1)                                   
    msdsn = sysdsn(idsn)                                                        
    if msdsn ^= 'OK' then   /* problem, flag what's wrong */                    
      do                                                                        
        say 'DRSEO: Input Dataset' idsn '...' || msdsn                          
        return (16)                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Read Dcollect Records and get the abars selection dataset         */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr12 iagname dcoldsn                                                   
    output = result                                                             
    if result = 16 then                                                         
      do                                                                        
        endrc = result                                                          
        signal quit                                                             
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* copy input to selection dataset                                   */         
/*********************************************************************/         
if input ^= '' then                                                             
  do                                                                            
    call dr13 iagname idsn output                                               
    if result ^ = 0 then                                                        
      do                                                                        
        endrc = result                                                          
        return endrc                                                            
      end                                                                       
  end                                                                           
/*********************************************************************/         
/* Run ABACKUP with Verify Option                                    */         
/*********************************************************************/         
  "HSEND WAIT ABACKUP" iagname tunit "VERIFY"                                   
   endrc = rc                                                                   
/*********************************************************************/         
/* locate the verify log                                             */         
/*********************************************************************/         
  call dr14 iagname                                                             
  logdsn = result                                                               
  if endrc > 0 then    /* from previous Verify Command */                       
    do                                                                          
      say "DRSEO: Aggregate Verify Failed, Check Report in" logdsn              
      endrc = 16                                                                
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* read the Read the log and look for datasets to exclude            */         
/*********************************************************************/         
  call dr61 iagname logdsn                                                      
  if result ^ = 0 then                                                          
    do                                                                          
      endrc = result                                                            
      signal quit                                                               
    end                                                                         
/*********************************************************************/         
/* Clear ABARS control dataset #1                                    */         
/*********************************************************************/         
quit:                                                                           
if input ^= '' then                                                             
  call dr16 iagname output                                                      
/*********************************************************************/         
exit endrc                                                                      
./ ADD NAME=DR10                                                                
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Output: constants used for ABARS Utilities                       */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/* utility dataset allocation defaults */                                       
dcoldsn = "'A10DLH.DCOLLECT.DATA'"                                              
arec    = "A10DLH.ABARS.ARECOVER.PARMS"                                         
thlq    = "temp."                                                               
loglog  = "A10DLH.ABARS.ARECOVER.LOGS"                                          
return dcoldsn arec thlq loglog                                                 
./ ADD NAME=DR11                                                                
/*REXX*/                                                                        
dr11:                                                                           
arg agname tunit execver input                                                  
/* *********************** */                                                   
/* * subroutine readparm * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * validates input parameters       ** */                                     
/* *  and fails exec with messages    ** */                                     
/* *  if problems are encountered.    ** */                                     
/* ************************************* */                                     
if agname  = '' | ,                                                             
   tunit   = '' | ,                                                             
   execver = '' | ,                                                             
   input   = ''   then                                                          
  do                                                                            
    say 'DRBACKUP: 4 Required parameters not supplied'                          
    say 'DRBACKUP: need Aggregate Name, Tape Unit, Execute/Verify, ',           
        'and Input DSN (fully qualified)'                                       
    return (16);                                                                
  end                                                                           
/* ************************************* */                                     
/* * check EXECUTE/VERIFY option      ** */                                     
/* * and test to see if it's good     ** */                                     
/* * Rich Sleger Spellcheck......     ** */                                     
/* ************************************* */                                     
if execver = 'EXECUTE' | ,                                                      
   execver = 'VERIFY' then                                                      
  nop                                                                           
else                                                                            
  do                                                                            
    say 'DRBACKUP:' execver ' MUST specify VERIFY or EXECUTE'                   
    return (16);                                                                
  end                                                                           
/* ************************************* */                                     
/* * pull dsn out of input parameter  ** */                                     
/* * and test to see if it's good     ** */                                     
/* ************************************* */                                     
parse var input inputx '(' idsn                                                 
if lastpos(')',idsn) ^= 0 then                                                  
  idsn = delstr(idsn,lastpos(')',idsn),1)                                       
msdsn = sysdsn(idsn)                                                            
if msdsn ^= 'OK' then                                                           
  do /* problem  flag what's wrong */                                           
    say 'DRBACKUP: valid input dataset required'                                
    say 'DRBACKUP:' input '...' || msdsn                                        
    return (16)                                                                 
  end                                                                           
return idsn;                                                                    
./ ADD NAME=DR12                                                                
/*REXX*/                                                                        
dr12:                                                                           
arg iagname dcoldsn                                                             
/* *********************** */                                                   
/* * subroutine readdcol * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * reads the dcollect records to    ** */                                     
/* * acquire information about the    ** */                                     
/* * aggregate                        ** */                                     
/* ************************************* */                                     
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
agnamef = 0                                                                     
/*********************************************************************/         
/* DCOLLECT Aggregate Group Record Description (rectype = 'AG')      */         
/*********************************************************************/         
/* Offset (dec) |  Length (bytes)  | Field Description               */         
/*********************************************************************/         
/* 1            |  24              | DCOLLECT Header                 */         
/* 1            |  4               |  RDW                            */         
/* 5            |  2               |  Record Type                    */         
/* 7            |  2               |  VERSION                        */         
/* 9            |  4               |  SMFID                          */         
/* 13           |  4               |  SMF style Timestamp            */         
/* 17           |  4               |  SMF style Datestamp            */         
/* 21           |  4               |  Reserved                       */         
/* 25           |  616             | AG Definition Record            */         
/* 25           |  2               |  AG Name Length                 */         
/* 27           |  30              |  AG Name                        */         
/* 57           |  8               |  TSO Userid doing last update   */         
/* 65           |  10              |  Date of last update            */         
/* 75           |   2              |  Reserved                       */         
/* 77           |   8              |  Time of last update            */         
/* 85           | 120              |  Description of Aggregate       */         
/* 205          |   1              |  Flags                          */         
/*              |                  |       (1... ....) - TOLENQ(YES) */         
/*              |                  |       (.1.. ....) - RETPD(YES)  */         
/*              |                  |       (..1. ....) -*COPIES(YES) */         
/*              |                  |       (...1 1111) - reserved    */         
/* 206          |   3              |  Reserved                       */         
/* 209          |   4              |  Retention Period               */         
/* 213          |   30             |  Destination                    */         
/* 243          |   33             |  Output DSN Prefix              */         
/* 276          |   1              |  Reserved                       */         
/* 277          |   44             |  Instruction DSN                */         
/* 321          |    8             |  Instruction Member Name        */         
/* 329          |  260             |  Array of DSNs (5)              */         
/*              |   44             |           DSN                   */         
/*              |    8             |           Member Name (if any)  */         
/* 589          |    2             |  Management Class Name Length -**/         
/* 591          |    30            |  Management Class Name -*       */         
/* 621          |    4             |  Number of Copies      -*       */         
/* 625          |    16            |  Reserved                       */         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
"allocate fi(input) da("dcoldsn") shr reuse"                                    
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: cannot allocate' dcolldsn '.  RC='rc                         
    exit rc                                                                     
  end                                                                           
"execio 1 diskr input"                                                          
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: Error reading' dcolldsn '.  RC='rc                           
    exit rc                                                                     
  end                                                                           
do while rc = 0 & agnamef = 0                                                   
   parse pull dcollrec                                                          
   parse var dcollrec 5 rectype 7                                               
   if rectype = 'AG' then /* aggregate record */                                
      do                                                                        
       parse var dcollrec 25 agnamel 27 agname 57 .                             
       aggname = substr(agname,1,c2d(agnamel))                                  
       if iagname = aggname then                                                
         do /* found our aggregate */                                           
           agnamef = 1                                                          
            /* get input dataset names */                                       
           parse var dcollrec 329 rectail 644                                   
           do n = 1 to 5                                                        
             parse var rectail 1 agidsn.n +44 agimem.n +8 rectail               
           end                                                                  
         end                                                                    
     end                                                                        
    "execio 1 diskr input"                                                      
end                                                                             
"execio 0 diskr input (finis"                                                   
"free fi(input)"                                                                
/* *************************** */                                               
/* * Delete the last record  * */                                               
/* * read from the queue.    * */                                               
/* * (didn't process til EOF)* */                                               
/* *************************** */                                               
if queued() = 1 then                                                            
  do                                                                            
    delstack                                                                    
  end                                                                           
/* ******************************* */                                           
/* * Check to see if we          * */                                           
/* * Didn't find a match for     * */                                           
/* * aggregate name (re-run, ... * */                                           
/* * need dcollect info current) * */                                           
/* ******************************* */                                           
if agnamef = 0 then                                                             
  do /* need to flag error */                                                   
    say 'DRBACKUP:' iagname 'aggregate not found in dcollect dsn',              
         dcoldsn                                                                
    return (16);                                                                
  end                                                                           
output = "'" || strip(agidsn.1,b) || "(" || strip(agimem.1,t) || ")'"           
return output;   /* remove for production  */                                   
/* ******************************* */                                           
/* * Check to see if there are   * */                                           
/* * more than one selection dsn * */                                           
/* * defined (error if there is).* */                                           
/* ******************************* */                                           
do i = 2 to 5                                                                   
  if agidsn.i ^= "" then                                                        
    do                                                                          
      say 'DRBACKUP:' iagname 'has multiple selection datasets defined'         
      return (16);                                                              
    end                                                                         
end                                                                             
output = "'" || strip(agidsn.1,b) || "(" || strip(agimem.1,t) || ")'"           
return output;                                                                  
./ ADD NAME=DR13                                                                
/*REXX*/                                                                        
dr13:                                                                           
arg agname idsn oputctl                                                         
/* *********************** */                                                   
/* * subroutine copyrecs * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * copies the aggregate's input     ** */                                     
/* *dataset to selection dataset      ** */                                     
/* ************************************* */                                     
/* ************************************* */                                     
/* * check it to see if it exists     ** */                                     
/* ************************************* */                                     
if idsn = oputctl then   /* problem, flag what's wrong */                       
  do                                                                            
    say 'DRBACKUP: Selection Dataset and input dataset are the same'            
    say 'DRBACKUP: Selection Dataset :' oputctl                                 
    say 'DRBACKUP:     Input Dataset :' idsn                                    
    return (16)                                                                 
  end                                                                           
parse var oputctl odsn '(' .                                                    
odsn = odsn || "'"                                                              
msdsn = sysdsn(odsn)                                                            
if msdsn = 'OK' | ,                                                             
   msdsn = 'UNAVAILABLE DATASET' then /* good, continue */                      
  do                                                                            
  "alloc fi(sysut2) da("oputctl") old"                                          
  end                                                                           
else /* so far so good             */                                           
  do                                                                            
    say 'DRBACKUP: Selection Dataset' odsn '...' || msdsn                       
    return (16)                                                                 
  end                                                                           
r = 0                                                                           
do while (rc ^= 0 & r ^= 6)                                                     
  r = r + 1                                                                     
  "wait 10"                                                                     
  "alloc fi(sysut2) da("oputctl") old"                                          
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: Reset of selection dataset unsuccessful' oputctl             
    return                                                                      
  end                                                                           
/* ************************************* */                                     
/* * do remaining allocations         ** */                                     
/* ************************************* */                                     
"alloc fi(sysut1) da("idsn") shr reuse"                                         
"alloc fi(sysin) dummy reuse"                                                   
"alloc fi(sysprint) dummy reuse"                                                
/* ************************************* */                                     
/* * copy to selection dataset        ** */                                     
/* ************************************* */                                     
"call 'sys1.linklib(iebgener)'"                                                 
"FREE FI(SYSUT1)"                                                               
"FREE FI(SYSUT2)"                                                               
return (0)                                                                      
./ ADD NAME=DR14                                                                
/*REXX****************************************************************/         
/*  GETLOG Subroutine                                                */         
/*********************************************************************/         
/*  Function:                                                        */         
/*      Passed the aggregate name, we will use the automate function */         
/*   "getvar" to obtain the log name of the last ABARS command for   */         
/*   this aggregate. Automate is scanning for the occurrence of a    */         
/*   "ARC6030I" message on the console and setting the variable for  */         
/*   us.                                                             */         
/*                                                                   */         
/*   Input: Aggregate Name                                           */         
/*                                                                   */         
/*  Output: Logdsn for the aggregate                                 */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                    */         
/*                                                                   */         
/****************************************************************@ZRC*/         
dr14:                                                                           
arg iagname, .                                                                  
stat = msg('OFF')   /* suppress messages to the job */                          
varname = "ABARS_" || iagname                                                   
"getvar " value(varname) logdsn                                                 
logdsn = "'" || logdsn || "'"                                                   
 /*"delvar " value(varname)*/                                                   
return logdsn                                                                   
./ ADD NAME=DR14AM                                                              
/*REXX****************************************************************/         
/*  GETLOG Subroutine                                                */         
/*********************************************************************/         
/*  Function:                                                        */         
/*      Passed the aggregate name, we will use the automate function */         
/*   "getvar" to obtain the log name of the last ABARS command for   */         
/*   this aggregate. Automate is scanning for the occurrence of a    */         
/*   "ARC6030I" message on the console and setting the variable for  */         
/*   us.                                                             */         
/*                                                                   */         
/*   Input: Aggregate Name                                           */         
/*                                                                   */         
/*  Output: Logdsn for the aggregate                                 */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                    */         
/*                                                                   */         
/****************************************************************@ZRC*/         
dr14:                                                                           
arg iagname, .                                                                  
stat = msg('OFF')   /* suppress messages to the job */                          
varname = "ABARS_" || iagname                                                   
"getvar " value(varname) logdsn                                                 
logdsn = "'" || logdsn || "'"                                                   
 /*"delvar " value(varname)*/                                                   
return logdsn                                                                   
./ ADD NAME=DR14NV                                                              
/*REXX****************************************************************/         
/*  GETLOG Subroutine                                                */         
/*********************************************************************/         
/*  Function:                                                        */         
/*      Passed the aggregate name, we will use the same PDS that     */         
/*   NETVIEW writes to obtain the activity log of the most recent    */         
/*   ABARS command for this aggregate.  NETVIEW is scanning for      */         
/*   the occurrence of an "ARC6030I on the console and updates this  */         
/*   PDS for us.                                                 @XRC*/         
/*                                                                   */         
/*   Input: Aggregate Name                                           */         
/*                                                                   */         
/*  Output: Logdsn for the aggregate                                 */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                    */         
/*                                                                   */         
/****************************************************************@ZRC*/         
dr14:                                                                           
arg iagname, .                                                                  
stat = msg('OFF')   /* suppress messages to the job */                          
"alloc fi(input) da('a10dlh.abarxref.pds(" || iagname || ")') shr reuse"        
"execio 1 diskr input"                                                          
parse pull logdsn                                                               
"execio 0 diskr input (close"                                                   
"free fi(input)"                                                                
logdsn = "'" || logdsn || "'"                                                   
return logdsn                                                                   
./ ADD NAME=DR15                                                                
/*REXX****************************************************************/         
dr15:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Activity Log Dataset,                                     */         
/*         ABARS Selection DSN #1,                                   */         
/*                                                                   */         
/*  Output: Revised aggregate control cards                          */         
/*          (ABARS Selection DSN #1)                                 */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname actlog output thlq .                                                
/*********************************************************************/         
/* Constants and Flags (global to subroutines)                       */         
/*********************************************************************/         
look = 'OFF'                                                                    
m = 0                                                                           
smc1 = 0   /* counter for the # of datasets*/                                   
smc2 = 0   /* counter for the # of arcive'd datasets*/                          
smc3 = 0   /* counter for the # of non-arcive'd datasets*/                      
include = 'INCLUDE ('                                                           
exclude = 'EXCLUDE ('                                                           
accompa = 'ACCOMPANY ('                                                         
allocat = 'ALLOCATE ('                                                          
ii = 0   /* counters for the # of lines per occurrence @ZRC*/                   
jj = 0   /* counters for the # of lines per occurrence @ZRC*/                   
kk = 0   /* counters for the # of lines per occurrence @ZRC*/                   
ll = 0   /* counters for the # of lines per occurrence @ZRC*/                   
text. = ''                                                                      
idsn = "'" || thlq || "SELECT." || iagname || "'"                               
/*********************************************************************/         
/* Text is an internal data structure for ABARS control statements   */         
/* it has 3 levels of qualification                                  */         
/* Text.a.b.c                                                        */         
/*     "a" is 1 - 4 for include, exclude, allocate, or accompany     */         
/*       "b" is the number of occurrences of the control card    @ZRC*/         
/*        "c" is the number of statements under "control"            */         
/*********************************************************************/         
/*********************************************************************/         
/* The control statements follow two paths (providing all exist)     */         
/* 1)the exclude/include statements are dealt with from the          */         
/*   subroutines readlog and writeinc                                */         
/* 2)the allocate/accompany statements are dealt with from the       */         
/*   subroutines allocacc and writeaa                                */         
/* These statements merge in the selection dataset prior to          */         
/* executing the abackup execute for the aggregate.                  */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*trace*?r************************************************************/         
  stat = msg('OFF')                                                             
call readlog                                                                    
if result > 0 then signal quit                                                  
call allocacc                                                                   
if result > 0 then signal quit                                                  
call writeinc                                                                   
if result > 0 then signal quit                                                  
call writeaa                                                                    
quit:                                                                           
return idsn;                                                                    
readlog:                                                                        
/* *********************** */                                                   
/* * subroutine readlog  * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * allocates the backup log dataset ** */                                     
/* * the reads the backup activity    ** */                                     
/* * log to eliminate archive data    ** */                                     
/* ************************************* */                                     
/*********************************************************************/         
/*   start with opening and reading the ABARS Verify Activity Log    */         
/*********************************************************************/         
stat = msg('OFF')                                                               
"allocate fi(input) da("actlog") shr reuse"                                     
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: Error allocating log dsn' actlog '.  RC='rc                  
    return 16;                                                                  
  end                                                                           
/*********************************************************************/         
/*   parse the abars activity log for dataset names                  */         
/*********************************************************************/         
"execio 1 diskr input"                                                          
do while rc = 0                                                                 
   parse pull abarorec                                                          
   parse var abarorec 2 abarmsg 10 .                                            
   if abarmsg = 'ARC6004I' then /* msg from an EXECUTE log (bad)*/              
      do                                                                        
        say 'DRBACKUP: Log not from ABACKUP VERIFY' logdsn                      
        say 'DRBACKUP: Check Automated Operations, wrong log' actlog            
        return (16);                                                            
      end                                                                       
   if abarmsg = 'ARC6166I' then /* start of dataset names */                    
     do /* read the next record */                                              
       "execio 1 diskr input"                                                   
       parse pull abarorec                                                      
       parse var abarorec abart1 abart2 .                                       
       if abart1 = 'INCLUDE/EXCLUDE' | ,                                        
          abart2 = 'INCLUDE/EXCLUDE' then                                       
         look = 'ON'                                                            
       else                                                                     
         look = 'OFF'                                                           
     end                                                                        
   if abarmsg = 'ARC6250I' then /* msg proceeding DSNs for DFSMShsm */          
      look = 'OFF'                                                              
   if abarmsg = 'ARC6379I' then /* Dataset Count Fix 9/8/94         */          
      look = 'OFF'              /* Dataset Count Fix 9/8/94         */          
   if abarmsg = 'ARC6055I' then /* msg proceeding DSNs for DFHSM 2.6*/          
      look = 'OFF'                                                              
   if look = 'ON' then                                                          
/*********************************************************************/         
/*   Look for Dataset names                                          */         
/*********************************************************************/         
     do                                                                         
       parse var abarorec 2 abarnull 4 .                                        
       if abarnull = '  '  then  /* it is a dataset name */                     
         do                                                                     
           smc1 = smc1 + 1                                                      
           parse var abarorec 4 agdsn 48 .                                      
           agdsn = strip(agdsn,t)                                               
           aggdsn = "'" || agdsn || "'"                                         
           /* *************************** */                                    
           /* parse the output of listcat */                                    
           /* *************************** */                                    
           call outtrap ("cmdoput.")                                            
           "LISTC entry("aggdsn") volume"                                       
           do j = 1 to cmdoput.0                                                
             parse var cmdoput.j 8 volser 14 .                                  
             if volser = 'VOLSER' then                                          
               do                                                               
                j = cmdoput.0   /* end listcat process */                       
                 parse var cmdoput.j 26 volume 32 junk 52 devt 60 .             
                 /* ************************ */                                 
                 /* do we want this dataset? */                                 
                 /* ************************ */                                 
                 call dr151 iagname agdsn volume devt                           
                 why = result                                                   
                 if why ^= '' then                                              
                   do                                                           
                     say 'DRBACKUP: Problem with' agdsn why                     
                     smc2 = smc2 + 1                                            
                   end                                                          
                 else                                                           
                   do                                                           
                     smc3 = smc3 + 1                                            
                     incldsn.smc3 = agdsn                                       
                   end                                                          
               end                                                              
           end                                                                  
           call outtrap("off")                                                  
         end                                                                    
     end                                                                        
   "execio 1 diskr input"                                                       
end                                                                             
"execio 0 diskr input (finis"                                                   
"free fi(input)"                                                                
/* "delete" actlog  */                                                          
return 0;                                                                       
allocacc:                                                                       
/* *********************** */                                                   
/* * subroutine allocacc * */                                                   
/* *********************** */                                                   
/* **************************** */                                              
/* look for allocate/accompany */                                               
/* statements in selection dsn */                                               
/* **************************** */                                              
"alloc fi(abin) da("output") shr"                                               
"EXECIO 1 DISKR ABIN"                                                           
if rc ^= 0 then do                                                              
  say 'DRBACKUP: Error allocating selection dataset' output '.  RC='rc          
  exit rc                                                                       
end                                                                             
parse pull abarin                                                               
do while rc = 0                                                                 
  parse var abarin kword '(' abarin                                             
  kword = strip(kword,b)                                                        
  abarin = strip(abarin,t)                                                      
  if lastpos('-',abarin) ^= 0 then                                              
    abarin = delstr(abarin,lastpos('-',abarin),1)                               
  select                                                                        
    when abbrev(include,kword,1)  then                                          
      do                                                                        
        i = 1                                                                   
        ii = ii + 1                                                             
        text.i.ii.1 = abarin                                                    
        call mparse i ii text.i.ii.1                                            
      end                                                                       
    when abbrev(exclude,kword,1)  then                                          
      do                                                                        
        j = 2                                                                   
        jj = jj + 1                                                             
        text.j.jj.1 = abarin                                                    
        call mparse j jj text.j.jj.1                                            
      end                                                                       
    when abbrev(accompa,kword,1)  then                                          
      do                                                                        
        k = 3                                                                   
        kk = kk + 1                                                             
        text.k.kk.1 = abarin                                                    
        call mparse k kk text.k.kk.1                                            
      end                                                                       
    when abbrev(allocat,kword,1)  then                                          
      do                                                                        
        l = 4                                                                   
        ll = ll + 1                                                             
        text.l.ll.1 = abarin                                                    
        call mparse l ll text.l.ll.1                                            
      end                                                                       
    otherwise /* could be a comment */                                          
      do                                                                        
        nop                                                                     
      end                                                                       
  end                                                                           
  "execio 1 diskr abin"                                                         
  parse pull abarin                                                             
end                                                                             
"execio 0 diskr abin (finis"                                                    
"free fi(abin)"                                                                 
return 0;                                                                       
writeinc:                                                                       
/* *********************** */                                                   
/* * subroutine writeinc * */                                                   
/* *********************** */                                                   
/* **************************** */                                              
/* open cntl dataset and write */                                               
/* datasets to be included     */                                               
/* **************************** */                                              
/* "alloc fi(about) da("output") old" */                                        
msdsn = sysdsn(idsn)                                                            
if msdsn = 'OK' then   /* reuse dataset */                                      
   "alloc fi(about) da("idsn") old"                                             
else /* create a new dataset       */                                           
   "alloc fi(about) da("idsn") new space(2 1)" ,                                
    " recfm(f b) lrecl(80) blksize(0) dsorg(PS)"                                
say 'DRBACKUP: Candidate Datasets for backup:' smc1                             
say "DRBACKUP: Arcive'd Datasets Excluded:" smc2                                
say "DRBACKUP: Datasets Included:" smc3                                         
"EXECIO 0 DISKW ABOUT (OPEN"                                                    
preceed = ' INCLUDE('                                                           
if smc3 > 0 then                                                                
  do j = 1 to smc3                                                              
    if j ^= smc3  then                                                          
      do                                                                        
        push preceed || incldsn.j || ','                                        
       "EXECIO 1 DISKW ABOUT"                                                   
      end                                                                       
    else                                                                        
      do                                                                        
        push preceed || incldsn.j || ')'                                        
       "EXECIO 1 DISKW ABOUT"                                                   
      end                                                                       
    preceed = '         '                                                       
  end                                                                           
else                                                                            
  do                                                                            
    say "DRBACKUP: All datasets in aggregate have been eliminated"              
    return (16);                                                                
  end                                                                           
return 0;                                                                       
writeaa:                                                                        
/* *********************** */                                                   
/* * subroutine writeaa  * */                                                   
/* *********************** */                                                   
/* **************************** */                                              
/* follow this with allocate/   */                                              
/* accompany statements         */                                              
/* **************************** */                                              
if text.3.1.1 ^= '' then                                                        
  do                                                                            
    push ' ' accompa '-'                                                        
    "EXECIO 1 DISKW ABOUT"                                                      
    ddname = 'ABOUT'                                                            
    call commstmt 3 ddname                                                      
  end                                                                           
if text.4.1.1 ^= '' then                                                        
  do                                                                            
    push ' ' allocat '-'                                                        
    "EXECIO 1 DISKW ABOUT"                                                      
    ddname = 'ABOUT'                                                            
    call commstmt 4 ddname                                                      
  end                                                                           
push '  /* dataset modified by DRBACKUP' date(usa) time() '*/'                  
"EXECIO 1 DISKW ABOUT"                                                          
"execio 0 diskw about (finis"                                                   
"free fi(about)"                                                                
return 0;                                                                       
mparse: PROCEDURE EXPOSE TEXT.                                                  
arg u v excludes                                                                
/* *********************** */                                                   
/* * subroutine mparse   * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * separates  merged include/exclude** */                                     
/* * allocate/accompany statements and** */                                     
/* * splits them for use by DFDSS.    ** */                                     
/* ************************************* */                                     
fileiorc = 0                                                                    
paren = 1                                                                       
w = 1                                                                           
paren = paren + dr152('(',text.u.v.w) - dr152(')',text.u.v.w)                   
do while fileiorc = 0 & paren ^= 0                                              
  "execio 1 diskr abin"                                                         
  fileiorc = rc                                                                 
  w = w + 1                                                                     
  parse pull text.u.v.w                                                         
  if lastpos('-',text.u.w.v) ^= 0 then                                          
    text.u.w.v = delstr(text.u.w.v,lastpos('-',text.u.w.v),1)                   
  paren = paren + dr152('(',text.u.v.w) - dr152(')',text.u.v.w)                 
end                                                                             
return 0;                                                                       
commstmt: PROCEDURE EXPOSE TEXT.                                                
/* *********************** */                                                   
/* * function commstmt   * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * creates control statements       ** */                                     
/* * acceptable to both df/dss and    ** */                                     
/* * abars                            ** */                                     
/* ************************************* */                                     
arg cntlx ddnam exclx .                                                         
i = 1                                                                           
j. = 1                                                                          
j = 1                                                                           
do while (text.cntlx.i.j ^= '')                                                 
  do while (text.cntlx.i.j ^= '')                                               
   /* say text. cntlx i j '=' text.cntlx.i.j  */                                
      j.i = j.i + 1                                                             
      j = j + 1                                                                 
  end                                                                           
  j.i = j.i - 1                                                                 
  j = 1                                                                         
  i = i + 1                                                                     
end                                                                             
i = i - 1                                                                       
do x = 1 to i                                                                   
   do y = 1 to j.i                                                              
      linex = text.cntlx.x.y                                                    
      if x = i & y = j.i then /* last line */                                   
        do                                                                      
          if exclx ^= '' then   /* there are excludes too */                    
            do                                                                  
              push '   ' linex ' - '                                            
              'EXECIO 1 DISKW' ddnam                                            
            end                                                                 
          else  /* end of statements */                                         
            do                                                                  
              push '   ' linex                                                  
              'EXECIO 1 DISKW' ddnam                                            
            end                                                                 
        end                                                                     
      else                                                                      
        if x ^= i & y = j.i then /* end of intermediate */                      
          do                                                                    
            linex = delstr(linex,length(linex)) /* delete extra )*/             
            push '   ' linex ' - '                                              
            'EXECIO 1 DISKW' ddnam                                              
          end                                                                   
        else                                                                    
          do  /* its a line without continuation */                             
            push '   ' linex ' - '                                              
            'EXECIO 1 DISKW' ddnam                                              
          end                                                                   
   end                                                                          
return 0;                                                                       
./ ADD NAME=DR151                                                               
/*REXX****************************************************************/         
/*  ELIMDSN Subroutine                                               */         
/*********************************************************************/         
dr151:                                                                          
arg agname aggdsn volume devt                                                   
elimflag = ""                                                                   
if volume = 'ARCIVE' then                                                       
  do                                                                            
    elimflag = '...Archived dataset'                                            
  end                                                                           
return elimflag                                                                 
./ ADD NAME=DR152                                                               
/*REXX*/                                                                        
dr152:                                                                          
arg lookupv, abarin                                                             
/* *********************** */                                                   
/* * function count      * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * parses a line of input and counts** */                                     
/* * the # of occurrences of a string ** */                                     
/* ********************************@ZRC* */                                     
lastrp = 1                                                                      
idx = 0                                                                         
do while lastrp ^= 0                                                            
  lastrp = pos(lookupv,abarin,lastrp)                                           
  if lastrp > 0  then                                                           
    do                                                                          
      lastrp = lastrp + 1 /* search starting from the next pos */               
      idx = idx + 1                                                             
    end                                                                         
end                                                                             
return idx                                                                      
./ ADD NAME=DR16                                                                
/*REXX*/                                                                        
dr16:                                                                           
arg agname output                                                               
/* *********************** */                                                   
/* * subroutine clearctl * */                                                   
/* *********************** */                                                   
"alloc fi(exclout) da("output") old"                                            
/* ************************************* */                                     
/* * clears the 1st selection dataset.** */                                     
/* * first, loop until we get the     ** */                                     
/* *   selection dataset allocated    ** */                                     
/* ************************************* */                                     
r = 0                                                                           
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(exclout) da("output") old"                                          
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: Reset of selection dataset unsuccessful' output              
    return                                                                      
  end                                                                           
/* ************************************* */                                     
/* * Second, Run our records into     ** */                                     
/* *   the dataset to reset it        ** */                                     
/* ************************************* */                                     
"EXECIO 0 DISKW EXCLOUT (OPEN"                                                  
push '  /* dataset cleared by DRBACKUP' date(usa) time() '*/'                   
"EXECIO 1 DISKW EXCLOUT"                                                        
"execio 0 diskw EXCLOUT (finis"                                                 
"free fi(exclout)"                                                              
return 0;                                                                       
./ ADD NAME=DR21                                                                
/*REXX****************************************************************/         
dr21:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Activity Log Dataset,                                     */         
/*                                                                   */         
/* Output: ARECOVER dataset statements,                              */         
/*         Activity Log,                                             */         
/*         Detail DSN dataset                                        */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname tunit actlog ardsn detpre .                                         
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
look = 'OFF'                                                                    
dsnlist = 'off'                                                                 
k = 0                                                                           
cs = 0           /* copy set, support for multiple copies */                    
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/** set up a reporting dsn **********************************/                  
rptdsn = "'" || detpre || "dsndet." || iagname || "'"                           
msdsn = sysdsn(rptdsn)                                                          
if msdsn ^= 'OK' then                                                           
  do                                                                            
   "alloc da("rptdsn") new space(2 1)"    ,                                     
     " recfm(f b) lrecl(200) blksize(0) dsorg(PS)"                              
  end                                                                           
"alloc fi(dsndet) da("rptdsn") old"                                             
/*********************************************************************/         
/*   Locate and read the ABARS Activity Log                          */         
/*********************************************************************/         
if actlog = "''" then                                                           
  do                                                                            
    say "ABARPOST: no ABACKUP logs available for aggregate" iagname             
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("actlog") shr reuse"                                     
"EXECIO 0 DISKW dsndet (OPEN"                                                   
"EXECIO 0 DISKW LOG (OPEN"                                                      
/*********************************************************************/         
/*   parse the abars activity log for msgs,dsns,cond codes, etc      */         
/*********************************************************************/         
"execio 1 diskr input"                                                          
cdsn = 'no'                                                                     
execlog = 'no'                                                                  
do while (rc = 0)                                                               
   parse pull abarorec                                                          
   push abarorec                                                                
   "execio 1 diskw log"                                                         
   "execio 1 diskr input"                                                       
   parse var abarorec 2 ablogmsg 10                                             
   select                                                                       
     when ablogmsg = "ARC6055I" then  /* ending msg  */                         
       logrc = word(abarorec,words(abarorec))                                   
     when ablogmsg = "ARC6061I" then  /* Control File Message */                
       do                             /* Volser Follows       */                
         cdsn = 'yes'                                                           
         cs = cs + 1                                                            
         parse var abarorec 41 cntldsn.cs .                                     
       end                                                                      
     when dsnlist = 'on' then  /* gather detail on datasets   */                
       do                                                                       
         parse var abarorec 24 dssmsg 31                                        
         if dssmsg = 'ADR013I' then                                             
           do                                                                   
             dsnlist = 'off'                                                    
           end                                                                  
         else                                                                   
           do                                                                   
             call dr212 dssmsg, abarorec                                        
             if result ^= '' then                                               
               do                                                               
                 k = k + 1                                                      
                 dsnlist.k = '  /*' result '*/'                                 
               end                                                              
           end                                                                  
       end                                                                      
     when ablogmsg = "ARC6064I" then  /* mig/tape dsn fix 9/8/94 */             
       do                                                                       
         parse var abarorec 20 tmdsn .                                          
         k = k + 1                                                              
         dsnlist.k = '  /*' tmdsn '*/'                                          
         call dr213 tmdsn                                                       
       end                                                                      
     when ablogmsg = "ARC6004I" then  /* active execute log */                  
       do                                                                       
         execlog = 'yes'                                                        
         parse var abarorec 24 dssmsg 31                                        
         if dssmsg = 'ADR454I' then                                             
           dsnlist = 'on'                                                       
       end                                                                      
     when cdsn = 'yes' then  /* look for volser of cntl dsn */                  
       do                                                                       
         if sysvar(syshsm) = 2060 then  /* its dfhsm 2.6 */                     
           do                                                                   
             parse var abarorec cc cntlvol.cs .                                 
             if cc = 0 then                                                     
               cdsn = 'found'                                                   
           end                                                                  
         else  /* its DFSMS/hsm V1 */                                           
           if ablogmsg = "ARC6060I" then /* want the line before */             
             cdsn = 'found'                                                     
           else                                                                 
             do                                                                 
               parse var abarorec 2 nopre 4 .   /* Fix Volser 9/8/94 */         
               if nopre = '  ' then             /* Fix Volser 9/8/94 */         
                 parse var abarorec 4 cntlvol.cs .        /*  9/8/94 */         
             end                                                                
       end                                                                      
     otherwise                                                                  
       nop                                                                      
  end                                                                           
end                                                                             
/************************************************************/                  
"execio 0 diskr input (finis"                                                   
"execio 0 diskw dsndet (finis"                                                  
"free fi(input,dsndet)"                                                         
/************************************************************/                  
r = 0                                                                           
parse var ardsn arparms '(' .                                                   
arparms = arparms || "'"                                                        
mdsn = sysdsn(arparms)                                                          
if mdsn ^= 'OK' then                                                            
  do                                                                            
    say 'ABARPOST:' arparms '...' || mdsn                                       
    say 'ARECOVER parms not written for' iagname                                
    return logrc;                                                               
  end                                                                           
/************************************************************/                  
/**if dfhsm2.6, the last dataset is the instruction dataset**/                  
/**for auditing purposes, this dataset is unnecessary      **/                  
/************************************************************/                  
if sysvar(syshsm) = 2060 then  /* its dfhsm 2.6 */                              
  do                                                                            
    dsnlist.k = ''                                                              
    dsnlist.0 = k - 1                                                           
  end                                                                           
else                                                                            
  do                                                                            
/************************************************************/                  
/**if DFSMS1.1, the last two datasets are              @ZRC**/                  
/**the instruction dataset and the abackup log             **/                  
/**for auditing purposes, these datasets are unnecessary   **/                  
/************************************************************/                  
    dsnlist.k = ''                                                              
    k = k - 1                                                                   
    dsnlist.k = ''                                                              
    dsnlist.0 = k - 1                                                           
  end                                                                           
if cdsn = 'found' then                                                          
  do                                                                            
    CALL OUTTRAP 'CMDOUTPUT.',999                                               
    if cs = 1 then                                                              
      do                                                                        
        call dr211 iagname tunit cntldsn.1 cntlvol.1 actlog 1                   
        call dr211 iagname tunit cntldsn.1 cntlvol.1 actlog 2                   
      end                                                                       
    else                                                                        
      do                                                                        
        call dr211 iagname tunit cntldsn.1 cntlvol.1 actlog 1                   
        call dr211 iagname tunit cntldsn.2 cntlvol.2 actlog 2                   
      end                                                                       
    CALL OUTTRAP 'OFF',999                                                      
    "ALLOC FI(AROUT) DA("ardsn") old"                                           
    do while (rc ^= 0 & r ^= 20)                                                
      r = r + 1                                                                 
      "wait 15"                                                                 
      "ALLOC FI(AROUT) DA("ardsn") old"                                         
    end                                                                         
    if rc ^= 0 then                                                             
      do                                                                        
        say "ABARPOST: Unable to Allocate Arecover parms dataset" ardsn         
        return 16;                                                              
      end                                                                       
    "EXECIO * DISKW AROUT (STEM CMDOUTPUT."                                     
    "EXECIO * DISKW AROUT (STEM dsnlist. FINIS"                                 
    "FREE FI(AROUT)"                                                            
  end                                                                           
/************************************************************/                  
return logrc;                                                                   
dr212:                                                                          
/************************************************************/                  
/* REXX SUBROUTINE-DR212                                    */                  
/* takes the datasetnames from the abackup log records      */                  
/* and writes the dsn attributes to a file for later report */                  
/************************************************************/                  
arg dfdssmsg, abarorec                                                          
retrndsn = ''                                                                   
if dfdssmsg ^= '' then                                                          
  return retrndsn;                                                              
parse var abarorec 50 dsname 94                                                 
parse var abarorec 50 nmflg  64                                                 
parse var abarorec 50 apflg  52                                                 
dsnameq = "'" || strip(dsname,t) || "'"                                         
select                                                                          
 when nmflg  = 'CLUSTER NAME  '  then                                           
   do                                                                           
     parse var abarorec 65 compname 110                                         
     push compname 'CLUSTER'                                                    
    "execio 1 diskw dsndet"                                                     
     retrndsn = strip(compname,t)                                               
   end                                                                          
 when apflg = '  ' then /* text concerning path and aix */                      
     nop                                                                        
 when nmflg = 'CATALOG NAME  ' then                                             
     nop                                                                        
 when nmflg = 'COMPONENT NAME' then                                             
   do                                                                           
     parse var abarorec 65 compname 110                                         
     compname  = "'" || strip(compname,t) || "'"                                
     x = listdsi(compname)                                                      
     rc = outtrap('cmdoput.',999,noconcat)                                      
     "LISTC entry("compname") alloc"                                            
     do i = 1 to cmdoput.0                                                      
       parse var cmdoput.i 1 piece1 6 junk 8 piece2 21                          
       select                                                                   
         when  piece1 = 'DATA' then                                             
           comptype = piece1                                                    
         when  piece1 = 'INDEX' then                                            
           comptype = piece1                                                    
         when  piece1 = 'AIX' then                                              
           comptype = piece1                                                    
         when  piece2 = 'DATASET-OWNER' then                                    
           parse var cmdoput.i 53 credt 61                                      
         when  piece2 = 'RELEASE------' then                                    
           parse var cmdoput.i 53 expdt 61                                      
         when  piece2 = 'SPACE-TYPE---' then                                    
           do                                                                   
             parse var cmdoput.i 24 allotype 32                                 
             /* suppress the  dashes ('---') from listcat */                    
             x = lastpos('-',allotype) + 1                                      
             y = length(allotype)                                               
             allotype = substr(allotype,x,y)                                    
           end                                                                  
         when  piece2 = 'SPACE-PRI----' then                                    
           do                                                                   
             parse var cmdoput.i 26 prispace 32                                 
             /* suppress the  dashes ('---') from listcat */                    
             x = lastpos('-',prispace) + 1                                      
             y = length(prispace)                                               
             prispace = substr(prispace,x,y)                                    
           end                                                                  
         when  piece2 = 'SPACE-SEC----' then                                    
           do                                                                   
             parse var cmdoput.i 26 secspace 32                                 
             /* suppress the  dashes ('---') from listcat */                    
             x = lastpos('-',secspace) + 1                                      
             y = length(secspace)                                               
             secspace = substr(secspace,x,y)                                    
           end                                                                  
         when  piece2 = 'VOLSER-------' then                                    
           do                                                                   
             parse var cmdoput.i 56 cisize 61                                   
             parse var cmdoput.i 80 hiallo  90                                  
             parse var cmdoput.i 116 extents 119                                
             /* suppress the  dashes ('---') from listcat */                    
             x = lastpos('-',cisize) + 1                                        
             y = length(cisize)                                                 
             cisize = substr(cisize,x,y)                                        
             x = lastpos('-',hiallo) + 1                                        
             y = length(hiallo)                                                 
             hiallo = substr(hiallo,x,y)                                        
             x = lastpos('-',extents) + 1                                       
             y = length(extents)                                                
             extents = substr(extents,x,y)                                      
           end                                                                  
         when  piece2 = 'DEVTYPE------' then                                    
           do                                                                   
             parse var cmdoput.i 56 recptrk 61                                  
             parse var cmdoput.i 80 hiused  90                                  
             /* suppress the  dashes ('---') from listcat */                    
             x = lastpos('-',recptrk) + 1                                       
             y = length(recptrk)                                                
             recptrk = substr(recptrk,x,y)                                      
             x = lastpos('-',hiused) + 1                                        
             y = length(hiused)                                                 
             hiused = substr(hiused,x,y)                                        
           end                                                                  
         when  piece2 = 'VOLFLAG------' then                                    
           parse var cmdoput.i 27 multi 32                                      
         otherwise                                                              
           nop                                                                  
       end  /*select*/                                                          
     end                                                                        
     call outtrap("off")                                                        
     q = sysdsname 'VSAM    ' sysunit sysvolume sysdsorg,                       
         allotype hiallo hiused prispace secspace extents,                      
         credt sysrefdate expdt 'V' syslrecl,                                   
         cisize syspassword sysracfa sysupdated systrkscyl,                     
         recptrk sysadirblk sysudirblk multi                                    
     push q                                                                     
     "execio 1 diskw dsndet"                                                    
   end                                                                          
 otherwise                                                                      
/***************************************************************/               
/* non-vsam dataset                                            */               
/***************************************************************/               
     do                                                                         
       x = listdsi(dsnameq "NORECALL")                                          
       if sysreason  = 8 then /* tape dataset */                                
         q = dsname 'NONVSAM' 'TAPE'                                            
       else                                                                     
         q = sysdsname 'NONVSAM' sysunit sysvolume sysdsorg,                    
           sysunits sysalloc sysused sysprimary sysseconds sysextents,          
           syscreate sysrefdate sysexdate sysrecfm syslrecl,                    
           sysblksize syspassword sysracfa sysupdated systrkscyl,               
           sysblkstrk sysadirblk sysudirblk                                     
        push q                                                                  
       "execio 1 diskw dsndet"                                                  
       retrndsn = sysdsname                                                     
     end                                                                        
end /* select */                                                                
return retrndsn;                                                                
dr213:                                                                          
/************************************************************/                  
/* REXX SUBROUTINE-DR213                                    */                  
/* takes the datasetname  from the abackup log records      */                  
/* and writes the dsn attributes to a file for later report */                  
/* (tape and migrated datasets only)                        */                  
/************************************************************/                  
arg dsname                                                                      
retrndsn = ''                                                                   
dsnameq = "'" || strip(dsname,t) || "'"                                         
/***************************************************************/               
/* non-vsam dataset                                            */               
/***************************************************************/               
x = listdsi(dsnameq "NORECALL")                                                 
if sysreason  = 8 then /* tape dataset */                                       
  q = dsname 'NONVSAM' 'TAPE'                                                   
else                                                                            
  if sysreason  = 9 then /* tape dataset */                                     
    q = dsname 'NONVSAM' 'DASD' 'MIGRAT'                                        
    else                                                                        
      if sysreason  = 25 then /* tape dataset */                                
        q = dsname 'NONVSAM' 'TAPE' 'MIGRAT'                                    
      else                                                                      
        q = sysdsname '-ERROR-'                                                 
 push q                                                                         
"execio 1 diskw dsndet"                                                         
retrndsn = sysdsname                                                            
return retrndsn;                                                                
./ ADD NAME=DR211                                                               
/*REXX                                                  @XRC*/                  
dr211:                                                                          
arg iagname tunit cntldsn cntlvol logdsn i .                                    
/************************************************************/                  
/* REXX SUBROUTINE-genarec                                  */                  
/* codes the arecover statements (valid for dfhsm 2.6)      */                  
/* for this aggregate                                       */                  
/************************************************************/                  
/************************************************************/                  
/* REXX SUBROUTINE-genarec                                  */                  
/* codes the arecover statements (valid for dfsmshsm 1.1)   */                  
/* for this aggregate as comments                           */                  
/************************************************************/                  
if i = 1 then                                                                   
  do                                                                            
    SAY " HSEND WAIT ARECOVER "cntldsn"-"                                       
    SAY " VOLUMES("cntlvol") " tunit " REPLACE EXECUTE"                         
  end                                                                           
 else                                                                           
  do                                                                            
    SAY " /*HSEND WAIT ARECOVER-*/"                                             
    SAY " /*DATASETNAME("cntldsn") VOLUMES("cntlvol")-*/"                       
    SAY " /*" tunit " DSCONFLICT(REPLACE) EXECUTE *DFSMShsm11*/"                
    SAY " /* " logdsn "*/"                                                      
   end                                                                          
RETURN 0                                                                        
./ ADD NAME=DR22                                                                
dr22:                                                                           
arg iagname detpre .                                                            
stat = msg('OFF')                                                               
rptdsn = "'" || detpre || "dsndet." || iagname || "'"                           
"alloc fi(dsndet) da("rptdsn") old"                                             
"execio 1 diskr dsndet"                                                         
lines = 58                                                                      
page = 1                                                                        
do while (rc = 0)                                                               
   if lines > 57 then                                                           
     do                                                                         
       call DR221                                                               
     end                                                                        
   parse pull ,                                                                 
         sysdsname systyp sysunit sysvolume sysdsorg sysunits sysalloc,         
         sysused sysprimary sysseconds sysextents syscreate,                    
         sysrefdate sysexdate sysrecfm syslrecl sysblksize,                     
         syspassword sysracfa sysupdated systrkscyl sysblkstrk,                 
         sysadirblk sysudirblk                                                  
   push " " ,                                                                   
        left(sysdsname,44),                                                     
        sysunit,                                                                
        left(sysvolume,6),                                                      
        left(systyp,7),                                                         
        right(sysdsorg,5),                                                      
        left(sysunits,8),                                                       
        right(sysprimary,5),                                                    
        right(sysseconds,5),                                                    
        right(sysextents,3),                                                    
        syscreate,                                                              
        right(sysexdate,8),                                                     
        left(sysrecfm,5),                                                       
        right(sysblksize,7)                                                     
   "execio 1 diskw log"                                                         
   "execio 1 diskr dsndet"                                                      
   lines = lines + 1                                                            
end                                                                             
"execio 0 diskw log   (finis"                                                   
"execio 0 diskr dsndet (finis"                                                  
"free fi(dsndet)"                                                               
"delete "rptdsn                                                                 
return 0;                                                                       
dr221:                                                                          
/************************************************************/                  
/* REXX SUBROUTINE-DR221                                    */                  
/* report heading routine                                   */                  
/************************************************************/                  
push "1        ABARS DSN Detail Report for Aggregate:" ,                        
      iagname "      " date(usa) "   Page:" page                                
"execio 1 diskw log"                                                            
page = page + 1                                                                 
push "0  Dataset Name                               ",                          
     "UNIT VOLSER DSNType DSORG Alloc   ",                                      
     "Pri   Sec   Ext Credt    Expdt   ",                                       
     "RECFM BLKSIZE"                                                            
"execio 1 diskw log"                                                            
push "  -------------------------------------------- " || ,                     
     "---- ------ ------- ----- -------- ----- ----- " || ,                     
     "--- -------- -------- ----- -------"                                      
"execio 1 diskw log"                                                            
lines = 4                                                                       
return 0;                                                                       
./ ADD NAME=DR31                                                                
/*REXX****************************************************************/         
dr31:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset                                    */         
/*                                                                   */         
/* Output: ARECOVER statement execution,                             */         
/*         Activity Log,                                             */         
/*         log of arecover logs for audit purposes                   */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname ardsn .                                                             
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/* Find out which release of DFHSM is available                      */         
/*********************************************************************/         
 dfhsm = sysvar(syshsm)                                                         
/****DFHSM 2.6 is 2060 ***********************************************/         
/****DFSMShsm 1.1 is 1010 ********************************************/         
/*********************************************************************/         
/*   Locate and read the ABARS arecover parms dataset                */         
/*********************************************************************/         
r = 0                                                                           
if ardsn = "''" then                                                            
  do                                                                            
    say "ARECPROC: no ARECOVER Parms Dataset for aggregate" iagname             
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("ardsn") shr"                                            
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(input) da("ardsn") shr"                                             
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'ARECPROC: Check Syslog; Contention for parms DSN' ardsn                
    return (16);                                                                
  end                                                                           
/*********************************************************************/         
/*   parse the abars arecover parms dataset for control dsn & volser */         
/*********************************************************************/         
"execio * diskr input (finis"                                                   
"free fi(input)"                                                                
parse pull h1 h2 h3 h4                                                          
parse pull h5 h6 h7 h8 h9                                                       
delstack                                                                        
parse var h4 cdsn '-' .                                                         
if dfhsm ^= 2060 then                                                           
  do                                                                            
    cdsn = 'datasetname(' || cdsn || ')'                                        
    if h7 = 'REPLACE' then                                                      
      h7 = 'DSCONFLICT(REPLACE)'                                                
  end                                                                           
"hsend wait arecover" cdsn h5 h6 h7 h8                                          
say "hsend wait arecover" cdsn ,                                                
    h5 h6 h7 h8                                                                 
return rc;                                                                      
./ ADD NAME=DR31                                                                
/*REXX****************************************************************/         
dr31:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset                                    */         
/*                                                                   */         
/* Output: ARECOVER statement execution,                             */         
/*         Activity Log,                                             */         
/*         log of arecover logs for audit purposes                   */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname ardsn .                                                             
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/* Find out which release of DFHSM is available                      */         
/*********************************************************************/         
 dfhsm = sysvar(syshsm)                                                         
/****DFHSM 2.6 is 2060 ***********************************************/         
/****DFSMShsm 1.1 is 1010 ********************************************/         
/*********************************************************************/         
/*   Locate and read the ABARS arecover parms dataset                */         
/*********************************************************************/         
r = 0                                                                           
if ardsn = "''" then                                                            
  do                                                                            
    say "ARECPROC: no ARECOVER Parms Dataset for aggregate" iagname             
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("ardsn") shr"                                            
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(input) da("ardsn") shr"                                             
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'ARECPROC: Check Syslog; Contention for parms DSN' ardsn                
    return (16);                                                                
  end                                                                           
/*********************************************************************/         
/*   parse the abars arecover parms dataset for control dsn & volser */         
/*********************************************************************/         
"execio * diskr input (finis"                                                   
"free fi(input)"                                                                
parse pull h1 h2 h3 h4                                                          
parse pull h5 h6 h7 h8 h9                                                       
delstack                                                                        
parse var h4 cdsn '-' .                                                         
if dfhsm ^= 2060 then                                                           
  do                                                                            
    cdsn = 'datasetname(' || cdsn || ')'                                        
    if h7 = 'REPLACE' then                                                      
      h7 = 'DSCONFLICT(REPLACE)'                                                
  end                                                                           
"hsend wait arecover" cdsn h5 h6 h7 h8                                          
say "hsend wait arecover" cdsn ,                                                
    h5 h6 h7 h8                                                                 
return rc;                                                                      
./ ADD NAME=DR32                                                                
/*REXX****************************************************************/         
dr32:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Activity Log Dataset,                                     */         
/*                                                                   */         
/* Output: ARECOVER dataset statements,                              */         
/*         Activity Log,                                             */         
/*         Detail DSN dataset                                        */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname actlog loglog .                                                     
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
rclook = 'off'                                                                  
/*********************************************************************/         
/*   Locate and read the ABARS Activity Log                          */         
/*********************************************************************/         
if actlog = "''" then                                                           
  do                                                                            
    say "ARECPROC: no ARECOVER logs available for aggregate" iagname            
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("actlog") shr reuse"                                     
/*********************************************************************/         
"EXECIO 0 DISKW LOG (OPEN"                                                      
/*********************************************************************/         
/*   write the abars activity log                                    */         
/*********************************************************************/         
"execio 1 diskr input"                                                          
do while (rc = 0)                                                               
   parse pull abarorec                                                          
   parse var abarorec 2 arlogmsg 10                                             
   push abarorec                                                                
   "execio 1 diskw log"                                                         
   if arlogmsg = "ARC6103I" then  /* ending msg  */                             
       rclook = 'on'                                                            
   if rclook = 'on' then  /* ending msg  */                                     
       logrc = word(abarorec,words(abarorec))                                   
   "execio 1 diskr input"                                                       
end                                                                             
/************************************************************/                  
"execio 0 diskr input (finis"                                                   
"execio 0 diskw log (finis"                                                     
"free fi(input)"                                                                
/** set up the log of logs **********************************/                  
r = 0                                                                           
msdsn = sysdsn(loglog)                                                          
if msdsn ^= 'OK' then                                                           
  do                                                                            
   "alloc da("loglog") new space(2 1)"    ,                                     
     " recfm(f b) lrecl(80) blksize(0) dsorg(PS)"                               
  end                                                                           
"alloc fi(logolog) da("loglog") mod"                                            
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(logolog) da("loglog") mod"                                          
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'ARECPROC: Mod to Log of Logs Dataset unsuccessful' loglog              
    return 16;                                                                  
  end                                                                           
"EXECIO 0 DISKW logolog (OPEN"                                                  
push iagname ' ' actlog                                                         
"EXECIO 1 DISKW logolog (FINIS"                                                 
"free fi(logolog)"                                                              
return 0;                                                                       
./ ADD NAME=DR41                                                                
dr41:                                                                           
/*REXX****************************************************************/         
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         log of logs                                               */         
/*                                                                   */         
/* Output: ARECOVER audit of datasets in the aggregate               */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
arg iagname loglog ardsn .                                                      
lines = 58                                                                      
page = 1                                                                        
call dr411 iagname loglog                                                       
call dr412 iagname ardsn                                                        
ok = result                                                                     
return ok;                                                                      
dr411:                                                                          
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         log of logs                                               */         
/*                                                                   */         
/* Output: ARECOVER audit of datasets in the aggregate               */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*               Copyright (c) 1993.  All Rights Reserved.           */         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname loglog .                                                            
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/* See how many times ARECOVER has ran                               */         
/*********************************************************************/         
r = 0                                                                           
"alloc fi(logolog) da('"loglog"') shr"                                          
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(logolog) da('"loglog"') shr"                                        
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRBACKUP: Allocation of LOGS dataset unsuccessful' loglog              
    return                                                                      
  end                                                                           
"EXECIO 1 DISKR logolog"                                                        
i = 0                                                                           
do while (rc = 0)                                                               
  parse pull agname logdsn .                                                    
  if iagname = agname then                                                      
    do                                                                          
      i = i + 1                                                                 
      ld.i = logdsn                                                             
    end                                                                         
  "EXECIO 1 DISKR logolog"                                                      
end                                                                             
"EXECIO 1 DISKR logolog (FINIS"                                                 
"free fi(logolog)"                                                              
/******************************************************/                        
/** Set up report file and headings                  **/                        
/******************************************************/                        
"EXECIO 0 DISKW agdet (open"                                                    
if lines > 57 then                                                              
  do                                                                            
    call DR4111                                                                 
  end                                                                           
/******************************************************/                        
if i = 0 then                                                                   
  do                                                                            
     push '    No ARECOVER commands executed for Aggregate'                     
     "execio 1 diskw agdet"                                                     
     push '    Expect all datasets to be in error'                              
     "execio 1 diskw agdet"                                                     
  end                                                                           
else                                                                            
  do k = 1 to i                                                                 
    if lines > 57 then                                                          
      do                                                                        
        call DR4111                                                             
      end                                                                       
     push ' ' left(k,3) ld.k                                                    
     "execio 1 diskw agdet"                                                     
     lines = lines + 1                                                          
  end                                                                           
push '    --------------------------------------------'                         
"execio 1 diskw agdet"                                                          
push '    ARECOVER for Aggregate' iagname ' ran ' i 'times'                     
"execio 1 diskw agdet"                                                          
push '0   --------------------------------------------'                         
"execio 1 diskw agdet"                                                          
lines = lines + 4                                                               
return 0;                                                                       
/*REXX****************************************************************/         
dr412:                                                                          
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         log of logs                                               */         
/*                                                                   */         
/* Output: ARECOVER audit of datasets in the aggregate               */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname ardsn .                                                             
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
ok = 'OK'                                                                       
cdsn = 0                                                                        
edsn = 0                                                                        
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/*   Locate and read the ABARS arecover parms dataset                */         
/*********************************************************************/         
if ardsn = "''" then                                                            
  do                                                                            
    say "ARAUDIT: no ARECOVER Parms Dataset for aggregate" iagname              
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("ardsn") shr reuse"                                      
/*********************************************************************/         
/*   pass over the first 6 records (arecproc and documentation)      */         
/*********************************************************************/         
"execio 6 diskr input"                                                          
delstack                                                                        
/*********************************************************************/         
"execio 1 diskr input"                                                          
/*********************************************************************/         
/*   process the remaining records                                   */         
/*********************************************************************/         
push "0    DSN                                         Errors         "         
"execio 1 diskw agdet"                                                          
push "    -------------------------------------------- ---------------"         
"execio 1 diskw agdet"                                                          
/*********************************************************************/         
do while (rc = 0)                                                               
  if lines > 57 then                                                            
      call DR4112                                                               
  parse pull junk1 dsn junk2                                                    
  dsname = "'" || dsn || "'"                                                    
  x = listdsi(dsname "NORECALL")                                                
  select                                                                        
  when sysreason  = 0 then /* normal completion */                              
    reason = 'OK'                                                               
  when sysreason  = 5 then /* Dataset Not Found */                              
    reason = 'DSN Not Cataloged'                                                
  when sysreason  = 8 then /* tape dataset */                                   
    reason = 'OK'                                                               
  when sysreason  = 9 then /* migrated dataset- DASD */                         
    reason = 'OK'                                                               
  when sysreason  = 12 then /* VSAM dataset */                                  
    reason = 'OK'                                                               
  when sysreason  = 19 then /* multi volume dataset */                          
    reason = 'OK'                                                               
  when sysreason  = 22 then /* volume not mounted */                            
    reason = 'Volume' sysvolume 'Offline'                                       
  when sysreason  = 24 then /* Dangling Catalog Pointer */                      
      reason = 'DSN Not Found'                                                  
  when sysreason  = 25 then /* migrated dataset- TAPE */                        
    reason = 'OK'                                                               
  otherwise                                                                     
    reason = sysreason                                                          
  end /* select */                                                              
  cdsn = cdsn + 1                                                               
  if reason ^= 'OK' then                                                        
    do                                                                          
      push '   ' left(dsn,44) left(reason,20)                                   
     "execio 1 diskw agdet"                                                     
      ok = 'ERROR'                                                              
     lines = lines + 1                                                          
     edsn = edsn + 1                                                            
  end                                                                           
"execio 1 diskr input"                                                          
end                                                                             
if OK = 'OK' then                                                               
    do                                                                          
      push '   No errors found'                                                 
     "execio 1 diskw agdet"                                                     
  end                                                                           
"execio 0 diskr input (finis"                                                   
"free fi(input)"                                                                
return cdsn edsn;                                                               
dr4111:                                                                         
/************************************************************/                  
/* REXX SUBROUTINE-DR4111                                   */                  
/* report heading routine for audit detail                  */                  
/************************************************************/                  
push "1        ABARS Arecover Audit Detail Report for Aggregate:" ,             
      iagname "      " date(usa) "   Page:" page                                
"execio 1 diskw agdet"                                                          
page = page + 1                                                                 
push "0    Accumulated Logs                           "                         
"execio 1 diskw agdet"                                                          
push "    -------------------------------------------- "                        
"execio 1 diskw agdet"                                                          
lines = 4                                                                       
return 0;                                                                       
dr4112:                                                                         
/************************************************************/                  
/* REXX SUBROUTINE-DR4112                                   */                  
/* report heading routine for audit detail                  */                  
/************************************************************/                  
push "1        ABARS Arecover Audit Detail Report for Aggregate:" ,             
      iagname "      " date(usa) "   Page:" page                                
"execio 1 diskw agdet"                                                          
page = page + 1                                                                 
push "0    DSN                                         Errors         "         
"execio 1 diskw agdet"                                                          
push "    -------------------------------------------- " ,                      
     "--------------------"                                                     
"execio 1 diskw agdet"                                                          
lines = 4                                                                       
return 0;                                                                       
./ ADD NAME=DR51                                                                
/*REXX****************************************************************/         
dr51:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Activity Log Dataset,                                     */         
/*                                                                   */         
/*  Output: Report of dataset location for aggregate development     */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname actlog                                                              
/*********************************************************************/         
/* Constants and Flags (global to subroutines)                       */         
/*********************************************************************/         
look = 'OFF'                                                                    
m = 0                                                                           
smc1 = 0   /* counter for the # of datasets*/                                   
smc2 = 0   /* counter for the # of arcive'd datasets*/                          
smc3 = 0   /* counter for the # of non-arcive'd datasets*/                      
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/* ************************************* */                                     
/* * allocates the abackup log dataset** */                                     
/* * the reads the abackup activity   ** */                                     
/* * log to locate the datasets       ** */                                     
/* ************************************* */                                     
/*********************************************************************/         
/*   start with opening and reading the ABARS Verify Activity Log    */         
/*********************************************************************/         
stat = msg('OFF')                                                               
"allocate fi(input) da("actlog") shr reuse"                                     
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRSCAN: Error allocating log dsn' actlog '.  RC='rc                    
    return 16;                                                                  
  end                                                                           
"EXECIO 0 DISKW ABRPT (OPEN"                                                    
/*********************************************************************/         
/*   parse the abars activity log for dataset names                  */         
/*********************************************************************/         
"execio 1 diskr input"                                                          
do while rc = 0                                                                 
   parse pull abarorec                                                          
   parse var abarorec 2 abarmsg 10 .                                            
   if abarmsg = 'ARC6004I' then /* msg from an EXECUTE log (bad)*/              
      do                                                                        
        say 'DRSCAN: Log not from ABACKUP VERIFY' logdsn                        
        say 'DRSCAN: Check Automated Operations, wrong log' actlog              
        return (16);                                                            
      end                                                                       
   if abarmsg = 'ARC6166I' then /* start of dataset names */                    
     do /* read the next record */                                              
       "execio 1 diskr input"                                                   
       parse pull abarorec                                                      
       parse var abarorec abart1 abart2 .                                       
       if abart1 = 'INCLUDE/EXCLUDE' | ,                                        
          abart2 = 'INCLUDE/EXCLUDE' then                                       
         look = 'ON'                                                            
       else                                                                     
         look = 'OFF'                                                           
     end                                                                        
   if abarmsg = 'ARC6250I' then /* msg proceeding DSNs for DFSMShsm */          
      look = 'OFF'                                                              
   if abarmsg = 'ARC6055I' then /* msg proceeding DSNs for DFHSM 2.6*/          
      look = 'OFF'                                                              
   if look = 'ON' then                                                          
/*********************************************************************/         
/*   Look for Dataset names                                          */         
/*********************************************************************/         
     do                                                                         
       parse var abarorec 2 abarnull 4 .                                        
       if abarnull = '  '  then  /* it is a dataset name */                     
         do                                                                     
           smc1 = smc1 + 1                                                      
           parse var abarorec 4 agdsn 48 .                                      
           agdsn = strip(agdsn,t)                                               
           aggdsn = "'" || agdsn || "'"                                         
           /* *************************** */                                    
           /* parse the output of listcat */                                    
           /* *************************** */                                    
           call outtrap ("cmdoput.")                                            
           "LISTC entry("aggdsn") volume"                                       
           do j = 1 to cmdoput.0                                                
             parse var cmdoput.j 8 volser 14 .                                  
             if volser = 'VOLSER' then                                          
               do                                                               
                j = cmdoput.0   /* end listcat process */                       
                 parse var cmdoput.j 26 volume 32 junk 52 devt 60 .             
                 /* ************************ */                                 
                 /* do we want this dataset? */                                 
                 /* ************************ */                                 
                 call dr151 agdsn volume devt                                   
                 why = result                                                   
                 if why ^= '' then                                              
                   do                                                           
                     push '  ' left(iagname,8) left(agdsn,44) why               
                     "EXECIO 1 DISKW ABRPT"                                     
                     smc2 = smc2 + 1                                            
                   end                                                          
                 else                                                           
                   do                                                           
                     smc3 = smc3 + 1                                            
                     call intdsn agdsn                                          
                     where = result                                             
                     push '  ' left(iagname,8) left(agdsn,44) where             
                     "EXECIO 1 DISKW ABRPT"                                     
                   end                                                          
               end                                                              
           end                                                                  
           call outtrap("off")                                                  
         end                                                                    
     end                                                                        
   "execio 1 diskr input"                                                       
end                                                                             
push '  DRSCAN: Candidate Datasets for backup:' smc1                            
"EXECIO 1 DISKW ABRPT"                                                          
push "  DRSCAN: Archived Dataset Excluded:" smc2                                
"EXECIO 1 DISKW ABRPT"                                                          
push '  DRSCAN: Datasets Included:' smc3                                        
"EXECIO 1 DISKW ABRPT"                                                          
"execio 0 diskr input (finis"                                                   
"execio 0 diskw ABRPT (finis"                                                   
"free fi(input)"                                                                
/* "delete" actlog  */                                                          
return 0;                                                                       
intdsn:                                                                         
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         log of logs                                               */         
/*                                                                   */         
/* Output: ARECOVER audit of datasets in the aggregate               */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
arg agdsn .                                                                     
  dsname = "'" || agdsn || "'"                                                  
  x = listdsi(dsname "NORECALL")                                                
  select                                                                        
  when sysreason  = 0 then /* normal completion */                              
    reason = 'DSN on DASD'                                                      
  when sysreason  = 5 then /* Dataset Not Found */                              
    reason = '...DSN Not Cataloged'                                             
  when sysreason  = 8 then /* tape dataset */                                   
    reason = '...Tape Dataset'                                                  
  when sysreason  = 9 then /* migrated dataset- DASD */                         
    reason = '...DSN Migrated to DASD'                                          
  when sysreason  = 12 then /* VSAM dataset */                                  
    reason = 'Vsam DSN on DASD'                                                 
  when sysreason  = 19 then /* multi volume dataset */                          
    reason = '...Multi-Volume DSN'                                              
  when sysreason  = 24 then /* Dangling Catalog Pointer */                      
      reason = '...DSN Not Found'                                               
  when sysreason  = 25 then /* migrated dataset- TAPE */                        
    reason = '...DSN Migrated to Tape'                                          
  otherwise                                                                     
    reason = sysreason                                                          
  end /* select */                                                              
return reason;                                                                  
./ ADD NAME=DR61                                                                
/*REXX****************************************************************/         
dr61:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Activity Log Dataset,                                     */         
/*                                                                   */         
/*  Output: Report of dataset location for aggregate development     */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
arg iagname actlog                                                              
/*********************************************************************/         
/* Constants and Flags (global to subroutines)                       */         
/*********************************************************************/         
look = 'OFF'                                                                    
m = 0                                                                           
smc1 = 0   /* counter for the # of datasets*/                                   
smc2 = 0   /* counter for the # of arcive'd datasets*/                          
smc3 = 0   /* counter for the # of non-arcive'd datasets*/                      
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/* ************************************* */                                     
/* * allocates the abackup log dataset** */                                     
/* * the reads the abackup activity   ** */                                     
/* * log to locate the datasets       ** */                                     
/* ************************************* */                                     
/*********************************************************************/         
/*   start with opening and reading the ABARS Verify Activity Log    */         
/*********************************************************************/         
stat = msg('OFF')                                                               
"allocate fi(input) da("actlog") shr reuse"                                     
if rc ^= 0 then                                                                 
  do                                                                            
    say 'DRSEO: Error allocating log dsn' actlog '.  RC='rc                     
    return 16;                                                                  
  end                                                                           
"EXECIO 0 DISKW ABRPT (OPEN"                                                    
/*********************************************************************/         
/*   parse the abars activity log for dataset names                  */         
/*********************************************************************/         
"execio 1 diskr input"                                                          
do while rc = 0                                                                 
   parse pull abarorec                                                          
   parse var abarorec 2 abarmsg 10 .                                            
   if abarmsg = 'ARC6004I' then /* msg from an EXECUTE log (bad)*/              
      do                                                                        
        say 'DRSEO: Log not from ABACKUP VERIFY' logdsn                         
        say 'DRSEO: Check Automated Operations, wrong log' actlog               
        return (16);                                                            
      end                                                                       
   if abarmsg = 'ARC6166I' then /* start of dataset names */                    
     do /* read the next record */                                              
       "execio 1 diskr input"                                                   
       parse pull abarorec                                                      
       parse var abarorec abart1 abart2 .                                       
       if abart1 = 'INCLUDE/EXCLUDE' | ,                                        
          abart2 = 'INCLUDE/EXCLUDE' then                                       
         look = 'ON'                                                            
       else                                                                     
         look = 'OFF'                                                           
     end                                                                        
   if abarmsg = 'ARC6250I' then /* msg proceeding DSNs for DFSMShsm */          
      look = 'OFF'                                                              
   if abarmsg = 'ARC6055I' then /* msg proceeding DSNs for DFHSM 2.6*/          
      look = 'OFF'                                                              
   if look = 'ON' then                                                          
/*********************************************************************/         
/*   Look for Dataset names                                          */         
/*********************************************************************/         
     do                                                                         
       parse var abarorec 2 abarnull 4 .                                        
       if abarnull = '  '  then  /* it is a dataset name */                     
         do                                                                     
           smc1 = smc1 + 1                                                      
           parse var abarorec 4 agdsn 48 .                                      
           agdsn = strip(agdsn,t)                                               
           aggdsn = "'" || agdsn || "'"                                         
           /* *************************** */                                    
           /* parse the output of listcat */                                    
           /* *************************** */                                    
           call outtrap ("cmdoput.")                                            
           "LISTC entry("aggdsn") volume"                                       
           do j = 1 to cmdoput.0                                                
             parse var cmdoput.j 8 volser 14 .                                  
             if volser = 'VOLSER' then                                          
               do                                                               
                j = cmdoput.0   /* end listcat process */                       
                 parse var cmdoput.j 26 volume 32 junk 52 devt 60 .             
                 /* ************************ */                                 
                 /* do we want this dataset? */                                 
                 /* ************************ */                                 
                 call dr151 agdsn volume devt                                   
                 why = result                                                   
                 if why ^= '' then                                              
                   do                                                           
                     push '  ' left(iagname,8) left(agdsn,44) why               
                     "EXECIO 1 DISKW ABRPT"                                     
                     smc2 = smc2 + 1                                            
                   end                                                          
                 else                                                           
                   do                                                           
                     smc3 = smc3 + 1                                            
                     call intdsn agdsn                                          
                     where = result                                             
                     if where ^= '' then                                        
                       do                                                       
                         push '  ' left(iagname,8) left(agdsn,44) ,             
                               where                                            
                         "EXECIO 1 DISKW ABRPT"                                 
                       end                                                      
                   end                                                          
               end                                                              
           end                                                                  
           call outtrap("off")                                                  
         end                                                                    
     end                                                                        
   "execio 1 diskr input"                                                       
end                                                                             
push '  DRSCAN: Candidate Datasets for backup:' smc1                            
"EXECIO 1 DISKW ABRPT"                                                          
push "  DRSCAN: Archived Dataset Excluded:" smc2                                
"EXECIO 1 DISKW ABRPT"                                                          
push '  DRSCAN: Datasets Included:' smc3                                        
"EXECIO 1 DISKW ABRPT"                                                          
"execio 0 diskr input (finis"                                                   
"execio 0 diskw ABRPT (finis"                                                   
"free fi(input)"                                                                
/* "delete" actlog  */                                                          
return 0;                                                                       
intdsn:                                                                         
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         log of logs                                               */         
/*                                                                   */         
/* Output: ARECOVER audit of datasets in the aggregate               */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1993,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
arg agdsn .                                                                     
  dsname = "'" || agdsn || "'"                                                  
  x = listdsi(dsname "NORECALL")                                                
  select                                                                        
  when sysreason  = 0 then /* normal completion */                              
    reason = ''                                                                 
  when sysreason  = 5 then /* Dataset Not Found */                              
    reason = '...DSN Not Cataloged'                                             
  when sysreason  = 8 then /* tape dataset */                                   
    reason = '...Tape Dataset'                                                  
  when sysreason  = 9 then /* migrated dataset- DASD */                         
    reason = '...DSN Migrated to DASD'                                          
  when sysreason  = 12 then /* VSAM dataset */                                  
    reason = ''                                                                 
  when sysreason  = 19 then /* multi volume dataset */                          
    reason = '...Multi-Volume DSN'                                              
  when sysreason  = 24 then /* Dangling Catalog Pointer */                      
      reason = '...DSN Not Found'                                               
  when sysreason  = 25 then /* migrated dataset- TAPE */                        
    reason = '...DSN Migrated to Tape'                                          
  otherwise                                                                     
    reason = sysreason                                                          
  end /* select */                                                              
return reason;                                                                  
./ ADD NAME=DR70                                                                
/*REXX*/                                                                        
dr70:                                                                           
arg agname apdsn .                                                              
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         Aggregate Parms Dataset                                   */         
/*                                                                   */         
/* Output: ARECSNGL parms validation                                 */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1995,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* *********************** */                                                   
/* * subroutine readparm * */                                                   
/* *********************** */                                                   
/* ************************************* */                                     
/* * validates input parameters       ** */                                     
/* *  and fails exec with messages    ** */                                     
/* *  if problems are encountered.    ** */                                     
/* ************************************* */                                     
if agname  = '' then                                                            
  do                                                                            
    say 'ARECSNGL: 1 Required parameter not supplied'                           
    say 'ARECSNGL: need Aggregate Name'                                         
    return (16);                                                                
  end                                                                           
/* ************************************* */                                     
/* * Insure we have an Aggregate      ** */                                     
/* * parm member                      ** */                                     
/* ************************************* */                                     
msdsn = sysdsn(apdsn)                                                           
if msdsn ^= 'OK' then                                                           
  do /* problem  flag what's wrong */                                           
    say 'ARECSNGL: valid aggregate parameter dataset required'                  
    say 'ARECSNGL:' apdsn '...' || msdsn                                        
    return (16)                                                                 
  end                                                                           
return 0;                                                                       
./ ADD NAME=DR71                                                                
dr71:                                                                           
/*REXX****************************************************************/         
/*********************************************************************/         
/*  Function: Setup Restart dataset for subset Aggregate Restore     */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset,                                   */         
/*         Inputdsn                                                  */         
/*         Temporary High Level Qualifier                            */         
/*                                                                   */         
/* Output: ARECOVER Restart Dataset                                  */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/* Copyright IBM Corp. 1995,2008                                 @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/*trace ?R*/                                                                    
arg iagname ardsn thlq .                                                        
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/* Read the Input DSN                                                */         
/*********************************************************************/         
stat = msg('off')                                                               
r = 0                                                                           
"EXECIO 1 DISKR indsn"                                                          
i = 0                                                                           
do while (rc = 0)                                                               
  i = i + 1                                                                     
  parse pull restdsn.i .                                                        
  len.i = lastpos('*',restdsn.i)                                                
  if len.i = 0 then                                                             
     len.i = length(restdsn.i)                                                  
  else                                                                          
     len.i = len.i - 1                                                          
  "EXECIO 1 DISKR indsn"                                                        
end                                                                             
"EXECIO 1 DISKR indsn (FINIS"                                                   
"free fi(indsn)"                                                                
/*********************************************************************/         
/*   Locate and read the ABARS arecover parms dataset                */         
/*********************************************************************/         
"allocate fi(input) da("ardsn") shr reuse"                                      
/*********************************************************************/         
/*   pass over the first 5 records (arecproc and documentation),     */         
/*   derive the ABARS restart dsn, allocate and open the restart dsn */         
/*********************************************************************/         
"execio 5 diskr input"                                                          
delstack                                                                        
"execio 1 diskr input"                                                          
parse pull junk1 dsn junk2                                                      
parse var dsn . value(iagname) dsnsuff                                          
rstrtdsn = dr711(iagname thlq) || iagname || '.restart' || dsnsuff              
"alloc da('" || rstrtdsn || ") new space(2 1)"    ,                             
     " recfm(f b) lrecl(80) blksize(0) dsorg(PS)"                               
"alloc fi(restart) da('"rstrtdsn") old"                                         
"EXECIO 0 DISKW restart (open"                                                  
push 'RESTART DATA SET'                                                         
"execio 1 diskw restart"                                                        
/*********************************************************************/         
"execio 1 diskr input"                                                          
/*********************************************************************/         
/*   process the remaining records from parms dataset                */         
/*********************************************************************/         
/*********************************************************************/         
do while (rc = 0)                                                               
  parse pull junk1 dsn junk2                                                    
  omit='n'                                                                      
  do j=1 to i by 1                                                              
    if substr(restdsn.j,1,len.j) = substr(dsn,1,len.j) then                     
       omit = 'y'                                                               
  end                                                                           
  if omit = 'n' then                                                            
    do                                                                          
      push dsn                                                                  
      "execio 1 diskw restart"                                                  
    end                                                                         
  "execio 1 diskr input"                                                        
end                                                                             
"execio 0 diskr input (finis"                                                   
"execio 0 diskw restart (finis"                                                 
"free fi(input)"                                                                
"free fi(restart)"                                                              
return 0;                                                                       
./ ADD NAME=DR711                                                               
/*REXX****************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Output: DFSMS/hsm prefix                                         */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1995,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
gethsmid:                                                                       
arg iagname thlq .                                                              
/*********************************************************************/         
prename = thlq || iagname                                                       
STAT = MSG('OFF')                                                               
"HSEND wait DISPLAY .MCVT.+C0 LENGTHS(7) ODS(" || PRENAME || ".MCVT)"           
"allocate fi(ddx) da('" || prename || ".MCVT') shr"                             
"execio 1 diskr ddx"                                                            
parse pull junk1                                                                
"execio 1 diskr ddx"                                                            
parse pull hexaddr hexval1 hexval2 .                                            
"execio 0 diskr ddx (finis"                                                     
"free fi(ddx)"                                                                  
"delete '" || prename || ".MCVT'"                                               
hexval =  hexval1 || hexval2                                                    
huidlen = x2d(substr(hexval,15,2))                                              
charval = substr(x2c(hexval),1,huidlen) || '.'                                  
RETURN charval                                                                  
./ ADD NAME=DR72                                                                
/*REXX****************************************************************/         
dr72:                                                                           
/*********************************************************************/         
/*  Function:                                                        */         
/*                                                                   */         
/*  Input: Aggregate Name,                                           */         
/*         arecover parms dataset                                    */         
/*                                                                   */         
/* Output: ARECOVER statement execution,                             */         
/*         Activity Log,                                             */         
/*         log of arecover logs for audit purposes                   */         
/*                                                                   */         
/*                                                                   */         
/*                                                                   */         
/*  Copyright IBM Corp. 1995,2008                                @ZRC*/         
/*                                                                   */         
/*********************************************************************/         
/* Parameters Passed to this exec                                    */         
/*********************************************************************/         
/*trace ?r*/                                                                    
arg iagname ardsn .                                                             
/*********************************************************************/         
/* Constants and Flags                                               */         
/*********************************************************************/         
/*********************************************************************/         
/* Function Starts Here                                              */         
/*********************************************************************/         
/*********************************************************************/         
/* Find out which release of DFHSM is available                      */         
/*********************************************************************/         
 dfhsm = sysvar(syshsm)                                                         
/****DFHSM 2.6 is 2060 ***********************************************/         
/****DFSMShsm 1.1 is 1010 ********************************************/         
/*********************************************************************/         
/*   Locate and read the ABARS arecover parms dataset                */         
/*********************************************************************/         
r = 0                                                                           
if ardsn = "''" then                                                            
  do                                                                            
    say "ARECSNGL: no ARECOVER Parms Dataset for aggregate" iagname             
    return (16);                                                                
  end                                                                           
"allocate fi(input) da("ardsn") shr"                                            
do while (rc ^= 0 & r ^= 20)                                                    
  r = r + 1                                                                     
  "wait 15"                                                                     
  "alloc fi(input) da("ardsn") shr"                                             
end                                                                             
if rc ^= 0 then                                                                 
  do                                                                            
    say 'ARECSNGL: Check Syslog; Contention for parms DSN' ardsn                
    return (16);                                                                
  end                                                                           
/*********************************************************************/         
/*   parse the abars arecover parms dataset for control dsn & volser */         
/*   use second set of cntl dsn & volser                             */         
/*********************************************************************/         
"execio 3 diskr input "                                                         
delstack                                                                        
"execio 1 diskr input "                                                         
parse pull 'DATASETNAME(' cdsn ')' h5 '-' .                                     
"execio 1 diskr input "                                                         
parse pull j1 h6 'DSCONFLICT(' h7 ') ' h8 .                                     
"execio * diskr input (finis"                                                   
"free fi(input)"                                                                
delstack                                                                        
if dfhsm ^= 2060 then                                                           
  do                                                                            
    cdsn = 'datasetname(' || cdsn || ')'                                        
    if h7 = 'REPLACE' then                                                      
      h7 = 'DSCONFLICT(REPLACE)'                                                
  end                                                                           
"hsend wait arecover" cdsn h5 h6 h7 h8                                          
say "hsend wait arecover" cdsn ,                                                
    h5 h6 h7 h8                                                                 
return rc;                                                                      
./ ADD NAME=GENMASK                                                             
/* REXX */                                                                      
/*******************************************************************/           
/* GENMASK -                                                       */           
/*    Syntax:   GENMASK input.data.set                             */           
/*                                                                 */           
/* This REXX exec will read in a filter list, and generate         */           
/* an subprogram that can be incorporated into any                 */           
/* DFSMShsm Exit, such as the ARCMDEXT exit.                       */           
/*                                                                 */           
/* The subprogram will be generated in assembler.                  */           
/*******************************************************************/           
/*                                                                 */           
/* The format of the input file is a set of masks, one mask        */           
/* per line:                                                       */           
/*                                                                 */           
/*    <mask number> mask <mask value>                              */           
/*                                                                 */           
/* Mask Number: Optional, ranging from 1-9999.  In no mask         */           
/*      number specified, will be assigned one automatically.      */           
/*      The mask numbers must be in ascending order.               */           
/*                                                                 */           
/* Mask: Required, 1-44 characters, representing dot-separated     */           
/*       qualifiers.  Each qualifier can be 1-8 valid data set     */           
/*       characters, or 0-7 valid data set characters followed     */           
/*       by an asterisk (*).  Mask values of ** and % are not      */           
/*       supported at this time.                                   */           
/*                                                                 */           
/*       Valid:                    Invalid:                        */           
/*       PEARSON.*.*.*.OUTPUT      PEARSON.**.OUTPUT               */           
/*       PEARSON.GDG.G*            PEARSON.GDG.G%%V%%%%            */           
/*       PEARSON.TEST*.OUTLIST     PEARSON.TEST7.*LIST             */           
/*                                                                 */           
/*                                                                 */           
/* Mask Value: Optional, 0-999999999, will be returned when a      */           
/*       data set name matches the associated mask.  If not        */           
/*       specified, a value of zero will be returned.              */           
/*                                                                 */           
/*                                                                 */           
/*******************************************************************/           
/*                                                                 */           
/* The output file created will be:    input.data.set.ASM          */           
/*                                                                 */           
/* If errors found, the output will contain a list of error        */           
/* messages.  If no errors found, the output will contain the      */           
/* assembler source code generated.                                */           
/*                                                                 */           
/*******************************************************************/           
/*                                                                 */           
/* First pass of the filter masks checks for valid values.  The    */           
/* following return codes are used to denote errors:               */           
/*                                                                 */           
/*     02 - Mask Number is not in ascending order                  */           
/*     04 - Mask Number exceeds 1-9999 range                       */           
/*     08 - Mask Value is non-integer, or exceeds 999999999        */           
/*     10 - Mask exceeds 44 characters in length                   */           
/*     12 - Last character in Mask is a dot (.)                    */           
/*     16 - Two consecutive dots found (empty qualifier)           */           
/*     20 - Qualifier exceeds 8 characters in length               */           
/*     24 - More than one asterisk (*) found in Qualifier          */           
/*     28 - Characters found after asterisk (*) in Qualifier       */           
/*                                                                 */           
/* To help fix mask errors, the position of the erroneous          */           
/* character is provided with the error message.                   */           
/*                                                                 */           
/*******************************************************************/           
/*                                                                 */           
/* The resulting subprogram can be invoked as follows:             */           
/*                                                                 */           
/*       BAL R14,FILTER                                            */           
/*                                                                 */           
/* On input, the following registers must be specified:            */           
/*                                                                 */           
/*       Register 1 points to a 16 byte area                       */           
/*         0(R1) 4-byte pointer to 44-character data set name      */           
/*         4(R1) 4-byte pointer to 4-byte mask number              */           
/*         8(R1) 4-byte pointer to 4-byte mask value               */           
/*        12(R1) 4-byte pointer to 80-byte working storage area    */           
/*                                                                 */           
/*       Register 13 points to a valid 72-byte standard save area. */           
/*                                                                 */           
/* On output, the following fields are set:                        */           
/*                                                                 */           
/*       If no match found, mask number and mask value both zero.  */           
/*                                                                 */           
/*       If match found, mask number and mask value associated     */           
/*          with the first mask found to match input data set      */           
/*                                                                 */           
/*******************************************************************/           
NUMERIC DIGITS 11                                                               
PARSE ARG DSN OPS                                                               
ERRORS = 0                                                                      
LASTMASK = 0                                                                    
nummask = 0                                                                     
OUTPUT.0 = 0                                                                    
plx = pos('PLX',ops)                                                            
hlqs = ''; hcount = 0; hlqval. = 0; hlqnum. = 0                                 
donecount = "0001"; donelimit = 50; maxtext = 0                                 
value. = 0; loval=999999; hival=-1                                              
CALL ANALYZE_DATA                                                               
IF ERRORS=0 THEN CALL GENERATE_CODE                                             
CALL WRITE_RESULTS                                                              
EXIT                                                                            
/*******************************************************************/           
/* ANALYZE_DATA                                                    */           
/*    READ AND PROCESS EACH RECORD OF THE INPUT FILE               */           
/*******************************************************************/           
ANALYZE_DATA:                                                                   
ALLOC_OCDS = "DA("DSN")"                                                        
'ALLOC 'ALLOC_OCDS' FI(XDATA) SHR REUSE'                                        
IF RC=0 THEN DO                                                                 
SAY 'Data Set='DSN ' Successfully opened'                                       
"EXECIO * DISKR XDATA ( STEM" X.                                                
   DO M=1 TO X.0                                                                
      Call Parse_Mask                                                           
   END                                                                          
"EXECIO 0 DISKR XDATA ( FINIS"                                                  
Say 'Lines Processed = 'x.0                                                     
If errors>0 then call write 'Warning: 'errors' Errors found'                    
END                                                                             
ELSE SAY 'Unable to open DSN='DSN'.  SYNTAX: GENMASK dsn'                       
'FREE FI(XDATA)'                                                                
/* Determine Common High Level Qualifiers */                                    
hlqmult = ''                                                                    
qx = hlqs                                                                       
do while (qx \= '')                                                             
parse var qx "<"hlq">" qx                                                       
if hlqval.hlq > 1 then do                                                       
                                                                                
      hlqmult = hlqmult"<"hlq">"                                                
      hcount = hcount + 1                                                       
      hlqnum.hlq = hcount                                                       
   end                                                                          
end                                                                             
RETURN                                                                          
/*******************************************************************/           
Parse_Mask:                                                                     
   parse var x.m maskn mask maskv .                                             
   if datatype(maskn,'Whole')=0 then do                                         
      maskv = mask                                                              
      mask = maskn                                                              
      maskn = lastmask + 1                                                      
      end                                                                       
   else                                                                         
      maskn = maskn + 0                                                         
   if maskv='' then maskv=0                                                     
   if maskn>0 & maskn<= lastmask then do                                        
     call write "Line "m": RC=02 Invalid Mask Number ("maskn")"                 
      errors = errors + 1                                                       
      end                                                                       
   else if maskn=0 | maskn>9999 then do                                         
     call write "Line "m": RC=04 Invalid Mask Number ("maskn")"                 
      errors = errors + 1                                                       
      end                                                                       
   else lastmask = maskn                                                        
   if datatype(maskv,'Whole')=0 | maskv>999999999 then do                       
     call write "Line "m": RC=08 Invalid Mask Value ("maskv")"                  
      errors = errors + 1                                                       
      end                                                                       
   if length(mask)>44 then do                                                   
     call write "Line "m": RC=10 Invalid Mask (",                               
             left(mask,30)") position="length(mask)                             
      errors = errors + 1                                                       
      end                                                                       
   size=0; numstar=0; rc=0                                                      
do n=1 to length(mask) while(rc=0)                                              
   char=substr(mask,n,1)                                                        
   select;                                                                      
      when(char='.') then do                                                    
         if n=length(mask) then rc=12                                           
         else if size<1 then rc=16                                              
         else if size>8 then rc=20                                              
         size=0                                                                 
         numstar=0                                                              
         end                                                                    
      when(char='*') then do                                                    
         if numstar>0 then rc=24                                                
         numstar=numstar+1                                                      
         size=size+1                                                            
         end                                                                    
      otherwise do                                                              
         if numstar>0 then rc=28                                                
         size=size+1                                                            
         end                                                                    
   end                                                                          
   if rc>0 then do                                                              
     call write "Line "m": RC="rc" Invalid Mask (",                             
             left(mask,30)") position="n                                        
      errors = errors + 1                                                       
      end                                                                       
end                                                                             
nummask = nummask + 1                                                           
mnum.nummask = right(maskn,4,'0')                                               
mtext.nummask = mask                                                            
mval.nummask = maskv+0                                                          
if mval.nummask <=99999 then do                                                 
val = mval.nummask                                                              
value.val=value.val+1                                                           
if val<loval then loval=val                                                     
if val>hival then hival=val                                                     
end                                                                             
kdot=pos('.',mask)                                                              
kstar=pos('*',mask)                                                             
if kdot>1 & (kstar=0 | kstar>kdot) then do                                      
   hlq = left(mask,kdot-1)                                                      
   hlqval.hlq=hlqval.hlq+1                                                      
   if hlqval.hlq=1 then do                                                      
      hlqs = hlqs"<"hlq">"                                                      
      end                                                                       
end                                                                             
return                                                                          
/*******************************************************************/           
Generate_Code:                                                                  
qx=hlqs                                                                         
do while qx\=''                                                                 
   parse var qx "<"hx">" qx                                                     
   end                                                                          
Comment_Tag = copies("*",71)                                                    
tcount = 0; tc.0 = 0                                                            
Call Front_Matter                                                               
do q=1 to nummask                                                               
mask = strip(mtext.q)                                                           
Call Comment "MASK "mnum.q mask "VALUE="mval.q                                  
numstar=0                                                                       
numdot=0                                                                        
mask = strip(mask)                                                              
lenmask=length(mask)                                                            
starter = "IF"                                                                  
do n=1 to lenmask                                                               
   char=substr(mask,n,1)                                                        
   if char='*' then do                                                          
      numstar=numstar+1                                                         
      star.numstar=n                                                            
      end                                                                       
   if char='.' then do                                                          
      numdot=numdot+1                                                           
      dot.numdot=n                                                              
      end                                                                       
end                                                                             
if plx then do                                                                  
   if q>1 then call write "ELSE"                                                
end                                                                             
else call write "MASK"mnum.q" DS    0H"                                         
hlq=''                                                                          
kdot = pos('.',mask)                                                            
if kdot>1 then do                                                               
   hlq=left(mask,kdot-1)                                                        
   if hlqval.hlq<2 then hlq=''                                                  
end                                                                             
select;                                                                         
/* Fully Qualified */                                                           
when numstar=0 then do                                                          
   if length(mask)<44 then mask=mask||' '                                       
   if hlq='' then Call Data_Set_Position 1,mask                                 
   else do                                                                      
      Call Data_Set_Position 1,hlq||'.'                                         
      klen = length(hlq)+2                                                      
      Call Data_Set_Position klen,substr(mask,klen)                             
   end                                                                          
   Call Set_Values                                                              
end                                                                             
/* No hard characters: *.*.*.*             */                                   
when (numstar+numdot)=lenmask then do                                           
   Call Number_Qualifiers                                                       
   Call Set_Values                                                              
      end                                                                       
otherwise do                                                                    
   Call Number_Qualifiers                                                       
   do r=1 to numstar                                                            
   if r= 1 & star.1>1 then do                                                   
      klen = length(hlq)+2                                                      
      if hlq='' | (star.1=klen) then do                                         
        Call Data_Set_Position 1,left(mask,star.1-1)                            
        end                                                                     
      else do                                                                   
        Call Data_Set_Position 1,hlq||'.'                                       
        Call Data_Set_Position klen,substr(mask,klen,star.1-klen)               
        end                                                                     
      end                                                                       
   if r<numstar then do                                                         
      rx=r+1                                                                    
      section=substr(mask,(star.r)+1,(star.rx)-(star.r)-1)                      
      dj=0                                                                      
      do  j=1 to numdot while(dj=0)                                             
          if dot.j>star.r then dj=j                                             
          end                                                                   
      if section\='.' then ,                                                    
         Call Data_Set_Position "DOT("dj")",section                             
      end                                                                       
   if r=numstar & star.r<lenmask then do                                        
      k=lenmask-star.r;                                                         
      dk="LASTPOS-"||(k-1)                                                      
      Call Data_Set_Position dk,right(mask,k)                                   
      end                                                                       
   end                                                                          
   Call Set_Values                                                              
   end                                                                          
end                                                                             
Say "Q= "q                                                                      
if q<nummask & (q//donelimit)=0 then do                                         
   call Comment "End of Section "donecount                                      
   call write "         B     STEP"donecount                                    
   call text_constants                                                          
   call write "STEP"donecount" DS    0H"                                        
   call write "         BALR  P9,0"                                             
   call write "         USING *,P9"                                             
   donecount = right(donecount+1,4,'0')                                         
   end                                                                          
end                                                                             
Call Back_Matter                                                                
Return                                                                          
Comment:                                                                        
  call write Comment_Tag                                                        
  call write "* "arg(1)                                                         
  call write Comment_Tag                                                        
Return                                                                          
Number_Qualifiers:                                                              
nq= numdot+1                                                                    
if plx then do                                                                  
  call write starter" NUMQUAL="nq                                               
  if starter="IF" then starter="   &"                                           
end                                                                             
else do                                                                         
  call write "         LA    P7,"nq                                             
  call write "         CR    NUMQUAL,P7"                                        
  call write "         BNE   NEXT"mnum.q                                        
end                                                                             
Return                                                                          
Data_Set_Position:                                                              
   startpos = arg(1)                                                            
   textvalue = arg(2)                                                           
   textlen = length(textvalue)                                                  
if plx then do                                                                  
  call write starter" DSN("startpos"::"textlen")='"textvalue"'"                 
  if starter="IF" then starter="   &"                                           
end                                                                             
else do                                                                         
   dsnreg = "DSN"                                                               
  if startpos=1 & pos('.',textvalue)=textlen then do                            
     hlq=left(textvalue,textlen-1)                                              
     tco = "CQ"||right(hlqnum.hlq,6,"0")                                        
     end                                                                        
  else do                                                                       
     un=0                                                                       
     do u=1 to tcount                                                           
        if tc.u=textvalue then un=u                                             
     end                                                                        
     if un=0 then do                                                            
        tcount = tcount + 1                                                     
        tc.tcount = textvalue                                                   
        un=tcount                                                               
        end                                                                     
     tco = "CT"||right(un+maxtext,6,"0")                                        
     end                                                                        
  if left(startpos,3)='DOT' then do                                             
  parse var startpos "DOT("dotpos")" .                                          
  call write "         L     P8,"||(12+(dotpos*4))||"(,WORK)"                   
  dsnreg = "P8"                                                                 
  newpos = "0"                                                                  
  end                                                                           
  else if left(startpos,3)='LAS' then do                                        
  parse var startpos "LASTPOS-"lp  .                                            
  call write "         LR    P8,DSN"                                            
  call write "         ALR   P8,LASTPOS"                                        
  call write "         LA    P6,"lp+1                                           
  call write "         SLR   P8,P6"                                             
  dsnreg = "P8"                                                                 
  newpos = "0"                                                                  
  end                                                                           
  else newpos = startpos-1                                                      
  call write "         CLC   "newpos"("textlen","dsnreg"),"tco                  
  call write "         BNE   NEXT"mnum.q                                        
end                                                                             
Return                                                                          
Set_Values:                                                                     
if plx then do                                                                  
  settings = "MASK="mnum.q";"                                                   
  if mval.q > 0 then settings=settings||" VALUE="mval.q";"                      
  call write "   THEN BEGIN; "settings" END;"                                   
end                                                                             
else do                                                                         
  call write "         LA    MASK,"mnum.q                                       
  thisval=mval.q                                                                
  if value.thisval > 1 then do                                                  
     call write "         B     SET"right(thisval,5,'0')                        
  end                                                                           
  else do                                                                       
  if mval.q > 0 then do                                                         
     call write "         LA    VALUE,"mval.q                                   
     end                                                                        
  call write "         B     DONE"                                              
  end                                                                           
  call write "NEXT"mnum.q" DS    0H"                                            
end                                                                             
Return                                                                          
/*******************************************************************/           
Write:                                                                          
n=OUTPUT.0 + 1                                                                  
line=arg(1)                                                                     
if plx then do                                                                  
   if left(line,1)="*" then line=" /"||left(line,66)||"*/"                      
   else if left(line,1)\=" " then line=" "||left(line,71)                       
end                                                                             
OUTPUT.n = line                                                                 
OUTPUT.0 = n                                                                    
return                                                                          
/*******************************************************************/           
WRITE_RESULTS:                                                                  
ext='.ASM'                                                                      
if plx then ext='.PLX'                                                          
if left(dsn,1)="'" then do                                                      
   PARSE VAR DSN "'" BASE "'" .                                                 
   OUTDSN = "'"BASE||ext"'"                                                     
   end                                                                          
else outdsn = DSN||ext                                                          
IF SYSDSN(OUTDSN) = 'OK' THEN ops='OLD REUSE'                                   
   else ops="NEW CATALOG TRACKS SPACE(1 1) ",                                   
        "RECFM(F B) LRECL(80) DSORG(PS)"                                        
"ALLOC FI(OUTDATA) DA("OUTDSN") "ops                                            
'EXECIO 'OUTPUT.0' DISKW OUTDATA ( FINIS STEM' OUTPUT.                          
'FREE FI(OUTDATA)'                                                              
Say "DSN= "outdsn" Created."                                                    
RETURN                                                                          
Front_Matter:                                                                   
Call write Comment_Tag                                                          
call write "*        SUBPROGRAM FILTER"                                         
call write "*        Generated:   "date()                                       
dsnq = dsn                                                                      
if left(dsn,1)="'" then parse var dsn "'" dsnq "'"                              
call write "*        Filter list: "DSNQ                                         
call write "* "                                                                 
call write "* INPUT = PARAMETER LIST ITEMS USED ARE:"                           
call write "*     R1 POINTS TO A PARAMETER LIST     "                           
call write "*        0(R1) IS @ OF DATA SET NAME,   "                           
call write "*              LEFT-JUSTIFIED WITH BLANKS "                         
call write "*        4(R1) IS @ OF WORK AREA, 200 BYTES "                       
call write "*                                           "                       
call write "* EXIT-NORMAL = WORK AREA CONTAINS RESULTS: "                       
call write "*        0(WORKAREA) IS MASK NUMBER,        "                       
call write "*                    ZERO IF NO MATCH FOUND "                       
call write "*        4(WORKAREA) IS VALUE FOR MASK,     "                       
call write "*                    ZERO IF NO MATCH FOUND "                       
Call write Comment_Tag                                                          
if plx then do                                                                  
call write "FILTER: PROCEDURE(DSN,WORKAREA);     "                              
call write "                                     "                              
call write "DECLARE                              "                              
call write "  DSN CHAR(44),                      "                              
call write "  1 WORKSPACE CHAR(200),             "                              
call write "    3 MASK FIXED(31),                "                              
call write "    3 VALUE FIXED(31),               "                              
call write "    3 NUMQUAL FIXED(31),             "                              
call write "    3 LASTPOS FIXED(31),             "                              
call write "    3 DOT(1:20) FIXED(31),           "                              
call write "  N FIXED(31);                       "                              
call write "WORKAREA=''B;                        "                              
call write "NUMQUAL=1;                           "                              
call write "DO N=1 TO 44;                        "                              
call write " IF DSN(N)^=' ' THEN LASTPOS=N;      "                              
call write " IF DSN(N)='.' THEN DO;              "                              
call write "    DOT(NUMQUAL)=N;                  "                              
call write "    NUMQUAL=NUMQUAL+1;               "                              
call write "    END;                             "                              
call write "END;                                 "                              
end                                                                             
else do                                                                         
call write "FILTER   DS    0H            "                                      
call write "         STM   P14,P12,12(P13)  "                                   
call write "         BALR  P12,0            "                                   
call write "         USING *,P12            "                                   
call Comment "       INITIALIZE VARIABLES"                                      
call write "         LM    DSN,WORK,0(PARMS)     "                              
call write "         XC    0(200,WORK),0(WORK)   "                              
call write "         USING WORKAREA,WORK         "                              
call write "         LM    MASK,LASTPOS,0(WORK)  "                              
call write "         LA    P7,MAXLEN             "                              
call write "FILTER01 LR    P6,DSN                "                              
call write "         ALR   P6,LASTPOS            "                              
call write "         CLI   0(P6),BLANK           "                              
call write "         BC    B'1100',FILTER03      "                              
call write "         CLI   0(P6),PERIOD          "                              
call write "         BNE   FILTER02              "                              
call write "         LR    P8,NUMQUAL            "                              
call write "         SLA   P8,2                  "                              
call write "         ST    P6,DOT(P8)            "                              
call write "         LA    NUMQUAL,1(NUMQUAL)    "                              
call write "FILTER02 LA    LASTPOS,1(LASTPOS)    "                              
call write "         CLR   LASTPOS,P7            "                              
call write "         BM    FILTER01              "                              
call write "FILTER03 LA    NUMQUAL,1(NUMQUAL)    "                              
call write "         B     START"                                               
call Comment "   SAVE RESULTS                    "                              
if hival>0 then do q=loval to hival                                             
      if value.q>1 then do                                                      
      call write "SET"right(q,5,'0')" LA    VALUE,"q                            
      if q<hival then do                                                        
        call write "         B     DONE"                                        
        end                                                                     
      end                                                                       
end                                                                             
call write "DONE     STM   MASK,VALUE,WORKAREA "                                
call Comment "   RETURN REGISTERS BACK TO ORIGINAL VALUES"                      
call write "         LM    P14,P12,12(P13)        "                             
call write "         BR    P14                  "                               
call Comment "   COMMON HIGH LEVEL QUALIFIERS   "                               
hlquals = hlqs                                                                  
do while(hlquals\='')                                                           
   parse var hlquals '<'hlq'>' hlquals                                          
   if hlqval.hlq > 1 then do                                                    
     cj="CQ"right(hlqnum.hlq,6,'0')                                             
     call write cj" DC    CL"length(hlq)+1"'"hlq".'"                            
   end                                                                          
end                                                                             
call write "START    DS    0H "                                                 
call write "         BALR  P9,0                   "                             
call write "         USING *,P9                   "                             
end                                                                             
Return                                                                          
Back_Matter:                                                                    
if plx then do                                                                  
call write "  END FILTER;  "                                                    
end                                                                             
else do                                                                         
call write "         B     DONE"                                                
Call text_constants                                                             
call Comment "   LOCAL REGISTER VARIABLES   "                                   
call write "PARMS    EQU   1             "                                      
call write "DSN      EQU   10            "                                      
call write "WORK     EQU   11            "                                      
call write "MASK     EQU   2             "                                      
call write "VALUE    EQU   3             "                                      
call write "NUMQUAL  EQU   4             "                                      
call write "LASTPOS  EQU   5             "                                      
call Comment "       IMMEDIATE CONSTANTS       "                                
call write "MAXLEN   EQU   44            "                                      
call write "BLANK    EQU   C' '          "                                      
call write "PERIOD   EQU   C'.'          "                                      
call Comment "       GENERAL PURPOSE REGISTERS "                                
call write "P6       EQU   6             "                                      
call write "P7       EQU   7             "                                      
call write "P8       EQU   8             "                                      
call write "P9       EQU   9             "                                      
call write "P12      EQU   12            "                                      
call write "P13      EQU   13            "                                      
call write "P14      EQU   14            "                                      
call Comment "       DATA CONTROL SECTION      "                                
call write "WORKAREA DSECT                     "                                
call write "         DS    0CL200              "                                
call write "         DS    F       MASK NUMBER "                                
call write "         DS    F       MASK VALUE  "                                
call write "         DS    F                   "                                
call write "         DS    F                   "                                
call write "DOT      DS    20C                 "                                
call write "         END                       "                                
end                                                                             
Return                                                                          
Text_Constants:                                                                 
call Comment "   CHARACTER TEXT CONSTANTS   "                                   
do j=1 to tcount                                                                
   fr=0; md=0; eq=0                                                             
   do p=1 to j-1                                                                
      if pos(tc.j,tc.p)>1 then md=p                                             
      if pos(tc.j,tc.p)=1 then fr=p                                             
      if tc.j = tc.p then eq=p                                                  
   end                                                                          
   cj="CT"right(j+maxtext,6,'0')                                                
   if eq>0 then call write cj" EQU   CT"right(eq+maxtext,6,'0')                 
   else if fr>0 then do                                                         
        fj=right(tc.fr+maxtext,6,"0")                                           
        call write cj" EQU   CT"fj","length(tc.fr)",C'C'"                       
        end                                                                     
   else if md>0 then do                                                         
        ml=length(tc.j)                                                         
        mo=pos(tc.j,tc.md)-1                                                    
        mj=right(md+maxtext,6,'0')                                              
        call write cj" EQU   CT"||mj"+"mo","ml",C'C'"                           
        end                                                                     
   else call write cj" DC    CL"length(tc.j)"'"tc.j"'"                          
end                                                                             
maxtext = maxtext + tcount                                                      
tcount = 0                                                                      
Return                                                                          
./ ADD NAME=QUERYSET                                                            
   /* REXX                                               @XRC*/                 
   /**********************************************************/                 
   /*                                                        */                 
   /* QUERYSET - This sample REXX exec demonstrates the  @XRC*/                 
   /*            4-byte console id and CART support          */                 
   /*            (Command And Response Token) in DFSMShsm.   */                 
   /*                                                        */                 
   /*            This exec issues a QUERY SETSYS via the     */                 
   /*            extended console control, and the results   */                 
   /*            are returned in variables that can then     */                 
   /*            be parsed or scanned for specific values.   */                 
   /*                                                        */                 
   /*            Variables: hsmid is the SYS1.PROCLIB(hsmid) */                 
   /*            used to start DFSMShsm with on this system. */                 
   /*                                                        */                 
   /**********************************************************/                 
      hsmid = 'HSMM'                                                            
      mdisp=sysvar(soldisp)                                                     
      "consprof soldisplay(no)"                                                 
      "console activate"                                                        
      address console "CART HSM"                                                
                                                                                
      j = 0                                                                     
      n = 0                                                                     
      msghsm = 0                                                                
                                                                                
      address console "F "hsmid",Q SETSYS"                                      
      do while msghsm = 0                        /* 11 */                       
         msghsm = getmsg('resp.','SOL','HSM',,22)                               
         if msghsm = 0 then do                   /* 10 */                       
             n = n+1                                                            
             do i = 1 to resp.0                 /* 9 */                         
                k = i+j                                                         
                wto.k = resp.i                                                  
             end                                /* 9 */                         
           j = j+resp.0                                                         
       end                                     /* 10 */                         
                                                                                
     end                                        /* 11 */                        
                                                                                
     "console deactivate"                                                       
     "consprof soldisplay("mdisp")"                                             
     count=j                                                                    
     say "Line-count = "count                                                   
     do i = 1 to count                                                          
     say "Line"i" = "wto.i                                                      
     end                                                                        
./ ADD NAME=SCANBLOG                                                            
/* REXX                                                  @XRC*/                 
   /**********************************************************/                 
   /*                                                        */                 
   /* SCANBLOG - This sample REXX exec can scan several      */                 
   /*            days' worth of backup activity logs and     */                 
   /*            summarize the results.                  @XRC*/                 
   /*                                                        */                 
   /**********************************************************/                 
outdsn = "'HSMACT.SCAN.BAKLOG'"                                                 
notime= '**:**:**'                                                              
numrec = 1000                                                                   
num = 0                                                                         
msgs = ''                                                                       
   /* THIS IS SEVEN DAYS CONTIGUOUS ACTIVITY */                                 
    d.1  = "'HSMACT.HB.BAKLOG.D98089.T160139'"                                  
    d.2  = "'HSMACT.HB.BAKLOG.D98089.T185134'"                                  
    d.3  = "'HSMACT.HB.BAKLOG.D98090.T164202'"                                  
    d.4  = "'HSMACT.HB.BAKLOG.D98090.T184203'"                                  
    d.5  = "'HSMACT.HB.BAKLOG.D98091.T165216'"                                  
    d.6  = "'HSMACT.HB.BAKLOG.D98091.T185533'"                                  
    d.7  = "'HSMACT.HB.BAKLOG.D98092.T170123'"                                  
    d.8 = "'HSMACT.HB.BAKLOG.D98092.T180208'"                                   
    d.9 = "'HSMACT.HB.BAKLOG.D98093.T164227'"                                   
    d.10 = "'HSMACT.HB.BAKLOG.D98093.T172520'"                                  
    d.11 = "'HSMACT.HB.BAKLOG.D98094.T170020'"                                  
    d.12 = "'HSMACT.HB.BAKLOG.D98094.T171135'"                                  
    d.13 = "'HSMACT.HB.BAKLOG.D98095.T044203'"                                  
    d.14 = "'HSMACT.HB.BAKLOG.D98095.T131935'"                                  
d.0 = 14                                                                        
Y.0 = 0                                                                         
do n=1 to 4; dist.n=0; end                                                      
ebv = ''; ecd=''; emb= ''; ebm = ''; evo=''; ebu=''                             
"FREE F(IN)"                                                                    
"FREE F(OUT)"                                                                   
"DELETE "outdsn                                                                 
ops = "NEW CATALOG SPACE(1 1) TRACKS RECFM(F B) LRECL(80)"                      
"ALLOC F(OUT) DA("outdsn") "ops                                                 
"MAKEBUF"                                                                       
do q = 1 to d.0                                                                 
"ALLOC F(IN) DA("d.q") SHR REUSE"                                               
Call Sendout "Data Set Analyzed: "d.q                                           
"EXECIO "numrec" DISKR IN (STEM "x.                                             
DO WHILE X.0>0                                                                  
   num = num + x.0                                                              
   DO N=1 to X.0                                                                
     CALL analyze                                                               
   END                                                                          
   "EXECIO "numrec" DISKR IN (STEM "x.                                          
END                                                                             
"EXECIO 0 DISKR IN (FINIS"                                                      
"FREE F(IN)"                                                                    
end                                                                             
"DROPBUF"                                                                       
                                                                                
Call Sendout "Number of lines read: "num                                        
/*                                                                              
do while msgs \= ''                                                             
   PARSE VAR MSGS MSG MSGS                                                      
   Call Sendout "Number of "msg" ... "msgcount.msg                              
end */                                                                          
do while ebv \= ''                                                              
   parse var ebv eday ebv                                                       
   Call sendout "Expire bv  "eday xbv.eday.start xbv.eday.end ,                 
                                xbv.eday.numds                                  
   end                                                                          
do while ecd \= ''                                                              
   parse var ecd eday ecd                                                       
   Call sendout "CDS backup "eday xcd.eday.start xcd.eday.end                   
   end                                                                          
do while emb \= ''                                                              
   parse var emb eday emb                                                       
   Call sendout "Move BVers "eday xmb.eday.start xmb.eday.end ,                 
                                xmb.eday.numds                                  
   end                                                                          
do while ebm \= ''                                                              
   parse var ebm eday ebm                                                       
   Call sendout "Back Migds "eday xbm.eday.start xbm.eday.end ,                 
                                xbm.eday.numds                                  
   end                                                                          
do while evo \= ''                                                              
   parse var evo eday evo                                                       
   Call sendout "Vol Backup "eday xvo.eday.start xvo.eday.end ,                 
                                xvo.eday.numds                                  
   end                                                                          
do while ebu  \= ''                                                             
   parse var ebu eday  ebu                                                      
   Call sendout "Processing "eday "Expire=" xbu.eday.expbv ,                    
                                  "Backup=" xbu.eday.backup  ,                  
                                  "Tracks=" xbu.eday.tracks ,                   
                                  "Failed=" xbu.eday.fail                       
   end                                                                          
call sendout "Data Set size distribution:"                                      
   Call sendout "Number of Data Sets (0.0 - 0.5 MB) "format(dist.1,8)           
   Call sendout "Number of Data Sets (0.6 - 2.0 MB) "format(dist.2,8)           
   Call sendout "Number of Data Sets (2.1 -  20 MB) "format(dist.3,8)           
   Call sendout "Number of Data Sets (20.1 MB over) "format(dist.4,8)           
"EXECIO "y.0" DISKW OUT (FINIS STEM "y.                                         
"FREE F(OUT)"                                                                   
exit 0                                                                          
                                                                                
Analyze:                                                                        
   msg = substr(x.n,2,8)                                                        
   if left(msg,3)='ARC' then do                                                 
      if pos(msg,msgs)=0 then do                                                
         msgcount.msg = 0                                                       
         msgs = msgs msg                                                        
         end                                                                    
      msgcount.msg = msgcount.msg + 1                                           
      if msg='ARC0680I' | msg='ARC0681I' then call expbv                        
      if msg='ARC0740I' | msg='ARC0741I' then call cdsb                         
      if msg='ARC0718I' | msg='ARC0719I' then call mbv                          
      if msg='ARC0735I' | msg='ARC0736I' then call bmds                         
      if msg='ARC0722I' | msg='ARC0723I' then call volbv                        
      if msg='ARC0734I' then call dataset                                       
   end                                                                          
   else if pos('BACKUP LOG',x.n)>0 then do                                      
      parse var x.n 'DATE ' tod ' '                                             
      if pos(tod,ebu)=0 then do                                                 
         ebu = ebu tod                                                          
         xbu.tod.expbv   = 0                                                    
         xbu.tod.backup  = 0                                                    
         xbu.tod.tracks  = 0                                                    
         xbu.tod.fail    = 0                                                    
      end                                                                       
   end                                                                          
Return                                                                          
Sendout:                                                                        
   say arg(1)                                                                   
   k=y.0 + 1                                                                    
   y.k = arg(1)                                                                 
   y.0 = k                                                                      
Return                                                                          
Expbv:                                                                          
   parse var x.n ' ON ' day ','                                                 
   if pos(day,ebv)=0 then do                                                    
      ebv = ebv day                                                             
      xbv.day.start = notime                                                    
      xbv.day.end = notime                                                      
      xbv.day.numds = 0                                                         
      end                                                                       
   if msg = 'ARC0680I' then do                                                  
      parse var x.n 'AT ' tim1 ' ON '                                           
      xbv.day.start = tim1                                                      
      parse var day '19' tod                                                    
      if pos(tod,ebu)=0 then do                                                 
         ebu = ebu tod                                                          
         xbu.tod.expbv   = 0                                                    
         xbu.tod.backup  = 0                                                    
         xbu.tod.tracks  = 0                                                    
         xbu.tod.fail    = 0                                                    
      end                                                                       
      end                                                                       
   if msg = 'ARC0681I' then do                                                  
      parse var x.n 'AT ' tim2 ' ON ' . 'EXPIRED=' nd ','                       
      xbv.day.end   = tim2                                                      
      xbv.day.numds = nd                                                        
      end                                                                       
Return                                                                          
Cdsb:                                                                           
   parse var x.n ' ON ' day ','                                                 
   if pos(day,ecd)=0 then do                                                    
      ecd = ecd day                                                             
      xcd.day.start = notime                                                    
      xcd.day.end = notime                                                      
      end                                                                       
   if msg = 'ARC0740I' then do                                                  
      parse var x.n 'AT ' tim1 ' ON '                                           
      xcd.day.start = tim1                                                      
      end                                                                       
   if msg = 'ARC0741I' then do                                                  
      parse var x.n 'AT ' tim2 ' ON ' . 'EXPIRED=' nd ','                       
      xcd.day.end   = tim2                                                      
      end                                                                       
Return                                                                          
Mbv:                                                                            
   if msg = 'ARC0718I' then do                                                  
   parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                                
   if pos(day,emb)=0 then do                                                    
      emb = emb day                                                             
      xmb.day.start = notime                                                    
      xmb.day.end = notime                                                      
      xmb.day.numds = 0                                                         
      mbday = day                                                               
      end                                                                       
      xmb.day.start = tim1                                                      
      end                                                                       
   if msg = 'ARC0719I' then do                                                  
      parse var x.n 'AT ' tim2 ',' nd ' BACKUP'                                 
      xmb.mbday.end   = tim2                                                    
      xmb.mbday.numds = nd                                                      
      end                                                                       
Return                                                                          
Bmds:                                                                           
   if msg = 'ARC0735I' then do                                                  
   parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                                
   if pos(day,ebm)=0 then do                                                    
      ebm = ebm day                                                             
      xbm.day.start = notime                                                    
      xbm.day.end = notime                                                      
      xbm.day.numds = 0                                                         
      bmday = day                                                               
      end                                                                       
      xbm.day.start = tim1                                                      
      end                                                                       
   if msg = 'ARC0736I' then do                                                  
      parse var x.n 'AT ' tim2 ', ' nd ' DATA'                                  
      xbm.bmday.end   = tim2                                                    
      xbm.bmday.numds = nd                                                      
      end                                                                       
Return                                                                          
VolBV:                                                                          
   if msg = 'ARC0722I' then do                                                  
   parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                                
   if pos(day,evo)=0 then do                                                    
      evo = evo day                                                             
      xvo.day.start = tim1                                                      
      xvo.day.end = notime                                                      
      xvo.day.numds = 0                                                         
      voday = day                                                               
      end                                                                       
      end                                                                       
   if msg = 'ARC0723I' then do                                                  
      parse var x.n 'AT ' tim2 ', ' nd ' DATA'                                  
      xvo.voday.end   = tim2                                                    
      xvo.voday.numds = xvo.voday.numds + nd                                    
      end                                                                       
Return                                                                          
Dataset:                                                                        
   parse var x.n 'ACTION=' act ' FR' . 'TRACKS=' tr 'RC=' rcd ','               
   if act = 'EXBACKV' then do                                                   
      xbu.tod.expbv = xbu.tod.expbv + 1                                         
      end                                                                       
   if act = 'BACK-UP' then do                                                   
      if rcd = 0 & pos('***',tr)=0 then do                                      
         xbu.tod.backup = xbu.tod.backup + 1                                    
         xbu.tod.tracks = xbu.tod.tracks + tr                                   
         if tr<=10 then dist.1 = dist.1 + 1                                     
         else if tr<=40 then dist.2 = dist.2 + 1                                
         else if tr<=400 then dist.3 = dist.3 + 1                               
         else dist.4 = dist.4 + 1                                               
      end                                                                       
      else xbu.tod.fail = xbu.tod.fail + 1                                      
   end                                                                          
Return                                                                          
./ ADD NAME=SCANMLOG                                                            
/* REXX                                                  @XRC*/                 
   /**********************************************************/                 
   /*                                                        */                 
   /* SCANMLOG - This sample REXX exec can scan several      */                 
   /*            days' worth of migration activity logs and  */                 
   /*            summarize the results.                  @XRC*/                 
   /*                                                        */                 
   /**********************************************************/                 
outdsn = "'HSMACT.SCAN.MIGLOG'"                                                 
notime= '**:**:**'                                                              
numrec = 1000                                                                   
num = 0                                                                         
msgs = ''                                                                       
   /* THIS IS SEVEN DAYS CONTIGUOUS ACTIVITY */                                 
    d.1  = "'HSMACT.HB.MIGLOG.D98089.T002634'"                                  
    d.2  = "'HSMACT.HB.MIGLOG.D98089.T024418'"                                  
    d.3  = "'HSMACT.HB.MIGLOG.D98089.T031115'"                                  
    d.4  = "'HSMACT.HB.MIGLOG.D98089.T040727'"                                  
    d.5  = "'HSMACT.HB.MIGLOG.D98089.T052616'"                                  
    d.6  = "'HSMACT.HB.MIGLOG.D98089.T061418'"                                  
    d.7  = "'HSMACT.HB.MIGLOG.D98089.T074632'"                                  
    d.8  = "'HSMACT.HB.MIGLOG.D98089.T083043'"                                  
    d.9  = "'HSMACT.HB.MIGLOG.D98089.T095556'"                                  
    d.10 = "'HSMACT.HB.MIGLOG.D98089.T105234'"                                  
    d.11 = "'HSMACT.HB.MIGLOG.D98089.T111738'"                                  
    d.12 = "'HSMACT.HB.MIGLOG.D98089.T121912'"                                  
    d.13 = "'HSMACT.HB.MIGLOG.D98089.T134842'"                                  
    d.14 = "'HSMACT.HB.MIGLOG.D98089.T142938'"                                  
    d.15 = "'HSMACT.HB.MIGLOG.D98089.T160343'"                                  
    d.16 = "'HSMACT.HB.MIGLOG.D98089.T162354'"                                  
    d.17 = "'HSMACT.HB.MIGLOG.D98089.T171745'"                                  
    d.18 = "'HSMACT.HB.MIGLOG.D98089.T183515'"                                  
    d.19 = "'HSMACT.HB.MIGLOG.D98089.T192810'"                                  
    d.20 = "'HSMACT.HB.MIGLOG.D98089.T202034'"                                  
    d.21 = "'HSMACT.HB.MIGLOG.D98089.T211813'"                                  
    d.22 = "'HSMACT.HB.MIGLOG.D98089.T223324'"                                  
    d.23 = "'HSMACT.HB.MIGLOG.D98089.T231654'"                                  
    d.24 = "'HSMACT.HB.MIGLOG.D98090.T005827'"                                  
d.0 = 24                                                                        
Y.0 = 0                                                                         
do n=1 to 4; dist.n=0; end                                                      
ebv = ''; ecd=''; emb= ''; ebm = ''; evo=''; ebu=''; acts=''                    
fco = ''                                                                        
"FREE F(IN)"                                                                    
"FREE F(OUT)"                                                                   
"DELETE "outdsn                                                                 
ops = "NEW CATALOG SPACE(1 1) TRACKS RECFM(F B) LRECL(80)"                      
"ALLOC F(OUT) DA("outdsn") "ops                                                 
"MAKEBUF"                                                                       
do q = 1 to d.0                                                                 
"ALLOC F(IN) DA("d.q") SHR REUSE"                                               
Call Sendout "Data Set Analyzed: "d.q                                           
"EXECIO "numrec" DISKR IN (STEM "x.                                             
DO WHILE X.0>0                                                                  
   num = num + x.0                                                              
   DO N=1 to X.0                                                                
     CALL analyze                                                               
   END                                                                          
   "EXECIO "numrec" DISKR IN (STEM "x.                                          
END                                                                             
"EXECIO 0 DISKR IN (FINIS"                                                      
"FREE F(IN)"                                                                    
end                                                                             
"DROPBUF"                                                                       
                                                                                
Call Sendout "Number of lines read: "num                                        
do while msgs \= ''                                                             
   PARSE VAR MSGS MSG MSGS                                                      
   Call Sendout "Number of "msg" ... "msgcount.msg                              
end                                                                             
do while ebv \= ''                                                              
   parse var ebv eday ebv                                                       
   Call sendout "Mig Clean  "eday xbv.eday.start xbv.eday.end ,                 
                                xbv.eday.numds                                  
   end                                                                          
do while ecd \= ''                                                              
   parse var ecd eday ecd                                                       
   Call sendout "Sub move   "eday xcd.eday.start xcd.eday.end ,                 
                                xcd.eday.numds xcd.eday.tracks                  
   end                                                                          
do while emb \= ''                                                              
   parse var emb eday emb                                                       
   Call sendout "PSM        "eday xmb.eday.start xmb.eday.end                   
   end                                                                          
do while ebm \= ''                                                              
   parse var ebm eday ebm                                                       
   Call sendout "Back Migds "eday xbm.eday.start xbm.eday.end ,                 
                                xbm.eday.numds                                  
   end                                                                          
do while fco \= ''                                                              
   parse var fco xrc  fco                                                       
   Call sendout "Return Codes "xrc xco.xrc                                      
   end                                                                          
do while ebu  \= ''                                                             
   parse var ebu eday  ebu                                                      
   Call sendout "Processing "eday "Migrate=" xbu.eday.migrat,                   
                                  "Tracks=" xbu.eday.tracks ,                   
                                  "Failed=" xbu.eday.fail                       
   Call sendout "Processing "eday "Expire=" xbu.eday.exp     ,                  
                                  "Delete=" xbu.eday.del     ,                  
                                  "Scratch=" xbu.eday.scr                       
   end                                                                          
call sendout fco                                                                
call sendout "Data Set size distribution:"                                      
   Call sendout "Number of Data Sets (0.0 - 0.5 MB) "format(dist.1,8)           
   Call sendout "Number of Data Sets (0.6 - 2.0 MB) "format(dist.2,8)           
   Call sendout "Number of Data Sets (2.1 -  20 MB) "format(dist.3,8)           
   Call sendout "Number of Data Sets (20.1 MB over) "format(dist.4,8)           
"EXECIO "y.0" DISKW OUT (FINIS STEM "y.                                         
"FREE F(OUT)"                                                                   
exit 0                                                                          
                                                                                
Analyze:                                                                        
   msg = substr(x.n,2,8)                                                        
   if left(msg,3)='ARC' then do                                                 
      if pos(msg,msgs)=0 then do                                                
         msgcount.msg = 0                                                       
         msgs = msgs msg                                                        
         end                                                                    
      msgcount.msg = msgcount.msg + 1                                           
      if msg='ARC0526I' | msg='ARC0527I' then call mcl                          
      if msg='ARC0530I' | msg='ARC0531I' then call msub                         
      if msg='ARC0520I' | msg='ARC0521I' then call psm                          
      if msg='ARC0734I' then call dataset                                       
   end                                                                          
   else if pos('MIGRATION LOG',x.n)>0 then do                                   
      parse var x.n 'TIME ' tim ',  DATE ' tod ' '                              
      if pos(tod,ebu)=0 then do                                                 
         ebu = ebu tod                                                          
         xbu.tod.spmc    = 0                                                    
         xbu.tod.exp     = 0                                                    
         xbu.tod.del     = 0                                                    
         xbu.tod.scr     = 0                                                    
         xbu.tod.migrat  = 0                                                    
         xbu.tod.tracks  = 0                                                    
         xbu.tod.fail    = 0                                                    
      end                                                                       
      if psmend = 1 then do                                                     
         xmb.mbday.end = tim                                                    
         psmend = 0                                                             
         end                                                                    
   end                                                                          
Return                                                                          
Sendout:                                                                        
   say arg(1)                                                                   
   k=y.0 + 1                                                                    
   y.k = arg(1)                                                                 
   y.0 = k                                                                      
Return                                                                          
MCL:                                                                            
   if msg = 'ARC0526I' then do                                                  
      parse var x.n 'AT ' tim1 ' ON ' day ','                                   
      IF POS(day,ebv)=0 then ebv = ebv day                                      
      mcday = day                                                               
      xbv.mcday.start = tim1                                                    
      xbv.mcday.end   = NOTIME                                                  
      xbv.mcday.numds = 0                                                       
      end                                                                       
   if msg = 'ARC0527I' then do                                                  
      parse var x.n 'AT ' tim2 ',' nd 'MCDS'                                    
      xbv.mcday.end   = tim2                                                    
      xbv.mcday.numds = nd                                                      
      end                                                                       
Return                                                                          
msub:                                                                           
   if msg = 'ARC0530I' then do                                                  
      parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                             
   if pos(day,ecd)=0 then do                                                    
      ecd = ecd day                                                             
      subday = day                                                              
      xcd.subday.start = tim1                                                   
      xcd.subday.end = notime                                                   
      xcd.subday.numds = 0                                                      
      xcd.subday.tracks = 0                                                     
      end                                                                       
      end                                                                       
   if msg = 'ARC0531I' then do                                                  
      parse var x.n ',' nd 'DATA' . ',' tr 'TRACKS' . 'TIME ' tim2 ' '          
      xcd.subday.end   = tim2                                                   
      xcd.subday.numds = nd                                                     
      xcd.subday.tracks = tr                                                    
      end                                                                       
Return                                                                          
psm:                                                                            
   if msg = 'ARC0520I' then do                                                  
   if pos(day,emb)=0 then do                                                    
      emb = emb day                                                             
      xmb.day.start = tim                                                       
      mbday = day                                                               
      end                                                                       
      end                                                                       
   if msg = 'ARC0521I' then do                                                  
      psmend = 1                                                                
      end                                                                       
Return                                                                          
Bmds:                                                                           
   if msg = 'ARC0735I' then do                                                  
   parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                                
   if pos(day,ebm)=0 then do                                                    
      ebm = ebm day                                                             
      xbm.day.start = notime                                                    
      xbm.day.end = notime                                                      
      xbm.day.numds = 0                                                         
      bmday = day                                                               
      end                                                                       
      xbm.day.start = tim1                                                      
      end                                                                       
   if msg = 'ARC0736I' then do                                                  
      parse var x.n 'AT ' tim2 ', ' nd ' DATA'                                  
      xbm.bmday.end   = tim2                                                    
      xbm.bmday.numds = nd                                                      
      end                                                                       
Return                                                                          
VolBV:                                                                          
   if msg = 'ARC0722I' then do                                                  
   parse var x.n 'AT ' tim1 ' ON ' day ' SYSTEM'                                
   if pos(day,evo)=0 then do                                                    
      evo = evo day                                                             
      xvo.day.start = tim1                                                      
      xvo.day.end = notime                                                      
      xvo.day.numds = 0                                                         
      voday = day                                                               
      end                                                                       
      end                                                                       
   if msg = 'ARC0723I' then do                                                  
      parse var x.n 'AT ' tim2 ', ' nd ' DATA'                                  
      xvo.voday.end   = tim2                                                    
      xvo.voday.numds = xvo.voday.numds + nd                                    
      end                                                                       
Return                                                                          
Dataset:                                                                        
   parse var x.n 'ACTION=' act ' FR' . 'TRACKS=' tr 'RC=' rcd ','               
   if pos(act,acts)=0 then acts = acts act                                      
   if act = 'SPCMGMT' then do                                                   
      if rcd = 0 then say x.n                                                   
      xbu.tod.fail  = xbu.tod.fail  + 1                                         
      call failure                                                              
      end                                                                       
   if act = 'EXPIRED' then do                                                   
      xbu.tod.exp   = xbu.tod.exp   + 1                                         
      end                                                                       
   if act = 'DELETED' then do                                                   
      xbu.tod.del   = xbu.tod.del   + 1                                         
      end                                                                       
   if act = 'SCRATCH' then do                                                   
      xbu.tod.scr   = xbu.tod.scr   + 1                                         
      end                                                                       
   if act = 'MIGRATE' then do                                                   
      if rcd = 0 & pos('***',tr)=0 then do                                      
         xbu.tod.migrat = xbu.tod.migrat + 1                                    
         xbu.tod.tracks = xbu.tod.tracks + tr                                   
         if tr<=10 then dist.1 = dist.1 + 1                                     
         else if tr<=40 then dist.2 = dist.2 + 1                                
         else if tr<=400 then dist.3 = dist.3 + 1                               
         else dist.4 = dist.4 + 1                                               
      end                                                                       
      else do                                                                   
           xbu.tod.fail = xbu.tod.fail + 1                                      
           call failure                                                         
           end                                                                  
   end                                                                          
Return                                                                          
Failure:                                                                        
   xrc = right(rcd+0,3,'0')                                                     
   if pos(xrc,fco)=0 then do                                                    
      fco = fco xrc                                                             
      xco.xrc = 0                                                               
      end                                                                       
   xco.xrc = xco.xrc + 1                                                        
Return                                                                          
./ ADD NAME=SCANFSR                                                             
/* REXX                                                  @XRC*/                 
   /**********************************************************/                 
   /*                                                        */                 
   /* SCANFSR  - This sample REXX exec scans the FSR data    */                 
   /*            extracted from SMF (via IFASMFDP program)   */                 
   /*            and summarized by FSR type and Management   */                 
   /*            Class.                                      */                 
   /*                                                        */                 
   /*            Variables: set fsrid to the smf id for      */                 
   /*            fsr records, which is one more than the     */                 
   /*            value specified for DSR/VSR records.        */                 
   /*            If SETSYS SMFID(240) is specified, use 241. */                 
   /*                                                        */                 
   /*            Set the input and output data set names     */                 
   /*            accordingly.  Since REXX cannot process     */                 
   /*            Variable-blocked Span file I/O, this exec   */                 
   /*            will REPRO the data to a VB file for use.   */                 
   /*                                                    @XRC*/                 
   /**********************************************************/                 
fsrid = 241                                                                     
indsn = "'HSMSMF.FSRDATA'"                                                      
outdsn = "'HSMSMF.FSRDATA.REPORT'"                                              
notime= '**:**:**'                                                              
numrec = 1000                                                                   
num = 0; y.0 = 0                                                                
types = ''                                                                      
mgmt = ''                                                                       
mgmtb= ''                                                                       
"FREE F(IN)"                                                                    
"FREE F(OUT)"                                                                   
if sysdsn(outdsn)='OK' then "DELETE "outdsn                                     
ops = "NEW CATALOG SPACE(1 1) TRACKS RECFM(F B) LRECL(80)"                      
"ALLOC F(OUT) DA("outdsn") "ops                                                 
"MAKEBUF"                                                                       
   x = listdsi(indsn)                                                           
   say "RECFM = "sysrecfm                                                       
   if sysrecfm = 'VBS' then do                                                  
      "ALLOC F(IN) DA("indsn") SHR REUSE"                                       
      parse var indsn "'" hlq "." da "'"                                        
      tempdsn = "'"hlq"."da||"."VB"'";                                          
      if sysdsn(tempdsn)='OK' then do                                           
         indsn = tempdsn                                                        
         end                                                                    
      else do                                                                   
         ops = "LIKE("indsn") RECFM(V B) LRECL(332)"                            
         "ALLOC F(TEMP) DA("tempdsn") "ops                                      
         "REPRO INFILE(IN) OUTFILE(TEMP)"                                       
         "FREE FI(IN)"; "FREE FI(TEMP)"                                         
         indsn = tempdsn                                                        
         end                                                                    
      end                                                                       
"ALLOC F(IN) DA("indsn") SHR REUSE"                                             
Call Sendout "Data Set Analyzed: "indsn                                         
"EXECIO "numrec" DISKR IN (STEM "x.                                             
DO WHILE X.0>0                                                                  
   num = num + x.0                                                              
   DO N=1 to X.0                                                                
     CALL analyze                                                               
   END                                                                          
   "EXECIO "numrec" DISKR IN (STEM "x.                                          
END                                                                             
"EXECIO 0 DISKR IN (FINIS"                                                      
"FREE F(IN)"                                                                    
"DROPBUF"                                                                       
                                                                                
Call Sendout "Number of lines read: "num                                        
do while types \= ''                                                            
   parse var types type types                                                   
   call sendout "FSR Type=("type") ... "xtype.type                              
   end                                                                          
Call Sendout " "                                                                
Call Sendout "FSR counts by Management Class (Types 01 - 05)"                   
do while mgmt  \= ''                                                            
   parse var mgmt mc mgmt                                                       
   columns = format(xmc.mc.001,6) format(xmc.mc.002,6)                          
   columns = columns format(xmc.mc.003,6) format(xmc.mc.004,6)                  
   columns = columns format(xmc.mc.005,6)                                       
   call sendout "Management Class "mc columns                                   
   end                                                                          
                                                                                
Call Sendout " "                                                                
Call Sendout "FSR counts by Management Class (Type  07)"                        
do while mgmtb \= ''                                                            
   parse var mgmtb mc mgmtb                                                     
   columns = format(xmc.mc.007,6)                                               
   call sendout "Management Class "mc columns                                   
   end                                                                          
                                                                                
"EXECIO "y.0" DISKW OUT (FINIS STEM "y.                                         
"FREE F(OUT)"                                                                   
exit 0                                                                          
                                                                                
Analyze:                                                                        
    smftype = c2d(substr(x.n,2,1))                                              
      if smftype = fsrid   then do                                              
         fsrtype = right(c2d(substr(x.n,39,1)),3,'0')                           
         if pos(fsrtype,types)=0 then do                                        
            types = types fsrtype                                               
            xtype.fsrtype = 0                                                   
            end                                                                 
         if left(xtype.fsrtype,1)='x' then say fsrtype xtype.fsrtype            
         xtype.fsrtype = xtype.fsrtype + 1                                      
         if fsrtype>=1 & fsrtype<=5 then call migrec                            
         if fsrtype =7  then call backup                                        
         end                                                                    
Return                                                                          
Sendout:                                                                        
   say arg(1)                                                                   
   k=y.0 + 1                                                                    
   y.k = arg(1)                                                                 
   y.0 = k                                                                      
Return                                                                          
Migrec:                                                                         
   mc= strip(substr(x.n,211,8))                                                 
   mc = left(mc,9,'.')                                                          
   if pos(mc,mgmt)=0 then do                                                    
      mgmt = mgmt mc                                                            
      xmc.mc.001 = 0                                                            
      xmc.mc.002 = 0                                                            
      xmc.mc.003 = 0                                                            
      xmc.mc.004 = 0                                                            
      xmc.mc.005 = 0                                                            
      end                                                                       
   if pos(fsrtype,' 001 002 003 004 005 ')=0 then say fsrtype                   
   if left(xmc.mc.fsrtype,1)="x" then say xmc.mc.fsrtype                        
   xmc.mc.fsrtype = xmc.mc.fsrtype + 1                                          
Return                                                                          
Backup:                                                                         
   mc= strip(substr(x.n,211,8))                                                 
   mc = left(mc,9,'.')                                                          
   if pos(mc,mgmtb)=0 then do                                                   
      mgmtb = mgmtb mc                                                          
      xmc.mc.007 = 0                                                            
      end                                                                       
   xmc.mc.fsrtype = xmc.mc.fsrtype + 1                                          
Return                                                                          
./ ADD NAME=FSRSTAT                                                             
/* REXX                                                        @XRC*/           
parse arg indsn ops                                                             
/*******************************************************************/           
/*                                                                 */           
/*  FSRSTAT:  This sample REXX program reads FSR data and presents */           
/*            statistical results.  In some cases, the data is     */           
/*            presented as a histogram, to group data in certain   */           
/*            categories for further analysis.                     */           
/*                                                                 */           
/*            Method of invocation:                                */           
/*                                                                 */           
/*               FSRSTAT  'my.fsr.data.vb' FSRID(241)              */           
/*                                                                 */           
/*            Note: SMF data collected by IFASMFDP is saved in     */           
/*            Variable-Blocked-Spanned (VBS) format.  This must    */           
/*            be converted to Variable-Blocked using DFSORT or     */           
/*            IDCAMS REPRO, to be processed by this REXX program.  */           
/*            Any LRECL 332 or larger is acceptable.               */           
/*                                                                 */           
/*            The FSR type is defined by SETSYS SMFID(nnn) in the  */           
/*            SYS1.PARMLIB(ARCCMDxx) member.  The FSR type is      */           
/*            nnn+1, so if SETSYS SMFID(240) is specified, use     */           
/*            FSRID(241) to represent the FSR records.             */           
/*                                                                 */           
/*******************************************************************/           
if pos('FSRID(',ops)>0 then do                                                  
   parse var ops front 'FSRID(' fsrid ')' back                                  
   ops = front back                                                             
   end                                                                          
else fsrid = 241                                                                
Call OpenFiles                                                                  
TotCPU = 0                                                                      
Inc. = 0                                                                        
"EXECIO "numrec" DISKR IN (STEM "x.                                             
DO WHILE X.0>0; num=num+x.0                                                     
   DO N=1 to X.0; Call Analyze; End                                             
   "EXECIO "numrec" DISKR IN (STEM "x.                                          
   if (num//10000)=0 then say "Processing ... "num (totcpu%100)                 
END                                                                             
                                                                                
/*******************************************************************/           
/*                                                                 */           
/*  The statistical results are based on the records provided as   */           
/*  input.  Some may not make sense if the FSR records represent   */           
/*  a multitude of functions.                                      */           
/*                                                                 */           
/*  Use DFSORT, or similar SORT product, to select just those FSR  */           
/*  records that apply to a certain function, or meet some special */           
/*  criteria.                                                      */           
/*                                                                 */           
/*  Note: the use of ____NONE represents either (a) the data set   */           
/*  is not SMS-managed, or (b) is SMS-managed, but is not assigned */           
/*  an explicit management class.                                  */           
/*******************************************************************/           
NONE = "____NONE"                                                               
Call Sendout "Data Set Analyzed: "indsn                                         
Call Sendout "Number of lines read: "num                                        
if num>0 then do                                                                
Call Sendout " "                                                                
Call ShowCount "FSR records by type ", xtype, KEY, UP                           
Call ShowPercent "FSR records by host ", xhost, KEY, UP                         
end                                                                             
if naf=1 then do                                                                
Call ShowPercent "FSR records by Return Code ", xcode, COUNT, DOWN              
Call ShowCount "FSR records by Date",xdate, KEY, UP                             
Call ShowHist    "FSR records by Hour", xhour                                   
Call ShowHist    "FSR records by Size (KB)", xsize                              
Call ShowPercent "By Request (Mounted/TSO/User/Wait)", xreq, KEY, UP            
Call ShowPercent "By Request (1=Extent Reduction)"   , xext, KEY, UP            
Call ShowPercent "By Request (1=Piggy Back)"         , xpgb, KEY, UP            
CALL ShowPercent "By Request (1=Tape Takeaway)", xtaway, KEY, UP                
Call ShowHist    "FSR records by Age (days) ", xage                             
Call ShowHist    "By time completed (seconds)", xtime                           
Call ShowPercent "FSR records by Management Class ", xmc, COUNT, DOWN           
Call ShowPercent "FSR records by GDG ", xllq,KEY,UP                             
Call sendout "Total CPU seconds "totcpu%100                                     
/*                                                                              
Call ShowPercent "FSR records by HLQ ", xhlq,KEY,UP                             
Call ShowCount "FSR records by job (first n chars)", xjob,COUNT,DOWN            
Call ShowCount "FSR records by user (first n chars)", xuid,COUNT,DOWN           
Call ShowCount "FSR records by FKB  ", xfkb , KEY, UP                           
*/                                                                              
end                                                                             
Call CloseFiles                                                                 
exit 0                                                                          
OpenFiles:                                                                      
parse var indsn "'" base "'" ;outdsn = "'"base".FSRSTAT'"                       
numrec = 5000; num = 0; y.0 = 0; "FREE F(IN)"; "FREE FI(OUT)"                   
if sysdsn(outdsn)='OK' then ops = "OLD"; else ,                                 
   ops = "NEW CATALOG SPACE(1 1) TRACKS RECFM(F B) LRECL(80)"                   
"ALLOC F(OUT) DA("outdsn") "ops ; "MAKEBUF"                                     
"ALLOC F(IN) DA("indsn") SHR REUSE"                                             
Return                                                                          
CloseFiles:                                                                     
"EXECIO 0 DISKR IN (FINIS"; "FREE FI(IN)"; "DROPBUF"                            
"EXECIO "y.0" DISKW OUT (FINIS STEM "y. ; "FREE F(OUT)"                         
Return                                                                          
Analyze:                                                                        
smftype = c2d(substr(x.n,2,1))                                                  
if smftype = fsrid   then do                                                    
   fsrtype = right(c2d(substr(x.n,39,1)),3,'0')                                 
   fsrsid = substr(x.n,11,4)                                                    
  call keycount xtype,fsrtype; call keycount xhost,fsrsid                       
   if fsrtype\='015' & fsrtype\='016' then do                                   
   fsrdsn = substr(x.n,41,44)                                                   
   call getmc; naf=1                                                            
   lq=lastpos('.',fsrdsn); llq=substr(fsrdsn,lq+1,lq+9)                         
   llq = underline(llq," ","_"); llq=left(llq,2)"_"                             
   if llq>="G0_" & llq<="G9_" then llq = "GDG"; else llq="NON"                  
   qq = substr(x.n,105,4)                                                       
   q2 = 0; if c2x(left(qq,1))='00' then q2=c2d(qq)                              
   fsrrc   = right(q2,4,'0')                                                    
   fsrdatr = c2x(substr(x.n,133,4)); fsrtimr = c2x(substr(x.n,137,4))           
   fsrtims = c2x(substr(x.n,141,4)); fsrtime = c2x(substr(x.n,145,4))           
   fsrtima = c2x(substr(x.n,149,4)); timeq = stamp(fsrtimr,fsrtims)             
   timem = stamp(fsrtims,fsrtima);   timep = stamp(fsrtima,fsrtime)             
  timet = stamp(fsrtimr,fsrtime);                                               
  fsrflags = bitstr(substr(x.n,40,1))                                           
  fsrfkb = substr(fsrflags,4,1)                                                 
  readkb  = c2d(substr(x.n,161,3)); writekb = c2d(substr(x.n,165,3))            
  movekb = readkb + writekb                                                     
  if fsrfkb="0" then movekb = movekb % 4                                        
  if fsrfkb="1" then movekb = movekb * 256                                      
  fsrtvol = substr(x.n,85,6); tovol = left(fsrtvol,2)"_"                        
  fsrflg2 = bitstr(substr(x.n,175,1)); req=left(fsrflg2,4)                      
  fsrflg3 = bitstr(substr(x.n,176,1)); ext=substr(fsrflg3,4,1)                  
  fsrflg4 = bitstr(substr(x.n,128,1)); pgb=substr(fsrflg4,3,1)                  
  fsrcpu = 0; top=c2x(substr(x.n,177,1))                                        
  if  top = '00' then fsrcpu=c2d(substr(x.n,177,4))                             
  totcpu = totcpu + fsrcpu                                                      
  fsrage  = right(c2d(substr(x.n,181,2)),4,'0')                                 
  hr=left(fsrtimr,2)                                                            
  taway = C2D(BITAND(SUBSTR(x.n,219,1),'01'x))                                  
  CALL Keycount xtaway, taway;                                                  
  call keycount xcode,fsrrc  ; call keycount xdate,fsrdatr                      
  call keycount xreq,req     ; call keycount xmc,mc                             
  call keyHist  xage,fsrage,1,15  ; call keyHist  xhour,hr,2,11                 
  Call KeyHist  xtime,timet,30,14                                               
  Call Keycount xext, ext; call Keycount xpgb, pgb;                             
  Call keycount xllq, llq                                                       
  /*                                                                            
  call keycount xjob,jobname ; call keycount xuid,userid                        
  call keycount xfkb, fsrfkb                                                    
  Call keycount xhlq, hlq                                                       
  Call keycount xtov, tovol                                                     
  */                                                                            
  call keyHist  xsize, movekb,50,14                                             
   end                                                                          
   end                                                                          
Return                                                                          
KeyCount:                                                                       
tag=arg(1); key=arg(2); Inc.tag = 1                                             
if left(w.tag.KEYS,2)='W.' then do; w.tag.keys=''; w.tag.COUNT.=0; end          
if pos(key,w.tag.keys)=0 then ,                                                 
   do; w.tag.keys = w.tag.keys key; w.tag.COUNT.key = 0; end                    
w.tag.COUNT.key = w.tag.COUNT.key + 1; return                                   
ShowCount:                                                                      
If inc.tag=0 then return                                                        
header=arg(1); tag=arg(2); method=arg(3); mode=arg(4)                           
Call Sortby tag,method,mode; Call Sendout header                                
list=w.tag.keys; do while list  \= ''; parse var list key list                  
   call sendout left(key,10,' ') format(w.tag.COUNT.key,9); end                 
Call Sendout " "; Return                                                        
KeyHist:                                                                        
tag=arg(1); point=arg(2); bar=arg(3); limit=arg(4); inc.tag=1                   
key = (point/bar)%1; if key>limit then key=limit+1                              
key = right(key,2,'0')                                                          
if left(w.tag.KEYS,2)='W.' then ,                                               
   do; w.tag.keys=''; w.tag.HBAR = bar; w.tag.HLIMIT = limit                    
        w.tag.MAX=0                                                             
   do h=0 to limit+1; c1=right(h,2,'0'); w.tag.COUNT.c1=0; end; end             
if w.tag.MAX<point then w.tag.MAX=point                                         
w.tag.COUNT.key = w.tag.COUNT.key + 1; return                                   
ShowHist:                                                                       
header=arg(1); tag=arg(2); if inc.tag=0 then return                             
bar=w.tag.HBAR; limit=w.tag.HLIMIT; total=0; run=0                              
over=' over'; if w.tag.max<99999 then over=format(w.tag.max,5,0)                
Call Sendout header                                                             
do h=0 to limit+1; key=right(h,2,'0'); total=total+w.tag.COUNT.key; end         
do h=0 to limit+1; key=right(h,2,'0')                                           
   x1=w.tag.count.key; x2=100*(x1/total); run=run+x2                            
   if h<=limit then range = format(h*bar,5)"->"format(h*bar+bar-1,5)            
               else range = format(h*bar,5)"->"over                             
   if (h<=limit)|(w.tag.COUNT.key > 0) then ,                                   
   call sendout range format(w.tag.COUNT.key,9) ,                               
        format(x2,6,2)'% 'format(run,6,2)'%'; end                               
Call Sendout " "; Return                                                        
ShowPercent:                                                                    
header=arg(1); tag=arg(2); method=arg(3);  mode=arg(4);                         
if inc.tag=0 then return                                                        
Call Sortby tag,method,mode; Call Sendout header                                
list=w.tag.keys;                                                                
sn=words(list);                                                                 
total=0; run=0                                                                  
do q=1 to sn; c1=word(list,q); total=total+w.tag.COUNT.c1; end                  
list=w.tag.keys;                                                                
do while list  \= ''; parse var list key list                                   
   x1=w.tag.count.key; x2=100*(x1/total); run=run+x2                            
   call sendout left(key,10,' ') format(x1,9) ,                                 
        format(x2,6,2)'% 'format(run,6,2)'%'; end                               
Call Sendout " "; Return                                                        
Sortby:                                                                         
tag = arg(1); method= arg(2); mode = arg(3)                                     
list = w.tag.KEYS; snum=words(list)                                             
do q=1 to snum; v.q = word(list,q); end                                         
do j=1 to snum-1; do k=j+1 to snum; c1=v.j; c2=v.k                              
   if method='COUNT' then do; c1=w.tag.count.c1; c2=w.tag.count.c2; end         
   if mode='DOWN' then do; temp=c1; c1=c2; c2=temp; end                         
   if c1  > c2  then do; temp=v.j; v.j=v.k; v.k=temp; end; end; end             
new= '';                                                                        
do q=1 to snum;                                                                 
   new = new v.q;                                                               
end;                                                                            
w.tag.keys = new                                                                
Return                                                                          
Sendout: /* say arg(1) */                                                       
   k=y.0 + 1; y.k = arg(1); y.0 = k; return                                     
 /***********************************************************/                  
 /* CONVERT THE HEX VALUE TO INDIVIDUAL 1'S AND 0'S         */                  
 /* EACH BYTE WILL TAKE UP 8 CHARACTER POSITIONS            */                  
 /***********************************************************/                  
  BITSTR:                                                                       
  IF BIT.F \= "1111"  THEN DO                                                   
     BIT.0="0000"; BIT.1="0001"; BIT.2="0010"; BIT.3="0011"                     
     BIT.4="0100"; BIT.5="0101"; BIT.6="0110"; BIT.7="0111"                     
     BIT.8="1000"; BIT.9="1001"; BIT.A="1010"; BIT.B="1011"                     
     BIT.C="1100"; BIT.D="1101"; BIT.E="1110"; BIT.F="1111"                     
     END                                                                        
  CH=C2X(ARG(1)); BS=''                                                         
  DO B=1 TO LENGTH(CH); Q=SUBSTR(CH,B,1); BS=BS||BIT.Q; END                     
  RETURN BS                                                                     
GetMC:                                                                          
 fsrmcnam = substr(x.n,211,8); fsrmclen = c2d(substr(x.n,209,2))                
 mc= underline(fsrmcnam,' ','_');                                               
   fsrjbn = substr(x.n,15,8); fsruid=substr(x.n,31,8);                          
 jobname = left(underline(fsrjbn,' ','_'),1)||"__"                              
 userid  = left(underline(fsruid,' ','_'),1)||"__"                              
 RETURN                                                                         
 UNDERLINE:                                                                     
 ST = ''; L=LENGTH(ARG(1)); SP=ARG(2); UN=ARG(3)                                
 DO j=1 TO L; Q=SUBSTR(ARG(1),j,1); IF Q<' ' THEN Q=' '                         
   IF Q=SP  THEN ST = ST||UN; ELSE ST=ST||Q; END                                
if left(st,1)="_" then st=right("NONE",8,"_")                                   
RETURN ST                                                                       
stamp:                                                                          
time1 = arg(1); time2 = arg(2)                                                  
hour1 = left(time1,2); min1=substr(time1,3,2); sec1=right(time1,4)              
hour2 = left(time2,2); min2=substr(time2,3,2); sec2=right(time2,4)              
if hour2<hour1 then hour2=hour2+24                                              
stamp1 = 3600*hour1 + 60*min1 + (sec1/100)                                      
stamp2 = 3600*hour2 + 60*min2 + (sec2/100)                                      
return stamp2 - stamp1                                                          
$$                                                                              
//HSMSTEP3 EXEC PGM=IEBGENER                                                    
//*                                                                             
//********************************************************************          
//* CREATES THE FOLLOWING JCL FOR THE ABARS UTILITIES:           @04A*          
//*                                                              @04A*          
//* ARECPROC -  ISSUE THE ARECOVER COMMAND                       @04A*          
//* ARECSNGL -  SINGLE DATA SET RESTORE FOR ARECOVER             @04A*          
//* ASMAL    -  ASSEMBLE AND LINK EDIT SLEEP PROGRAM             @04A*          
//* DCOLLECT -  ISSUE DCOLLECT COMMAND FOR AGGREGATE             @04A*          
//* DRAUDIT  -  CREATE AUDIT REPORTS FOR ARECOVER PROCESSING     @04A*          
//* DRBACKUP -  SETUP AND ISSUE APPROPRIATE ABACKUP COMMAND      @04A*          
//* DRSCAN   -  LIST INFORMATION REGARDING DATA SETS TO BE       @04A*          
//*             BACKED UP BY ABARS                               @04A*          
//* DRSCAN   -  LIST INFORMATION REGARDING DATA SETS TO BE       @04A*          
//* HSMPATCH -  ABARS PATCH                                      @04A*          
//* SETABKUP -  ISSUE ABACKUP COMMAND                            @04A*          
//* SLEEPASM -  SLEEP ASSEMBLER PROGRAM                          @04A*          
//********************************************************************          
//*                                                                             
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD UNIT=SYSDA,                                                       
//            DSN=HSM.ABARUTIL.JCL(ARECPROC),                                   
//            DISP=(NEW,CATLG),                                                 
//            DCB=(RECFM=FB,LRECL=80),                                          
//            SPACE=(CYL,(2,1,10))                                              
//SYSIN    DD DUMMY                                                             
//SYSUT1   DD DATA,DLM='$$'                                                     
//ARECPROC JOB ?JOBPARM                                                         
//*                                                                             
//AGGNAME1 EXEC DRECOVER                                                        
//DRECOVER.SYSTSIN DD  *                                                        
    %ARECPROC  AGGNAME1                                                         
$$                                                                              
//HSMSTEP4 EXEC PGM=IEBUPDTE,PARM=NEW                                           
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD DSN=HSM.ABARUTIL.JCL,                                             
//            DISP=OLD                                                          
//SYSIN    DD DATA,DLM='$$'                                                     
./ ADD NAME=ARECSNGL                                                            
//ARECSNGL JOB ?JOBPARM                                                         
/*                                                                              
//*                                                                             
//DRECOVER PROC                                                                 
//*********************************************************************         
//******   ABARS ARECOVER                                                       
//*********************************************************************         
//ARECOVER EXEC PGM=IKJEFT01,DYNAMNBR=20,TIME=1440                              
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//STEPLIB   DD  DSN=A10DLH.TSO.LOAD,DISP=SHR                                    
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//DRECOVER PEND                                                                 
//AGGNAME1 EXEC DRECOVER                                                        
//ARECOVER.SYSTSIN DD  *                                                        
    %ARECSNGL  DAVETEST                                                         
//ARECOVER.INDSN DD  *                                                          
A10DLH.BADDSN                                                                   
/*                                                                              
./ ADD NAME=ASMAL                                                               
//ASMAL   JOB ?JOBPARM                                                          
//C      EXEC  PGM=IEV90,PARM=OBJECT,REGION=200K                                
//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR                                         
//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1           
//SYSPUNCH DD  SYSOUT=B,DCB=(BLKSIZE=800),SPACE=(CYL,(5,5,0))                   
//SYSPRINT DD SYSOUT=A,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))         
//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *        
//             DCB=(BLKSIZE=400),DSN=&&LOADSET                                  
//SYSIN    DD DSN=A10DLH.JCL.CNTL(SLEEPASM),DISP=SHR                            
//L    EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',REGION=96K,COND=(8,LT,C)         
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)                                  
//         DD  DDNAME=SYSIN                                                     
//SYSLMOD DD DSN=A10DLH.TSO.LOAD,DISP=SHR                                       
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1                         
//SYSPRINT DD  SYSOUT=A,DCB=(RECFM=FB,BLKSIZE=3509)                             
  ALIAS WAIT                                                                    
  NAME SLEEP(R)                                                                 
/*                                                                              
./ ADD NAME=DCOLLECT                                                            
//DCOLLCT JOB ?JOBPARM                                                          
//*                                                                             
//STEP1 EXEC PGM=IDCAMS                                                         
//SYSPRINT DD SYSOUT=*                                                          
//SYSIN    DD *                                                                 
  DCOLLECT OUTDATASET(HSMATH0.DCOLLECT.DATA) SMSDATA(ACTIVE) REPLACE            
/*                                                                              
./ ADD NAME=DRAUDIT                                                             
//DRAUDIT  JOB ?JOBPARM                                                         
//*                                                                             
//AUDIT PROC                                                                    
//AUDIT    EXEC PGM=IKJEFT01,DYNAMNBR=20,PARM='%DRAUDIT'                        
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//AGDET     DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//AGSUMM    DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//AUDIT    PEND                                                                 
//STEP1  EXEC AUDIT                                                             
//AUDIT.INCNTL DD  *                                                            
aggname1                                                                        
aggname2                                                                        
  .                                                                             
  .                                                                             
  .                                                                             
aggnameN                                                                        
/*                                                                              
./ ADD NAME=DRBACKUP                                                            
//DRBACKUP JOB ?JOBPARM                                                         
//*                                                                             
//TEST1 EXEC DRBACKUP                                                           
//ABACKUP.SYSTSIN DD  *                                                         
    %DRBACKUP  TEST1 UNIT(3480X) EXECUTE +                                      
               INPUT('IB996RV.TEST.ABARS.CNTL(TEST1)')                          
//ABARPOST.SYSTSIN DD  *                                                        
    %ABARPOST  TEST1 UNIT(3480X)                                                
/*                                                                              
./ ADD NAME=DRSCAN                                                              
//DRSCAN   JOB ?JOBPARM                                                         
//*                                                                             
//DRSCAN PROC                                                                   
//*********************************************************************         
//******   ABARS ABACKUP PRE PROCESSOR                                          
//******    1) ELIMINATES 'ARCIVE' DATASETS FROM AGGREGATE                      
//******    2) SET UP ENVIRONMENT FOR POST PROCESSING                           
//*********************************************************************         
//ABACKUP  EXEC PGM=IKJEFT01,DYNAMNBR=20                                        
//SYSPROC   DD  DSN=?????????.ISPCLIB,DISP=SHR                                  
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//ABRPT     DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//DRSCAN  PEND                                                                  
//STEP1  EXEC DRSCAN                                                            
//ABACKUP.SYSTSIN DD  *                                                         
    %DRSCAN  LMDB204 UNIT(3480X) VERIFY                                         
    %DRSCAN  LMDB304 UNIT(3480X) VERIFY                                         
    %DRSCAN  LMDB309 UNIT(3480X) VERIFY                                         
    %DRSCAN  LMDB312 UNIT(3480X) VERIFY                                         
/*                                                                              
./ ADD NAME=HSMPATCH                                                            
//HSMPTCH JOB ?JOBPARM                                                          
//IKJACCT EXEC PGM=IKJEFT01,DYNAMNBR=20                                         
//SYSPRINT DD  DUMMY                                                            
//SYSTSPRT DD  SYSOUT=*                                                         
//SYSTERM  DD  SYSOUT=*                                                         
//SYSIN    DD  DUMMY,DCB=BLKSIZE=80                                             
//SYSTSIN  DD  *                                                                
    HSEND PATCH .ABRCB.+81 BITS(.....1..)                                       
//*                                                                             
./ ADD NAME=SETABKUP                                                            
//SETABKP JOB ?JOBPARM                                                          
//DRBACKUP PROC                                                                 
//*********************************************************************         
//******   ABARS ABACKUP PRE PROCESSOR IF %DRBACKUP IS USED:                    
//******    1) ELIMINATES 'ARCIVE' DATASETS FROM AGGREGATE                      
//******    2) SET UP ENVIRONMENT FOR POST PROCESSING                           
//*********************************************************************         
//*********************************************************************         
//******   ABARS POST PROCESSOR                                                 
//******    1) WRITES ACTIVITY LOG TO DDNAME 'LOG'                              
//******       IF ABACKUP IS GOOD.....                                          
//******    2) WRITES ARECOVER STATEMENTS TO ARECOVER PARMS DATASET             
//******    3) CREATES DATASET ATTRIBUTE DETAIL REPORT                          
//*********************************************************************         
//ABARPOST EXEC PGM=IKJEFT01,DYNAMNBR=20                                        
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//DRBACKUP PEND                                                                 
//DAVETEST EXEC DRBACKUP                                                        
//ABARPOST.SYSTSIN DD  *                                                        
    %ABARPOST  DAVETEST UNIT(3490)                                              
//                                                                              
    HSEND WAIT ABACKUP DAVETEST UNIT(3490) EXECUTE                              
    %ABARPOST  DAVETEST UNIT(3490)                                              
./ ADD NAME=SLEEPASM                                                            
CMDNAME  TITLE ' TSO SLEEP command'                                             
         SPACE 1                                                                
***********************************************************************         
*                                                                     *         
*   Copyright IBM Corp. 2008                                      @ZRC*         
*                                                                     *         
*                                                                     *         
*        Command SLEEP puts a REXX Exec to sleep for a                *         
*        specified amount of seconds. Command used in ABARS           *         
*        Utilities to attempt to resolve dataset allocation           *         
*        conflicts.                                                   *         
*                                                                     *         
*        Command syntax:                                              *         
*                                                                     *         
*              SLEEP <number_of_seconds>                              *         
*                    'only' 15 digits allowed                         *         
*                    only numerics allowed                            *         
*                    default is 60 seconds                            *         
*                                                                     *         
***********************************************************************         
         SPACE 1                                                                
SLEEP    CSECT                                                                  
         SAVE  (14,12),,SLEEP(&SYSTIME._&SYSDATE) Save registers                
         LR    R12,R15             Load register 12 with entry address          
         USING SLEEP,R12           Establish addressability to SLEEP            
         ST    R13,SAVEAREA+4      Store address of previous savearea           
         LA    R2,SAVEAREA         Temp address of savearea                     
         ST    R2,8(,R13)          Store address of current savearea            
*                                    in previous savearea                       
         LR    R13,R2              Our save area.                               
         L     R6,0(,R1)           Point to the command buffer                  
         LH    R5,2(,R6)           Load index into command buffer.              
         LA    R4,4(R5,R6)         Point to command argument                    
         LH    R3,0(,R6)           Get length of command buffer                 
         SR    R3,R5               Subtract the command code length             
         SH    R3,=H'4'            Subtract length of prefix.                   
         BZ    STAX                Branch to process argument                   
ARGPROC  CH    R3,=H'15'           Only 15 characters in arg.                   
         BH    ERRMSG1               bin                                        
         LR    R2,R3               Set up validity check loop                   
         LR    R7,R4               Set up address reg for val. check            
VALLOOP  CLI   0(R7),C'0'          Larger than smallest num?                    
         BL    ERRMSG2               bin                                        
         CLI   0(R7),C'9'          Smaller than largest num?                    
         BH    ERRMSG2               bin                                        
         LA    R7,1(,R7)           Increment arg. pointer                       
         BCT   R2,VALLOOP            branch if more arg. chars.                 
         BCTR  R3,*-*              Decrement for EX instruction                 
         EX    R3,PACK             Pack the EBCDIC number.                      
         CVB   R2,DEC              Convert it to binary                         
         MH    R2,=H'100'          Get the number in hundreds of a sec.         
         ST    R2,TIME             Save it for STIMER.                          
         EJECT                                                                  
STAX     STAX  WAKEUP,             Address of exit routine             .        
               OBUF=(ATTNMSG,L'ATTNMSG), Message to interrupter        .        
               TOPLEVL=YES         This is a top level interrupt.               
         LTR R15,R15               STAX successful?                             
         BZ STIMER                   biy                                        
         TPUT  MSG3,L'MSG3         Issue warning and continue                   
STIMER   STIMER REAL,              Set the specified interval          .        
               WAKEUP,             Address of exit routine             .        
               BINTVL=TIME         Time interval for SLEEP                      
         WAIT  1,                  WAIT for timer expiration           .        
               ECB=WECB,           ECB to be posted after timer exp    .        
               LONG=YES            Swap out while at sleep.                     
RETURN   L     R13,4(R13)          Get previous savearea scale='0.8'.           
         RETURN (14,12),RC=0       Return to the TSO                            
ERRMSG1  TPUT  MSG1,L'MSG1         Issue error message                          
         B     ERRRETN                                                          
ERRMSG2  TPUT  MSG2,L'MSG2         Issue error message                          
         B     ERRRETN                                                          
ERRRETN  TPUT  MSGX,L'MSGX         Issue termination message                    
         L     R13,4(R13)          Get previous save area.                      
         RETURN (14,12),RC=12      Return to the TSO using rc = 12              
         EJECT                                                                  
*                                                                               
*  Combined wake up routine for STIMER and STAX                                 
*                                                                               
WAKEUP   SAVE  (14,12),,WAKEUP.ROUTINE                                          
         LR    R10,R15             Addressability in exit.                      
         DROP R12                                                               
         USING WAKEUP,R10                                                       
         LA    R3,EXITSAVE         Load address of workarea                     
         ST    R13,4(,R3)          Store address of previous savearea           
         ST    R3,8(,R13)          Store address of current savearea            
*                                    in previous savearea                       
         LR    R13,R3              Load register 13 with address of             
*                                    current savearea                           
         POST  WECB                Wake up mainline routine                     
         L     R13,4(R13)          Get previous savearea.                       
         RETURN (14,12),RC=0       Return to OS                                 
         DROP  R10                 Remove base reg. for exit                    
         USING SLEEP,R12           Re-establish base reg. for SLEEP             
         EJECT                                                                  
ATTNMSG  DC    C'SLEEP stopped due to ATTN'                  @FVC               
MSG1     DC    C'Time longer than 16 characters'                                
MSG2     DC    C'Time not numeric'                                              
MSG3     DC    C'STAX failed, SLEEP continues'                                  
MSGX     DC    C'SLEEP terminated due to error'                                 
PACK     PACK  DEC,0(*-*,R4)                                                    
SAVEAREA DS    18F                 Normal save area                             
EXITSAVE DS    18F                 Exit routine save area                       
WECB     DC    F'0'                Must contain zeros at WAIT time              
TIME     DC    F'6000'             Timer default (set to 60 sec)                
DEC      DS    D                   Dec time value (work field)                  
         SPACE 3                                                                
         LTORG                                                                  
         EJECT                                                                  
R0       EQU   0                                                                
R1       EQU   1                                                                
R2       EQU   2                                                                
R3       EQU   3                                                                
R4       EQU   4                                                                
R5       EQU   5                                                                
R6       EQU   6                                                                
R7       EQU   7                                                                
R8       EQU   8                                                                
R9       EQU   9                                                                
R10      EQU   10                                                               
R11      EQU   11                                                               
R12      EQU   12                                                               
R13      EQU   13                                                               
R14      EQU   14                                                               
R15      EQU   15                                                               
         END   SLEEP                                                            
$$                                                                              
//HSMSTEP5 EXEC PGM=IEBGENER                                                    
//*                                                                             
//********************************************************************          
//* THESE ARE THE PROCEDURES FOR THE ABARS UTILITIES:            @04A*          
//*                                                              @04A*          
//* DRBACKUP - PROVIDES AGGREGATE BACKUP SUPPORT                 @04A*          
//* DRECOVER - PROVIDES AGGREGATE RECOVERY SUPPORT               @04A*          
//********************************************************************          
//*                                                                             
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD UNIT=SYSDA,                                                       
//            DSN=HSM.ABARUTIL.PROCLIB(DRBACKUP),                               
//            DISP=(NEW,CATLG),                                                 
//            DCB=(RECFM=FB,LRECL=80),                                          
//            SPACE=(CYL,(1,1,5))                                               
//SYSIN    DD DUMMY                                                             
//SYSUT1   DD DATA,DLM='$$'                                                     
//DRBACKUP PROC                                                                 
//*********************************************************************         
//******   ABARS ABACKUP PRE PROCESSOR IF %DRBACKUP IS USED:                    
//******    1) ELIMINATES 'ARCIVE' DATASETS FROM AGGREGATE                      
//******    2) SET UP ENVIRONMENT FOR POST PROCESSING                           
//*********************************************************************         
//ABACKUP  EXEC PGM=IKJEFT01,DYNAMNBR=20,TIME=1440                              
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//*********************************************************************         
//******   ABARS POST PROCESSOR                                                 
//******    1) WRITES ACTIVITY LOG TO DDNAME 'LOG'                              
//******       IF ABACKUP IS GOOD.....                                          
//******    2) WRITES ARECOVER STATEMENTS TO ARECOVER PARMS DATASET             
//******    3) CREATES DATASET ATTRIBUTE DETAIL REPORT                          
//*********************************************************************         
//ABARPOST EXEC PGM=IKJEFT01,DYNAMNBR=20                                        
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//*********************************************************************         
//******   ABENDBK - ISSUE U0100 ABEND CODE IF ABACKUP  STEP ISSUES             
//******   A RETURN CODE NOT EQUAL TO 0                                         
//*********************************************************************         
//ABENDBK EXEC PGM=GPABEND,COND=(0,EQ,ABACKUP)                                  
//SYSOUT  DD SYSOUT=*                                                           
$$                                                                              
//HSMSTEP6 EXEC PGM=IEBUPDTE,PARM=NEW                                           
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD DSN=HSM.ABARUTIL.PROCLIB,                                         
//            DISP=OLD                                                          
//SYSIN    DD DATA,DLM='$$'                                                     
./ ADD NAME=DRECOVER                                                            
//DRECOVER PROC                                                                 
//*********************************************************************         
//******   ABARS ARECOVER                                                       
//*********************************************************************         
//ARECOVER EXEC PGM=IKJEFT01,DYNAMNBR=20,TIME=1440                              
//SYSEXEC   DD  DSN=HSM.SAMPLE.TOOL,DISP=SHR                                    
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//*********************************************************************         
//******   ABENDBK - ISSUE U0100 ABEND CODE IF ARECOVER STEP ISSUES             
//******   A RETURN CODE NOT EQUAL TO 0                                         
//*********************************************************************         
//ABENDBK EXEC PGM=GPABEND,COND=(0,EQ,ARECOVER)                                 
//SYSOUT  DD SYSOUT=*                                                           
$$                                                                              
//HSMSTEP7 EXEC PGM=IEBGENER                                                    
//*                                                                             
//********************************************************************          
//* THIS IS THE ABARS UTILITIES REFERENCE MATERIAL:              @04A*          
//*                                                              @04A*          
//* ABARTREF - ABARS UTILITIES TECHNICAL REFERENCE               @04A*          
//* ABARUG   - ABARS UTILITIES USER'S GUIDE                      @04A*          
//*                                                              @04A*          
//********************************************************************          
//*                                                                             
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD UNIT=SYSDA,                                                       
//            DSN=HSM.ABARUTIL.DOCS(ABARTREF),                                  
//            DISP=(NEW,CATLG),                                                 
//            DCB=(RECFM=FB,LRECL=80),                                          
//            SPACE=(CYL,(1,1,10))                                              
//SYSIN    DD DUMMY                                                             
//SYSUT1   DD DATA,DLM='$$'                                                     
.cm  gdoc sec='unclassified'                                                    
:GDOC SEC='(C)COPYRIGHT INTERNATIONAL BUSINESS MACHINES CORPORATION 1994        
.cm  qprint dcf options 'twopass cont prof(dsmprof3'                            
:frontm.                                                                        
:titlep.                                                                        
:title.ABARS REXX Utilities                                                     
:title.Technical Reference                                                      
:address.                                                                       
:aline.D. L. Heggen                                                             
:aline.214 280-5432                                                             
:aline.Tie 542-5432                                                             
:eaddress.                                                                      
:address.                                                                       
:aline.IBM Corporation                                                          
:aline.Department 1MJD                                                          
:aline.1605 LBJ Freeway                                                         
:aline.Dallas, Texas  75234                                                     
:eaddress.                                                                      
:date.February 7th, 1994                                                        
:etitlep.                                                                       
.ll 4i                                                                          
:toc.                                                                           
.ll 6i                                                                          
:body                                                                           
:h2.Introduction                                                                
:p.ABARS stands for Aggregate Backup and Recovery System.  It is an             
extension of IBM's DFHSM product and allows for the backup (and in the          
case of a disaster) the recovery of an application's data.  It creates          
a transportable logical (as opposed to physical) copy of the                    
application's data.  The use of logical copies allows for the data              
to be restored on a different device type than it originated.  This             
simplifies recovery, because the Recovery Site need only supply the             
required storage capacity for the application, not a specific                   
configuration.                                                                  
:p.The ABARS Utilities allow Customers the ability to track and control         
the execution of hundreds of ABARS aggregates defined in their                  
datacenters.                                                                    
:h2.Technical Detail                                                            
:h3.Utility Flow                                                                
:p.Assuming HSEND and ABACKUP are restricted commands, Application              
Owners request a ABARS Aggregate to be set-up for their use.  If                
DRBACKUP is to be used (as opposed to the regular ABACKUP command),             
The first selection dataset is not owned by the Application Owner               
and defined to DFSMS with a name that allow Storage Administration              
write access.  DRSCAN is used initially, to supply information                  
to the application owner concerning the location of the datasets                
included in the aggregate.  After a few iterations of DRSCAN, the               
Include/Exclude list for the aggregate is finalized, and production             
can start.  Production Jobs of the DRBACKUP JCL PROCs are usually               
submitted via a Scheduling package (CA7,OPC/ESA,etc).  The ARECOVER             
Parms produced as output from ABARPOST step of the DRBACKUP Procedure           
are transmitted to the recovery site in coordination with the Vaulting          
Cycle.                                                                          
:p.At the Recovery Site, the ARECOVER parms are merged to a single PDS          
with the aggregate name as the member name (most to least recent,               
copy without replacement).  Application owners schedule their                   
ARECOVER jobs to start (determine the order of restoration).  These             
jobs read the PARMS dataset and execute the ARECOVER command, copy              
the activity log to SYSOUT, and update a dataset with the aggregate             
name and log dataset name (for audit).                                          
:p.At some point in time an AUDIT is executed with a list of aggregates         
to be checked.  The Audit lists the logs for the aggregate, the number          
of times an ARECOVER has executed, and checks the status of movement            
of each dataset in the aggregate to the recovery site.                          
:h2.Installation                                                                
:h3.Pre-Requisite Maintenance                                                   
:p.Need PTF UY73400 to write message ARC6030I to the system log                 
(SYSLOG).  This message contains the name of the aggregate and the              
name of the activity log.                                                       
:p.Need hsm patch as described in the text of PTF UY73400                       
(Presented later in this document)                                              
:p.Need APARS OY59794, OY60048, and OY37378 to allow DCOLLECT to                
gather data on DFSMS Constructs.                                                
:h3.Automated Operations Interface                                              
:h4.Activity Log Name Capture                                                   
:p.Message(s) ARC6030I must be trapped and parsed for these utilities.          
The utilities need to be presented with the Activity Log Dataset Name           
for a given Aggregate Name.  Initial implementation used AUTOMATE/MVS           
and it set Global Variables that we accessed through the utilities.             
The ARC6030I message has 4 flavors.  There are differences between              
DFHSM 2.6 /DFSMShsm 1.1 and ABACKUP/ARECOVER.  So depending on the              
release and activity, the Automated Operations interface may need to            
be different. The exec DR14AM is an example of an interface to Automate         
and exec DR14NV is an implementation using NETVIEW.  In the appendix            
of this document are instructions/examples of implementation of the             
NETVIEW interface.                                                              
:h4.DCOLLECT Executions                                                         
:p.If the REXX exec DRBACKUP is necessary then                                  
any time the aggregate definition changes, a DCOLLECT needs to                  
be run to capture the new structure.  For convenience, we set up                
Automate/MVS to submit DCOLLECT whenever a SETSMS activate                      
was successful (msg IGD0008I).                                                  
:H4.ARECOVER Parms Transmission                                                 
:p.This environment vaults tapes twice daily.  We set up an NDM                 
transmission of the ARECOVER Parms Dataset approximately 30 minutes             
prior to the vault run.  It is sent to the Recovery Site as a GDG PDS           
and with a limit of 70.  We then copy to the ARECOVER.PARMS dataset from        
the GDGs starting from GDG(0) to GDG(-69) without replacement                   
With this setup, our recovery has the most                                      
current ARECOVER commands for the daily, weekly, and monthly aggregates.        
:h3.HSM Setup                                                                   
:p.Need the DFSMS/hsm ARCCMDxx member to specify SETSYS                         
ABARSACTLOGMSGLVL(FULL) to insure all DFDSS messages are written to             
the activity log.  SETSYS ABARSACTLOGMSGLVL(FULL) is the default if             
not specified.                                                                  
:p.With ABARS II, the minimum number of tapes needed for an aggregate           
increased from 2 to 3 tapes. A DFSMS/hsm patch exists to change the             
minimum tapes needed for a aggregate back to 2 tapes.  If this                  
patch is applied, changes will need to be made to DRxx to not eliminate         
the last two datasets in the Aggregate for Audit (they would have been          
the instruction dataset and the activity log from ABACKUP).                     
:h3.REXX EXECS and JCL                                                          
:sl.                                                                            
:li.Copy REXX Execs to Production REXX Library                                  
:li.Allocate 2 Datasets for their use                                           
:sl.                                                                            
:li.HLQ.DCOLLECT.DATA (RECFM=VB,LRECL=644,DSORG=PS), should need no             
more than 750Kb, DFSMS constructs are recorded here, DRBACKUP utility           
reads the "AG" record types for the selection dataset name.                     
:li.HLQ.ARECOVER.PARMS (RECFM=FB,LRECL=80,DSORG=P0), should need no             
more than 3750Kb, ABARS ARECOVER commands are recorded here with the            
ABACKUP Activity Log Name (contains the date/time stamp) and a list of          
datasets included in the aggregate for audit purposes.  This dataset            
list is an improvement over mounting tapes and read the control file            
of the aggregate to audit.                                                      
:esl.                                                                           
:li.Specify dataset names for the utilities use in the REXX exec DR10.          
This exec is called and the result is parsed to supply 'Global                  
Variables' for the utilities to allocate their datasets.                        
:ol.The datasets are:                                                           
:li.the DCOLLECT dataset - discussed earlier                                    
:li.the ARECOVER PARMS dataset - discussed earlier                              
:li.the Temporary High Level Qualifier - This is used by various                
utilities for allocation of 'temporary' datasets. It would be                   
appropriate to associate this high-level qualifier with a                       
management class that deletes after 2 days unreferenced.                        
These datasets are normally                                                     
only a few tracks in size and needed only for a short period of time            
after allocation (e.g. ABARPOST will allocate a temp. dataset when              
its needed and delete it. This dataset                                          
contains information for the DSN Detail Report)                                 
:li.the ARECOVER LOGS dataset (Allocated by ARECPROC when needed)               
:eol.                                                                           
:li.Copy DR10 to member DR10SAVE in the same library.  This convention          
saves the information in DR10 so that new distributions of the code             
can overlay DR10 and installation supplied parameters can be reinstated.        
:li.Copy DRBACKUP and DRECOVER PROCs to a proclib available to batch            
jobs.                                                                           
:li.Copy DRBACKUP, DRECOVER, ARECPROC, and DRAUDIT to a jcl library             
for submission.                                                                 
:li.COPY DR14AM (Automate/MVS) or DR14NV(NETVIEW) to DR14.  This will           
enable the supplied interface to Console Automation.  An example of             
Console Automation via NETVIEW is supplied in the appendix of this              
document.                                                                       
:li.Decide if DRBACKUP is to be used in this installation.... If so             
existing aggregates will need to have a different selection dataset.            
(ALTER the Aggregate in ISMF).                                                  
DRBACKUP will use the existing selection dataset as input and it will           
re-write the 'new' selection dataset for the aggregate.  DRBACKUP also          
restricts the aggregate to use only the first selection dataset (ABARS          
allows up to 5).                                                                
:esl.                                                                           
:h2.Program Detail                                                              
:p.The naming convention used for execs is as follows.  The Driver              
Execs are given a name indicative of their function.  The supporting            
execs are DRxyz; where x is a number from 1-7 identifying the Driver            
exec they were designed to support, y is the order of sequence that             
they are first called by the driver, and z (if used) is a subroutine            
used by the DRxy supporting exec.  I tried to generalize and re-use             
these execs wherever it made sense.  So DR10 is used by all execs.              
DR13 is used twice by DRBACKUP and optionally by DRSCAN and DRSEO.              
Inside these execs can be other internal subroutines for their use              
exclusively.  For example, WRITEAA is a subroutine in DR15 and its              
use is to write the allocate/accompany statements to the ABARS                  
selection dataset.                                                              
:h3.DRBACKUP exec                                                               
:ol.Driver exec for DRBACKUP Function. Parameters passed are the                
Aggregate Name, Tape Unit, EXECUTE/VERIFY, and the Input Dataset.               
Output will be Return Code 16, if a problem is found with execution,            
or the return code from ABACKUP.                                                
:li.Suppresses TSO Messages                                                     
:li.Calls DR10 to get global parameters                                         
:li.Calls DR11 to parse parameters sent                                         
:li....Quits if problem found                                                   
:li.Calls DR12 to get Selection Dataset from Dcollect Data                      
:li....Quits if problem found                                                   
:li.Calls DR13 to copy input dataset to selection dataset                       
:li....Exits EXEC if problem found                                              
:li.Issues ABACKUP ...Verify command                                            
:li.Calls DR14 to locate Abars Activity Log Name                                
:li.Calls DR15 to parse log and exclude 'ARCIVE' datasets                       
:li.Calls DR13 to copy revised input dataset to selection dataset               
:li.Issues ABACKUP command with option supplied as parameter                    
:li.Calls DR16 to clear Aggregate's Selection Dataset                           
:eol.                                                                           
:h3.DR10 exec                                                                   
:ol.Global Variables exec                                                       
No parameters are passed to this exec. It's called                              
from all Driver Execs and returns Global Variables.                             
:li.Sets strings up as variables to be used by all utilities                    
:li.Returns variables as result                                                 
:eol.                                                                           
:h3.DR11 exec                                                                   
:ol.Performs edits on parameters passed to DRBACKUP                             
:li.Checks to see that all variables are passed                                 
:li....Exits EXEC if problem found                                              
:li.Checks to see that either 'EXECUTE' or 'VERIFY' was requested               
:li....Exits EXEC if problem found                                              
:li.Parses out Input dataset Specification                                      
:li.Checks to see if input dataset exists                                       
:li....Exits EXEC if problem found                                              
:li.Returns Input Dataset Name as result, if successful                         
:eol.                                                                           
:h3.DR12 exec                                                                   
:ol.Reads the DCOLLECT Data for Aggregate Structure                             
Passed the Aggregate Name and the DCOLLLECT.DATA Global Variable.               
Logic in the exec gets all selection datasets for the aggregate                 
but it returns only the first selection dataset.  We'll need APAR               
OW01729 to allow the use of more than 1 selection dataset in DRBACKUP.          
:li.Allocates DCOLLECT Dataset                                                  
:li....Exits EXEC if problem found                                              
:li.Looks for AG record Type and this aggregate's name in the record            
:li....Exits EXEC if not found                                                  
:li.Loops through Selection Datasets                                            
:li.Constructs the aggregate's first selection dataset name                     
:li.Returns Selection Dataset Name as result, if successful                     
:eol.                                                                           
:h3.DR13 exec                                                                   
Passed the Aggregate name and the Input and Output Dataset.                     
Nothing is passed back if no error is detected.                                 
:ol.Copies the Input dataset to the selection (output) dataset                  
:li.Checks to insure input dataset and output dataset aren't the same           
:li....Exits EXEC if they are the same                                          
:li.Insures the selection dataset exists on the system                          
:li....Exits EXEC if not found                                                  
:li.Allocates output, input, and utility datasets                               
:li.Calls IEBGENER to perform copy                                              
:li.Returns 0                                                                   
:eol.                                                                           
:h3.DR14 exec                                                                   
Passed the Aggregate Name.                                                      
:ol.Get the activity log name for the aggregate                                 
:li.Shuts off TSO messages                                                      
:li.Creates the variable name saved for us by AUTOMATE/MVS                      
:li.Issues AUTOMATE GETVAR Command to be returned the logname                   
:li.Create a fully qualified name out of the Logname Returned                   
:li.Return with logname as the result                                           
:eol.                                                                           
:h3.DR15 exec                                                                   
:ol.Read the log and the input dataset and Create the Revised Input             
Passed the Aggregate Name, Selection DSN, and Activity Log DSN                  
Parsing logic also exists here capable of dealing with multiple                 
selection datasets.  Changes need to be made here and DR12 to allow             
more than one selection dataset to be used.  see DR12.                          
:li.Shuts off TSO messages                                                      
:li.Allocate and read the activity log                                          
:li.Check to Insure Activity Log is from VERIFY Function                        
:li....Exits EXEC if problem found                                              
:li.Parses for Starting and Ending messages of INC/EXC stmts                    
:li.Between starting and ending messages, parse for dataset names               
:li.Issue LISTCAT command with dataset name                                     
:li.Call DR151 for possible dataset elimination                                 
:li.If not excluded, place DSN on stem variable                                 
.hr left right                                                                  
:li.Read Selection dataset                                                      
:li.Parse it for Allocate/Accompany statements                                  
:li.Place allocate/ accompany statements on stem variables                      
.hr left right                                                                  
:li.Allocate a Temporary dataset                                                
:li.Write Include statements to temporary dataset                               
:li.Write allocate/accompany statements to temporary dataset                    
:li.Return temporary datasetname                                                
:eol.                                                                           
:h3.DR16 exec                                                                   
Passed the Aggregate Name and Selection Dataset Name.                           
:ol.Prevents ABACKUP from attempting successful execution                       
:li.Writes comment to dataset as 1 record                                       
:li.close dataset                                                               
:eol.                                                                           
.pa                                                                             
:h3.ABARPOST exec                                                               
:ol.Driver exec for ABARPOST Function                                           
:li.Suppresses TSO Messages                                                     
:li.Calls DR10 to get global parameters                                         
:li.Calls DR14 to locate Abars Activity Log Name                                
:li.Calls DR21 to parse log, copy to SYSOUT, code ARECOVER, and                 
gather information for DSN Detail report                                        
:li.Calls DR22 to create DSN Detail Report                                      
:eol.                                                                           
:h3.DR21 exec                                                                   
:ol.Parses the log for required functions                                       
:li.Allocate report Dataset                                                     
:li.Allocate Activity Log                                                       
:li....Exits EXEC if problem found                                              
:li.Read log until EOF                                                          
:sl.                                                                            
:li.Write log record to DDNAME LOG                                              
:li.Look for the last message                                                   
:li....Set the return code to the Return code in the log                        
:li.Look for the message with the control dataset information                   
:li....Save this for ARECOVER Command                                           
:li.Look for the DF/DSS dataset messages                                        
:li....Call DR212 to gather detail dataset information                          
:li.......Write dsn detail to dsn detail dataset                                
:esl.                                                                           
:li.Insure parms dataset is available                                           
:li....Exits EXEC if problem found                                              
:li.Allocate ARECOVER Parms Dataset                                             
:li.Call DR211 to set up ARECOVER command                                       
:li.Write ARECOVER Parms and datasets to ARECOVER PARMS dataset                 
:li.Return                                                                      
:eol.                                                                           
:h3.DR22 exec                                                                   
:ol.                                                                            
:li.Allocate the DSN Detail Dataset                                             
:li.Read the DSN Detail Dataset                                                 
:li.Write Report to the LOG DDNAME                                              
:li.close datasets                                                              
:eol.                                                                           
.pa                                                                             
:h3.ARECPROC exec                                                               
:ol.Driver exec for ARECPROC Function                                           
:li.Suppresses TSO Messages                                                     
:li.Calls DR10 to get global parameters                                         
:li.Calls DR31 to Read ARECOVER Parms Dataset and Issue ARECOVER                
:li.Calls DR14 to locate Abars Activity Log Name                                
:li.Calls DR31 to process the ABARS Activity Log                                
:eol.                                                                           
:h3.DR31 exec                                                                   
:ol.Read, parse, create, and execute ARECOVER Command                           
:li.Determine the release of DFHSM at recovery site                             
:li.Allocates ARECOVER Parms Dataset                                            
:li....Exits EXEC if problem found                                              
:li.Reads and Parses ARECOVER Parms                                             
:li.Create and Execute HSEND ARECOVER command                                   
:li.Return                                                                      
:eol.                                                                           
:h3.DR32 exec                                                                   
:ol.Reads the arecover log and tracks the arecover executions                   
:li.Checks to see of the ARECOVER Activity Log exists                           
:li....Exits EXEC if problem found                                              
:li.Reads through the log for the ending return code                            
:li.Allocates the Log of Logs dataset if not found                              
:li.Writes 1 record to LOL dataset with DISP=MOD                                
:li.Return                                                                      
:eol.                                                                           
.pa                                                                             
:h3.DRAUDIT exec                                                                
:ol.Reads aggregate names as input and creates Audit Summary Report             
:li.Open input INCNTL and output AGSUMM ddnames                                 
:li.Read first record from INCNTL                                               
:li.Do While not EOF                                                            
:li....Count the aggregates we are processing                                   
:li....Check if we need a new report heading                                    
:li....Call ARAUDIT with the aggregate name                                     
:li....Parse result for the number of datasets and the number of errors         
:li....Write line to the summary report                                         
:li....Count the datasets and errors                                            
:li.write total aggregates, datasets and errors                                 
:eol.                                                                           
:h3.ARAUDIT exec                                                                
:ol.Call DR10 to set up global parameters                                       
:li.Call DR41 to create Audit Detail Report                                     
:li.Return with the number of datasets and errors                               
:eol.                                                                           
:h3.DR41 exec                                                                   
:ol.                                                                            
:li.Read the Log of Logs dataset                                                
:li.Do While not EOF                                                            
:li....If Aggregate name equals the Aggregate name in the LOL                   
:li....tally the match                                                          
:li....save the Activity Log DSN                                                
:li.Check to see we had matches                                                 
:li....If not, Provide message 'all Datasets in error'                          
:li....Otherwise, List the Activity Log Dataset Name                            
:li.Provide the count of log names as the # of times ARECOVER Executed          
:li.Allocate the ARECOVER Parms Dataset                                         
:li.Skip over the first 6 records                                               
:li.Read until EOF                                                              
:li....Parse out DSN of dataset in the aggregate                                
:li....Issue LISTDSI command against the dataset                                
:li....If Error                                                                 
:li.......Write Detail line with Dataset Name and Nature of the error           
:li.If no errors                                                                
:li....Write Detail Line indicating no datasets with errors                     
:li.Return with the number of datasets and errors                               
:eol.                                                                           
.pa                                                                             
:h3.DRSCAN EXEC                                                                 
:ol.Driver exec for DRSCAN Function                                             
:li.Suppresses TSO Messages                                                     
:li.Calls DR10 to get global parameters                                         
:li.Checks to see if the Input Parameter was sent                               
:li....If so, Checks to see if the Input dataset exists                         
:li.......If not, Exits with error message                                      
:li.Checks to see if the Input Parameter was sent                               
:li....Parses the input dsn out of the Input Parameter                          
:li....Calls DR12 to get Selection Dataset from Dcollect Data                   
:li....Quits if problem found                                                   
:li.Checks to see if the Input Parameter was sent                               
:li....Calls DR13 to copy input dataset to selection dataset                    
:li......Exits EXEC if problem found                                            
:li.Issues ABACKUP ...Verify command                                            
:li.Calls DR14 to locate Abars Activity Log Name                                
:li.Calls DR51 to parse log and List DSN information                            
:li.Checks to see if the Input Parameter was sent                               
:li....Calls DR16 to clear Aggregate's Selection Dataset                        
:eol.                                                                           
:h3.DR51 exec                                                                   
:ol.Read the log and list the dataset locations/characteristics                 
:li.Shuts off TSO messages                                                      
:li.Allocate and read the activity log                                          
:li.Check to Insure Activity Log is from VERIFY Function                        
:li....Exits EXEC if problem found                                              
:li.Parses for Starting and Ending messages of INC/EXC stmts                    
:li.Between starting and ending messages, parse for dataset names               
:li.Issue LISTCAT command with dataset name                                     
:li.Call DR151 to see if dataset is ARCIVE'd                                    
:li.If not ARCIVE'd, call INTDSN to interrogate the DSN Info                    
:li.Write DSN and Info to SYSOUT                                                
:eol.                                                                           
.pa                                                                             
:h3.DRSEO EXEC                                                                  
:p.Function is the same as DRSCAN but Datasets listed are Exception             
(exclusion) candidates only.                                                    
.fo off                                                                         
:h2.Ancillary JCL                                                               
:h3.DCOLLECT JCL                                                                
//IB996RVP JOB (800000),'HEGGEN IDCAMS  X6678',CLASS=R,MSGCLASS=U,              
//         NOTIFY=IB996RV                                                       
//*                                                                             
//STEP1 EXEC PGM=IDCAMS                                                         
//SYSPRINT DD SYSOUT=*                                                          
//SYSIN    DD *                                                                 
  DCOLLECT OUTDATASET(IB996RV.DCOLLECT.DATA) SMSDATA(ACTIVE) REPLACE            
/*                                                                              
:h3.HSMPATCH JCL                                                                
//IB996RVT JOB (800000),'HEGGEN IDCAMS  X6678',CLASS=R,MSGCLASS=U,              
//         NOTIFY=IB996RV                                                       
//IKJACCT EXEC PGM=IKJEFT01,DYNAMNBR=20                                         
//SYSHELP  DD  DSN=SYS1.HELP,DISP=SHR                                           
//SYSPRINT DD  DUMMY                                                            
//SYSTSPRT DD  SYSOUT=*                                                         
//SYSTERM  DD  SYSOUT=*                                                         
//SYSIN    DD  DUMMY,DCB=BLKSIZE=80                                             
//SYSTSIN  DD  *                                                                
    HSEND PATCH .ABRCB.+81 BITS(.....1..)                                       
//*                                                                             
:h2.Error Messages                                                              
:h3.DRBACKUP                                                                    
:ol.                                                                            
:LI.DRBACKUP: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                   
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know an EXECUTE          
will not work.  Message is generated by DRBACKUP exec.                          
:LI.DRBACKUP: 4 REQUIRED PARAMETERS NOT SUPPLIED                                
    DRBACKUP: need Aggregate Name, Tape Unit, Execute/Verify,                   
         and Input DSN (fully qualified)                                        
:p.Checked all four parameters to DRBACKUP for a null string and found          
at least one null string.  A space between parameters is required.              
A missing parameter to DRBACKUP will result in appearing that the               
last parameter is missing, two missing parameters will appear as                
the last two parameters are missing (and so on).  The execs have a              
positional orientation to their parameters.  Message is generated by            
DR11 exec.                                                                      
:LI.DRBACKUP: execver  MUST SPECIFY VERIFY OR EXECUTE'                          
:p.Checked the third parameter for correct spelling and it didn't               
pass.  Correct the spelling and resubmit.  Message is generated by              
DR11 exec.                                                                      
:LI.DRBACKUP: VALID INPUT DATASET REQUIRED                                      
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.  Message is generated by         
DR11 exec.                                                                      
:li.DRBACKUP: cannot allocate dcolldsn .  RC=rc                                 
:p.Attempted Allocation of DCOLLECT dataset and it failed.  Value of            
dcolldsn is what is specified in DR10.  RC is the return code from a            
TSO Allocate command.  Insure that the DCOLLECT JCL is using the same           
dataset for output that DR10 specifies.  Message is generated by                
DR12 exec.                                                                      
:li.DRBACKUP: Error reading dcolldsn .  RC=rc                                   
:p.Attempted first read of the DCOLLECT dataset and had a problem. Value        
of dcolldsn is what is specified in DR10.  RC is the return code from a         
REXX EXECIO command.  Insure that the DCOLLECT JCL is using the same            
dataset for output that DR10 specifies.  Insure the DCOLLECT JCL has            
executed (possible EOF on first read, if RC=2).  Message is generated           
by DR12 exec.                                                                   
:li.DRBACKUP: iagname AGGREGATE NOT FOUND IN DCOLLECT DSN dcoldsn               
:p.Read to end-of-file on DCOLLECT dataset and didn't match the                 
aggregate name on the DRBACKUP command to any in the DCOLLECT dataset.          
Possible problems are: DCOLLECT dataset records are not correct or              
current;  Aggregate Name is incorrect.  Insure the DCOLLECT JCL has             
executed. Message is generated by DR12 exec.                                    
:li.DRBACKUP: Selection Dataset and input dataset are the same                  
    DRBACKUP: Selection Dataset : oputctl                                       
    DRBACKUP:     Input Dataset : idsn                                          
:p.The dataset specified on the Input Parameter to DRBACKUP matches             
the Selection Dataset defined for the aggregate.  This error prevents           
the execs from over-writing the input dataset.   It is required that            
these datasets have different names, The EXECS will read from the INPUT         
DSN and write to the Selection DSN. Message is generated by DR13 exec.          
:li.DRBACKUP: Selection Dataset odsn ...msdsn                                   
:p.The exec has looked at the Catalog and Volume for the Selection              
DSN odsn, and found a problem.  The Nature of the problem is specified          
in the msdsn variable.  Message is generated by DR13 exec.                      
:LI.DRBACKUP: Allocation of Selection Dataset Unsuccessful oputctl              
:p.The exec has attempted allocation of the Selection Dataset (oputctl)         
with exclusive control many times.  Possible that someone or something          
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.  Message is generated by DR13 exec.                         
:li.DRBACKUP: Error allocating log dsn actlog .  RC=rc                          
Possible that someone or something has it allocated or that the                 
Automate/MVS Script has problems. Check the SYSLOG for messages                 
concerning this dataset                                                         
Message is generated by Readlog subroutine of the DR15 exec.                    
:li.DRBACKUP: Log not from ABACKUP VERIFY                                       
    DRBACKUP: Check Automated Operations, wrong log actlog                      
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
DRBACKUP prior to executing this exec), if not then the Automate/MVS            
scripts may have been pulled from the system.                                   
Message is generated by Readlog subroutine of the DR15 exec.                    
:li.DRBACKUP: Problem with agdsn why                                            
:p.The is the message produced when an DMS ARCIVE dataset is                    
encountered.  This is not an error.  Variable agdsn is the name of              
a dataset in the aggregate, and why is a string returned from the               
DR151 subroutine exec.                                                          
Message is generated by Readlog subroutine of the DR15 exec.                    
writeinc:                                                                       
:li.DRBACKUP: Candidate Datasets for backup: smc1                               
:p.This message displays a count of the datasets included as a result           
of the INPUT dataset used for a ABACKUP ...Verify.   SMC1 is                    
the total datasets prior to looking for ARCIVE'd datasets                       
Message is generated by Writeinc subroutine of the DR15 exec.                   
:li.DRBACKUP: Arcive'd Datasets Excluded: smc2                                  
:p.This message displays a count of the datasets excluded because they          
were archived (SMC2).                                                           
Message is generated by Writeinc subroutine of the DR15 exec.                   
:li.DRBACKUP: Datasets Included: smc3                                           
:p.This message displays a count of the datasets included after the             
archived datasets are removed (SMC3).  SMC1 = SMC2 + SMC3                       
Message is generated by Writeinc subroutine of the DR15 exec.                   
:li.DRBACKUP: All datasets in aggregate have been eliminated                    
:p.This message stops DRBACKUP because the aggregate has no datasets            
to be included for backup (ABARS must have at least one include stmt).          
Message is generated by Writeinc subroutine of the DR15 exec.                   
:li.DRBACKUP: Reset of selection dataset unsuccessful output                    
:p.Output is the name of the selection dataset.  This message indicates         
that it couldn't allocate the selection with exclusive control to clear         
it.  Clearing the selection dataset prevents the ABACKUP command from           
accidentally using an old include list generated by DRBACKUP. Check the         
SYSLOG for messages concerning another user/job having the selection            
dataset allocated.                                                              
Message is generated by the DR16 exec.                                          
:eol.                                                                           
:h3.ABARPOST                                                                    
:ol.                                                                            
:li.ABARPOST: no ABACKUP logs available for aggregate iagname                   
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
The ABACKUP activity log name is null.  Possible that this command was          
issued prior to DRBACKUP execution.                                             
Message is generated by the DR21 exec.                                          
:li.ABARPOST:' arparms ...mdsn                                                  
    ARECOVER parms not written for iagname                                      
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
ARPARMS is the ARECOVER Parms dataset specified in DR10.  MDSN is text          
describing the problem after checking the Catalog and Volume for the            
dataset.                                                                        
Message is generated by the DR21 exec.                                          
:eol.                                                                           
:h3.ARECPROC                                                                    
:ol.                                                                            
:li.ARECPROC: no ARECOVER Parms Dataset for aggregate iagname                   
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
ARPARMS is the ARECOVER Parms dataset specified in DR10.  MDSN is text          
describing the problem after checking the Catalog and Volume for the            
dataset.                                                                        
Message is generated by the DR31 exec.                                          
:li.ARECPROC: Check Syslog; Contention for parms DSN ardsn                      
:p.The exec has attempted allocation of the PARMS Dataset (ardsn)               
with shared control many times.  Possible that someone or something             
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.  Message is generated by DR31 exec.                         
:li.ARECPROC: no ARECOVER logs available for aggregate iagname                  
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
The ARECOVER activity log name is null.  Possible that the ARC6030I             
message wasn't trapped at the recovery site.  Insure that the                   
Automate/MVS script is active/working.                                          
Message is generated by the DR32 exec.                                          
:li.ARECPROC: Mod to Log of Logs Dataset unsuccessful loglog                    
:p.The exec has attempted allocation of the LOG-of-Logs Dataset (loglog)        
with Disp=mod many times.  Possible that someone or something                   
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
Message is generated by the DR32 exec.                                          
:eol                                                                            
:h3.DRAUDIT                                                                     
:ol                                                                             
:LI.DRAUDIT: Allocation of LOGS dataset unsuccessful' loglog                    
:p.The exec has attempted allocation of the LOG-of-Logs Dataset (loglog)        
with Disp=mod many times.  Possible that someone or something                   
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
Message is generated by the DR41 Exec (called by araudit, called by             
:li.DRAUDIT: No ARECOVER Parms Dataset for Aggregate iagname                    
:p.IAGNAME is the input aggregate name.                                         
Check the ARECOVER Parms dataset in DR10 to insure it's not null.               
Message is generated by the DR41 Exec (called by ARAUDIT  called by             
DRAUDIT).                                                                       
:eol.                                                                           
:h3.DRSCAN:                                                                     
:ol.                                                                            
:LI.DRSCAN: INPUT DATASET input ...MSDSN                                        
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.  Message is generated by         
DRSCAN exec.                                                                    
:LI.DRSCAN: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                     
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know the Activity        
log has no datasets in it.  Message is generated by DRSCAN exec.                
:LI.DRSCAN: ERROR ALLOCATING LOG DSN actlog .  RC=rc                            
:p.The exec has attempted allocation of the Log Dataset (actlog).               
Possible that someone or something has it allocated or that the                 
Automate/MVS Script has problems. Check the SYSLOG for messages                 
concerning this dataset                                                         
Message is generated by DR61 exec.                                              
:LI.DRSCAN: LOG NOT FROM ABACKUP VERIFY' LOGDSN                                 
    DRSCAN: CHECK AUTOMATED OPERATIONS, WRONG LOG actlog                        
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
by DRSCAN prior to executing this exec), if not then the Automate/MVS           
scripts may have been pulled from the system.                                   
Message is generated by DR51 exec.                                              
:eol                                                                            
:h3.DRSEO:                                                                      
:ol                                                                             
:LI.DRSEO: INPUT DATASET input ...msdsn                                         
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.  Message is generated by         
DRSEO exec.                                                                     
:LI.DRSEO: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                      
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know the Activity        
log has no datasets in it.  Message is generated by DRSEO exec.                 
:LI.DRSEO: ERROR ALLOCATING LOG DSN actlog .  RC=rc                             
:p.The exec has attempted allocation of the Log Dataset (actlog).               
Possible that someone or something has it allocated or that the                 
Automate/MVS Script has problems. Check the SYSLOG for messages                 
concerning this dataset                                                         
Message is generated by DR61 exec.                                              
:LI.DRSEO: LOG NOT FROM ABACKUP VERIFY LOGDSN                                   
    DRSEO: CHECK AUTOMATED OPERATIONS, WRONG LOG actlog                         
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
by DRSEO prior to executing this exec), if not then the Automate                
scripts may have been pulled from the system.                                   
Message is generated by DR61 exec.                                              
:eol                                                                            
:appendix                                                                       
:h1.Automation Processing for ARC6030I Message                                  
:p.The following describes sample automation for processing for matching        
the Aggregate name to the Log Dataset using NETVIEW Automation.                 
.sp 1                                                                           
:p. Provided by Donald Foster, IBM ISSC San Jose                                
:h2.Installation                                                                
:p.Installing this function requires changes to:                                
:ol                                                                             
:li.The MPF list (possibly)                                                     
:li.The NETVIEW Message Automation Table                                        
:li.The NETVIEW Clist data set.                                                 
:eol                                                                            
:p.In addition, a data set needs to be pre-allocated to contain                 
the results of the automation processing.                                       
:h3.MFP list                                                                    
:p.Check your MFP list to be sure that message ARC6030I is available            
for automation.                                                                 
:h3.NETVIEW Message Table                                                       
:p.Add an entry similar to the following                                        
to the appropriate section of your                                              
message table.  The ARC6030I message is NOT a multi-line message                
and is processed several times before all the data is collected.                
Therefore, the message table                                                    
entry must ROUTE the processing to a SPECIFIC                                   
autotask, as data is accumulated in a Global Task Variable.                     
.fo off                                                                         
.sp                                                                             
   IF MSGID='ARC6030I'                                                          
   THEN EXEC(CMD('ABARMSG ') ROUTE(ONE AUTO1))                                  
   BEEP(N) DISPLAY(Y) HCYLOG(N) HOLD(N) SYSLOG(N) NETLOG(Y);                    
.sp                                                                             
.fo on                                                                          
:h3.CLIST Installation                                                          
:p.The CLIST named ABARMSG must be installed in a dataset listed                
in the DSICLD DD card in the NETVIEW Proc.                                      
If you change the name of the CLIST, the Message Automation Table               
entry must change also.                                                         
:h3.Data Set Allocation                                                         
:p.Allocate a data set to contain the results of automation processing.         
By default this dataset has the name 'NETVIEW.ABARDATA'.  To change             
the name of the dataset, edit                                                   
the CLIST ABARMSG and change the OUTDSN variable.  The name of the              
started task that NETVIEW runs under, must have RACF update access              
to this dataset.  You will need to issue the SETROPTS RACF command,             
after you issue the appropriate PERMIT commands,                                
if you do not want to completely restart NETVIEW.                               
This data set must be a pre-allocated PDS.                                      
Also update DR14NV in the ABARS REXX Utilities, then copy this member           
to DR14 for the utility's use.                                                  
:h2.ABARMSG Clist                                                               
:xmp                                                                            
/**********************************************************************/        
/* Description:  This NETVIEW Clist processes message ARC6030I.       */        
/*               It allows the Aggregate Group name to be matched     */        
/*               to the associate Log data set.                   @XRC*/        
/*                                                                    */        
/* Processing:  When an ARC6030I message is received for backup       */        
/*              ('AGGREGATE GROUP' in text of message), a member      */        
/*              is created in the output dataset containing the       */        
/*              dataset name of the ACTIVITY LOG.  The name of        */        
/*              the member is the aggregate group name specified      */        
/*              in the message text.                                  */        
/*                                                                    */        
/*              When an ARC6030I message is received for recovery     */        
/*              ('CONTROL FILE' in text of message), a member         */        
/*              is created in the output dataset containing the       */        
/*              dataset name of the ACTIVITY LOG.  The name of        */        
/*              the member is the aggregate group name (as found      */        
/*              in the data set name (3rd qualifier from the end).    */        
/*                                                                    */        
/* Input:                                                             */        
/*       Backup Message:                                              */        
/*         ARC6030I ACTIVITY LOG FOR AGGREGATE GROUP DAVETEST WILL BE */        
/*         ARC6030I (CONT.) ROUTED TO                                 */        
/*         ARC6030I (CONT.) HSMACT.HD.ABACKUP.DAVETEST.D95082.T113550 */        
/*                                                                    */        
/*       Recovery Message:                                            */        
/*         ARC6030I ACTIVITY LOG FOR CONTROL FILE DATA SET            */        
/*         ARC6030I (CONT.) DR.C.C01V0001 WILL BE ROUTED TO           */        
/*         ARC6030I (CONT.) HSMACT.HD.ARECOVER.DAVETEST.D95083.T135552*/        
/*                                                                    */        
/* Output:                                                            */        
/*       The data set where the members are created is specified      */        
/*       in the variable OUTDSN.  Change this for your installation.  */        
/*                                                                    */        
/*       An entry is made into the NETVIEW Log indicating what        */        
/*       processing has taken place.                              @XRC*/        
/*                                                                    */        
/**********************************************************************/        
/* Created by Donald H. Foster 4/17/95                                */        
/**********************************************************************/        
/*                                                                    */        
/* Process the message.  The ARC6030I message is not a multiline      */        
/* message.  Therefore as the parts of the message are received,      */        
/* they are kept is a global task variable until the last part of     */        
/* the message is received.                                       @ZRC*/        
/*                                                                    */        
/*====================================================================*/        
/**********************************************************************/        
/* Modify this variable to contain the fully qualified DSN for        */        
/*        your installation.                                          */        
/**********************************************************************/        
OUTDSN = 'NETVIEW.ABARDATA'         /* PDS to create members in       */        
/**********************************************************************/        
/*====================================================================*/        
Parse Source . . CLISTname .        /*    get name of CLIST as called */        
Address NETVASIS                    /* support upper and lower case   */        
'GETMLINE INARG 1 '                 /* get the message                */        
Src = RC                                                                        
If INARG = '' | Src^=0 Then ,                                                   
   Do;                                                                          
     'MSG LOG' CLISTname 'error process input data. GETMLINE RC='Src,           
         ' or message was null: -'Inarg'-'                                      
     End                                                                        
  Else                                                                          
     Call MsgTest                   /* go process message if 6030 msg */        
Exit                                                                            
/**********************************************************************/        
/*                                                                    */        
/*  If this is a 6030 message process it, else note error in log      */        
/*                                                                    */        
/**********************************************************************/        
MsgTest:                                                                        
Parse upper var INARG MsgID MsgText                                             
If MsgID = 'ARC6030I' Then Call ParseMsg                                        
  Else                                                                          
    'MSG LOG' CLISTname 'received unexpected MSGID:' MsgID                      
Return                                                                          
/**********************************************************************/        
/*                                                                    */        
/*  Piece the message together.                                       */        
/*                                                                    */        
/* -A new message is detected if first word is 'ACTIVITY'             */        
/* -The last part of the message is detected if the data set name     */        
/*  is found in the message i.e. there is a character string with     */        
/*  more that 14 characters following the 'ROUTED TO' string.         */        
/*  The last part of the dsn is always Dxxxxx.Txxxxxx (14 chars)      */        
/*                                                                    */        
/**********************************************************************/        
ParseMsg:                                                                       
Parse var MsgText TestWord MsgRest                                              
If TestWord = 'ACTIVITY' Then SavedMsg = TestWord  /* save beginning  */        
  Else Call GetSavedMsg                       /* go get prior parts   */        
SavedMsg = SavedMsg||' '||MsgRest             /* reconstruct whole msg*/        
Parse var SavedMsg . 'ROUTED TO' Logfile    /* DSN follows 'ROUTED TO'*/        
Parse Var Logfile Logfile .                 /* isolate DSN            */        
If Length(Logfile) > 14 Then Call MsgDone   /* have complete message  */        
  Else                                                                          
    Call SaveMsg                            /* go save this much      */        
Return                                                                          
/**********************************************************************/        
/*                                                                    */        
/* Message reconstruction is complete.  So save the DSN in            */        
/* the appropriate member.                                            */        
/*  Backup: member name follows 'GROUP'  .... DAVETEST                */        
/*         ARC6030I ACTIVITY LOG FOR AGGREGATE GROUP DAVETEST WILL BE */        
/*  Recovery: member name is 3rs from last DSN qualifier ... DAVETEST */        
/*         ARC6030I (CONT.) HSMACT.HD.ARECOVER.DAVETEST.D95083.T135552*/        
/*                                                                    */        
/**********************************************************************/        
MsgDone:                                                                        
Parse Var SavedMsg . 'LOG FOR' type .                                           
If type = 'AGGREGATE' Then                                                      
   Parse Var SavedMsg . 'GROUP' MemberName .                                    
 Else                                                                           
   Do; LogWord = Translate(Logfile,' ','.') /* remove periods from DSN*/        
       WordCnt = Words(LogWord)             /* get count of qualifiers*/        
       MemberName = Word(LogWord,WordCnt-2) /* yes, its this one      */        
       End                                                                      
"ALLOC F(ABARDATA) DA('"OUTDSN"("MemberName")') SHR FREE"                       
Src = Rc                                                                        
If Src ^= 0 Then                                                                
   Do;                                                                          
     'MSG LOG' CLISTname 'ALLOCATE ERROR for 'OUTDSN' RC='Src                   
     End                                                                        
OutRec.0 = 1                                                                    
OutRec.1 = Logfile                                                              
ADDRESS MVS 'EXECIO 1 DISKW ABARDATA (FINIS STEM OUTREC.'                       
Src = RC                                                                        
If Src ^= 0 Then                                                                
   Do;                                                                          
     'MSG LOG' CLISTname 'EXECIO error RC='Src' while processing' OUTDSN        
     End                                                                        
'MSG LOG' CLISTname 'DSN:'OUTDSN 'Member:'MemberName' contains:'LogFile         
Return                                                                          
/**********************************************************************/        
/*                                                                    */        
/* Get the previous message text from Task Global: ABAR6030           */        
/*                                                                    */        
/**********************************************************************/        
GetSavedMsg:                                                                    
'GLOBALV GETT ABAR6030'            /* get previously saved test       */        
Src = RC                                                                        
If Src ^= 0 Then                                                                
   Do;                                                                          
     'MSG LOG' CLISTname 'GLOBALV GETT error RC='Src' while processing',        
     Inarg                                                                      
     End                                                                        
SavedMsg = Value('ABAR6030')                                                    
Return                                                                          
/**********************************************************************/        
/*                                                                    */        
/* Save the text so far in Task Global: ABAR6030                      */        
/*                                                                    */        
/**********************************************************************/        
SaveMsg:                                                                        
ABAR6030 = SavedMsg                                                             
'GLOBALV PUTT' 'ABAR6030'          /* get previously saved test       */        
Src = RC                                                                        
If Src ^= 0 Then                                                                
  Do;                                                                           
    'MSG LOG' CLISTname 'GLOBALV PUTT error RC='Src' while processing',         
    Inarg                                                                       
    End                                                                         
Return                                                                          
:exmp                                                                           
:backm.                                                                         
:egdoc.                                                                         
$$                                                                              
//HSMSTEP8 EXEC PGM=IEBUPDTE,PARM=NEW                                           
//SYSPRINT DD SYSOUT=*                                                          
//SYSUT2   DD DSN=HSM.ABARUTIL.DOCS,                                            
//            DISP=OLD                                                          
//SYSIN    DD DATA,DLM='$$'                                                     
./ ADD NAME=ABARUG                                                              
.cm  gdoc sec='unclassified'                                                    
:GDOC SEC='(C)COPYRIGHT INTERNATIONAL BUSINESS MACHINES CORPORATION 1994        
.cm  qprint dcf options 'twopass cont prof(dsmprof3'                            
:frontm.                                                                        
:titlep.                                                                        
:title.ABARS REXX Utilities                                                     
:title.Users Guide                                                              
:address.                                                                       
:aline.D. L. Heggen                                                             
:aline.214 280-5432                                                             
:aline.Tie 542-5432                                                             
:eaddress.                                                                      
:address.                                                                       
:aline.IBM Corporation                                                          
:aline.Department 1MJD                                                          
:aline.1605 LBJ Freeway                                                         
:aline.Dallas, Texas  75234                                                     
:eaddress.                                                                      
:date.February 7th, 1994                                                        
:etitlep.                                                                       
.ll 4i                                                                          
:toc.                                                                           
.ll 6i                                                                          
:body                                                                           
:h2.Introduction                                                                
:p.ABARS stands for Aggregate Backup and Recovery System.  It is an             
extension of IBM's DFHSM product and allows for the backup (and in the          
case of a disaster) the recovery of an application's data.  It creates          
a transportable logical (as opposed to physical) copy of the                    
application's data.  The use of logical copies allows for the data              
to be restored on a different device type than it originated.  This             
simplifies recovery, because the Recovery Site need only supply the             
required storage capacity for the application, not a specific                   
configuration.                                                                  
:p.ABARS provides an excellent transport vehicle for datasets to a              
Disaster/Recovery Site.  All data in an Abars Aggregate is self                 
describing and can be restored to any supported configuration.  ABARS           
will create copies of DASD, Tape, and Migrated Datasets for critical            
Business Application Recovery. An ABARS Aggregate definition is a               
collection of datasets comprising a Critical Business Function.  The            
Customers that use ABARS for Disaster/Recovery typically define an              
aggregate to a set of data that can be processed in 30-45 minutes.              
If the business application's datasets exceed this definition, then             
multiple Aggregates are defined for the application.  This can lead to          
more Aggregates than can be effectively tracked manually.  These                
utilities extend ABARS capability by providing the ability to track             
and control the execution of hundreds of ABARS aggregates defined for           
critical Business Application Recovery.                                         
:h3.Function                                                                    
:p.These Utilities will:                                                        
:ol.                                                                            
:li.Aid the development of an Aggregate definition                              
:li.Extend Dataset filter selection capability beyond Dataset Name              
:li.Associate the activity log to an ABARS Execution                            
:li.Provide Report of dataset detail for an ABARS aggregate                     
:li.Create the ARECOVER command as a result of the ABACKUP Process              
for transmission to recovery site                                               
:li.Allow for Submission, Tracking and Reporting of Aggregates by a             
Job Scheduling Product (i.e. OPC/ESA, CA7, etc.)                                
:li.Restore selected datasets from a successful ABACKUP execution               
:li.Restore an Aggregate with the user specifying only the aggregate            
name.                                                                           
:li.Allow Aggregate Restoration to be independent of ABARS Release at           
Recovery site                                                                   
:li.Audit this process at any point in time to assess degree of                 
completeness.                                                                   
:eol.                                                                           
:h3 Design                                                                      
:p.These ABARS Utilities are designed to:                                       
:ol.                                                                            
:li.Simplify the ABACKUP/ARECOVER process for Applications and Storage          
Administrators                                                                  
:li.Use external interfaces only                                                
:li.Allow for easy maintenance/modification                                     
:eol.                                                                           
.sp                                                                             
:p.These ABARS Utilities use:                                                   
:ol.                                                                            
:li.an Automated Operations type product (NETVIEW, Automate, etc. )             
:li.REXX Execs                                                                  
:li.Assembler TSO Command (optional, for Wait function)                         
:li.DFHSM or DFSMShsm is required                                               
:eol.                                                                           
:h3.The Command Functions                                                       
:ol.                                                                            
:li.DRSCAN (and/or DRSEO) to list location of datasets                          
contained in an Aggregate                                                       
:li.DRBACKUP to eliminate 'ARCIVE' data (Optional)                              
:li.ABARPOST to copy the activity log to sysout, code the ARECOVER              
command, and create the DSN DETAIL Report                                       
:li.ARECPROC to process the arecover commands from ABARPOST and                 
copy the ARECOVER Activity Log to Sysout                                        
:li.DRAUDIT to audit the aggregate(s) progress at the recovery site             
:li.ARECSNGL for selected dataset restore from ABACKUP tapes                    
:eol.                                                                           
.pa                                                                             
:h2.JCL, Commands,and Parameters                                                
.fo off                                                                         
:h3.DRSCAN JCL                                                                  
//jobname  JOB .................                                                
//DRSCAN PROC                                                                   
//AUDIT    EXEC PGM=IKJEFT01,DYNAMNBR=20                                        
//SYSEXEC   DD  DSN=IB996RV.ABARS.EXECS,DISP=SHR                                
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//DRSCAN   PEND                                                                 
//STEP1  EXEC DRSCAN                                                            
//DRSCAN.SYSTSIN DD  *                                                          
    %DRSCAN  aggname UNIT(tape) EXECUTE +                                       
               INPUT('input dsn')                                               
    %DRSEO  aggname UNIT(tape) EXECUTE                                          
.fo on                                                                          
:h3.DRSCAN/DRSEO Discussion                                                     
:p.Syntactically, the DRSCAN command is the same as DRBACKUP or ABACKUP         
commands (that is; the INPUT parameter is optional).  This is designed          
to minimize the changes needed as a new aggregate flows from design             
to production usage.  As shown, multiple executions of the                      
command may be used in a single step.  Also in the example, the first           
execution is for a aggregate that will use DRBACKUP, the second is for          
an aggregate that will use ABACKUP.                                             
We execute the front end of a DRBACKUP (if the                                  
input dataset is supplied). and issue an ABACKUP VERIFY command.                
The ABACKUP Activity Log is then allocated and each dataset is                  
interrogated for its location.  This information is used to create              
the report.  The difference between DRSCAN and DRSEO is the DRSCAN              
lists the location of all datasets in the aggregate, DRSEO lists                
what we think may be candidates for exclusion from the aggregate.               
DRSEO is a variation of DRSCAN to provide a list of datasets that               
are likely candidates for exclusion.                                            
.pa                                                                             
:h3.DRBACKUP JCL                                                                
.fo off                                                                         
//jobname  JOB .................                                                
//aggname EXEC DRBACKUP                                                         
//ABACKUP.SYSTSIN DD  *                                                         
    %DRBACKUP  aggname UNIT(tape) EXECUTE +                                     
               INPUT('input dsn')                                               
//ABARPOST.SYSTSIN DD  *                                                        
    %ABARPOST  aggname UNIT(tape)                                               
.sp                                                                             
//jobname  JOB .................                                                
//aggname EXEC DRBACKUP                                                         
//ABACKUP.SYSTSIN DD  *                                                         
    HSEND WAIT ABACKUP aggname UNIT(tape) EXECUTE                               
//ABARPOST.SYSTSIN DD  *                                                        
    %ABARPOST  aggname UNIT(tape)                                               
:h3.DRBACKUP JCL PROC                                                           
//DRBACKUP PROC                                                                 
//******   ABARS ABACKUP PRE PROCESSOR IF %DRBACKUP IS USED:                    
//******    1) ELIMINATES 'ARCIVE' DATASETS FROM AGGREGATE                      
//******    2) SET UP ENVIRONMENT FOR POST PROCESSING                           
//ABACKUP  EXEC PGM=IKJEFT01,DYNAMNBR=20,TIME=1440                              
//SYSPROC   DD  DSN=SYS3.FISCO.ISPCLIB,DISP=SHR                                 
//SYSEXEC   DD  DSN=DSM.D.REXX.EXECS,DISP=SHR                                   
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//******   ABARS POST PROCESSOR                                                 
//******    1) WRITES ACTIVITY LOG TO DDNAME 'LOG'                              
//******       IF ABACKUP IS GOOD.....                                          
//******    2) WRITES ARECOVER STATEMENTS TO ARECOVER PARMS DATASET             
//******    3) CREATES DATASET ATTRIBUTE DETAIL REPORT                          
//ABARPOST EXEC PGM=IKJEFT01,DYNAMNBR=20                                        
//SYSPROC   DD  DSN=SYS3.FISCO.ISPCLIB,DISP=SHR                                 
//SYSEXEC   DD  DSN=DSM.D.REXX.EXECS,DISP=SHR                                   
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//******   ABENDBK - ISSUE U0100 ABEND CODE IF ABACKUP  STEP ISSUES             
//******   A RETURN CODE NOT EQUAL TO 0                                         
//ABENDBK EXEC PGM=GPABEND,COND=(0,EQ,ABACKUP)                                  
//SYSOUT  DD SYSOUT=*                                                           
.fo on                                                                          
:h3.DRBACKUP Discussion                                                         
:p.The DRBACKUP JCL Proc supports both ABACKUP commands and DRBACKUP            
commands.  Although only one command is allowed to be present per               
execution. The ABACKUP command should already be familiar.  The only            
additional parameter needed for DRBACKUP is an Input File (fully                
qualified).  This is needed to copy and modify the dataset list                 
the selection statements generate.  Moving an aggregate to or from              
DRBACKUP command requires a change in the aggregate structure.  Do              
not change between ABACKUP and DRBACKUP commands                                
without getting the Aggregate altered by Storage Administration.                
:p.The ABARPOST command needs both the Aggregate Name and Tape Unit             
specified as parameters.  The necessity of the tape unit is because             
APARPOST will code the ARECOVER command for use at the recovery site.           
We didn't want to make DRBACKUP command a requirement (that if the              
aggregate didn't have ARCIVE data or needed the ARCIVE data,                    
ABACKUP command is appropriate to use), and without access to the               
tape unit specified to the ABACKUP command, it needs to be specified for        
the ABARPOST command.                                                           
:p.The order of the steps provided in the DRBACKUP JCL Procedure is             
important.  The ABACKUP step (if no problems are found) will end                
with the return code of a ABACKUP command.  If this is non-zero                 
the ABENDBK step will flag the aggregate backup as a problem to                 
the Job Scheduling Product.                                                     
ABARPOST executes before ABENDBK to at least dump the ABACKUP                   
Activity Log to SYSOUT.  If the return code from the ABACKUP step is            
zero, ABARPOST will also create the ARECOVER command and provide the DSN        
Detail Report.                                                                  
.pa                                                                             
.fo off                                                                         
:h3.DRECOVER JCL                                                                
//jobname  JOB .................                                                
//aggname EXEC DRECOVER                                                         
//DRECOVER.SYSTSIN DD  *                                                        
    %ARECPROC aggname                                                           
:h3.DRECOVER JCL PROC                                                           
//DRECOVER PROC                                                                 
//******   ABARS ARECOVER                                                       
//ARECOVER EXEC PGM=IKJEFT01,DYNAMNBR=20,TIME=1440                              
//SYSPROC   DD  DSN=SYS3.FISCO.ISPCLIB,DISP=SHR                                 
//SYSEXEC   DD  DSN=DSM.D.REXX.EXECS,DISP=SHR                                   
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//LOG       DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//******   ABENDBK - ISSUE U0100 ABEND CODE IF ARECOVER STEP ISSUES             
//******   A RETURN CODE NOT EQUAL TO 0                                         
//ABENDBK EXEC PGM=GPABEND,COND=(0,EQ,ARECOVER)                                 
.fo on                                                                          
:h3.DRECOVER Discussion                                                         
:p.The only input parameter needed for the ARECPROC command is the              
aggregate name.  This is used as the member name when accessing the             
ARECOVER.PARMS dataset.  In this dataset the ARECOVER command is coded          
as a result of a successful DRBACKUP execution.  This member is read,           
and the environment is checked in the Recovery Site for the release             
of DFHSM available.  The ARECOVER command is issued by the ARECPROC             
command (syntactically   correct for the release of DFHSM found at the          
recovery site).                                                                 
:p.A 'fall back' position is available, by executing                            
the TSO Terminal Monitor Program in Batch and pointing the SYSTSIN              
DD Card to the ARECOVER.PARMS dataset with the aggregate name specified         
as the member name.                                                             
:p.Worse Case, the ABARS tape(s) could be read by DFDSS for Dataset             
restoration outside the context of ABARS.                                       
.pa                                                                             
:h3.DRAUDIT JCL                                                                 
.fo off                                                                         
//jobname  JOB .................                                                
//AUDIT PROC                                                                    
//DRAUDIT  EXEC PGM=IKJEFT01,DYNAMNBR=20,PARM='%DRAUDIT'                        
//SYSEXEC   DD  DSN=IB996RV.ABARS.EXECS,DISP=SHR                                
//SYSHELP   DD  DSN=SYS1.HELP,DISP=SHR                                          
//SYSPRINT  DD  DUMMY                                                           
//SYSTSPRT  DD  SYSOUT=*                                                        
//SYSTERM   DD  SYSOUT=*                                                        
//AGDET     DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//AGSUMM    DD  SYSOUT=*,RECFM=FBA,LRECL=133                                    
//SYSIN     DD  DUMMY,DCB=BLKSIZE=80                                            
//SYSTSIN   DD  DUMMY                                                           
//AUDIT    PEND                                                                 
//STEP1  EXEC AUDIT                                                             
//AUDIT.INCNTL DD  *                                                            
aggname 1                                                                       
        .                                                                       
        .                                                                       
        .                                                                       
aggname n                                                                       
.fo on                                                                          
:h3.DRAUDIT Discussion                                                          
:p.Input is a list of aggregates following the INCNTL DD card.  ARECPROC        
keeps track of the ARECOVER commands/Activity Logs for each aggregate           
through a dataset it allocates and uses (DISP=NEW the first time,               
DISP=MOD for each subsequent execution). The Audit can be run any time          
and creates two different reports, a detail and a summary.                      
:p.The Detail Report lists an aggregate, the logs ARECOVER has created          
and (by counting the number of log datasets) the number of times                
ARECOVER has executed for this aggregate.  Following this information           
is a report of the datasets in the aggregate with errors.  Errors are           
detected via the REXX LISTDSI function.  That is to say, we can test            
existence of the dataset from the aggregate at the recovery site,               
but until applications start and access the data, the content                   
of the dataset can't be tested.                                                 
:p.The Summary Report lists an aggregate name, the number of datasets,          
and the number of errors found. The Last Line lists the total number            
of aggregates (requested for this audit), the total number of datasets,         
and the total number of errors.  The quick scan for this report starts          
at the bottom right edge (total errors).  If zero, look no further.             
If not zero, scan the right column on the report.  This will locate             
the aggregates with problems.  If the number of datasets and the                
number of errors are approximately the same, assume the ARECOVER for            
the aggregate hasn't completed yet.                                             
.pa                                                                             
:h3.ARECSNGL JCL                                                                
.fo off                                                                         
//jobname  JOB .................                                                
//aggname EXEC DRECOVER                                                         
//DRECOVER.SYSTSIN DD  *                                                        
    %ARECSNGL aggname                                                           
//DRECOVER.INDSN   DD  *                                                        
dsn1                                                                            
dsn*                                                                            
dsnN                                                                            
.fo on                                                                          
:h3.ARECSNGL Discussion                                                         
:p.The only input parameter needed for the ARECSNGL command is the              
aggregate name.  This is used as the member name when accessing the             
ARECOVER.PARMS dataset.  In this dataset the ARECOVER command is coded          
as a result of a successful DRBACKUP execution.  This member is read,           
and the environment is checked for the release of DFHSM available.              
Additionally, a list of datasets in the aggregate that need selective           
restore are supplied via the INDSN JCL DD Card. Input is expected to            
one line per dataset.  Also a simplistic filter capability has been             
enabled, use of an "*" on the right of the datasetname will allow a             
match on all preceding characters.                                              
:p.Up to 2 copies of the aggregate are supported, with the first copy           
expected to go offsite and the second copy expected to remain onsite.           
Multiple versions can be supported, if the member in the ARECOVER.PARMS         
dataset is replaced with a valid member from a previous ABACKUP                 
execution.  Otherwise the most recent ABACKUP execution's version of the        
dataset will be restored.                                                       
.pa                                                                             
:h2.Error Messages                                                              
:h3.DRBACKUP                                                                    
:ol.                                                                            
:LI.DRBACKUP: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                   
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know an EXECUTE          
will not work.                                                                  
:LI.DRBACKUP: 4 REQUIRED PARAMETERS NOT SUPPLIED                                
    DRBACKUP: need Aggregate Name, Tape Unit, Execute/Verify,                   
         and Input DSN (fully qualified)                                        
:p.Checked all four parameters to DRBACKUP for a null string and found          
at least one null string.  A space between parameters is required.              
A missing parameter to DRBACKUP will result in appearing that the               
last parameter is missing, two missing parameters will appear as                
the last two parameters are missing (and so on).  The execs have a              
positional orientation to their parameters.                                     
:LI.'DRBACKUP:' EXECVER ' MUST SPECIFY VERIFY OR EXECUTE'                       
:p.Checked the third parameter for correct spelling and it didn't               
pass.  Correct the spelling and resubmit.                                       
:LI.DRBACKUP: VALID INPUT DATASET REQUIRED                                      
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.                                  
:li.DRBACKUP: Error reading dcolldsn .  RC=rc                                   
:p.Attempted first read of the DCOLLECT dataset and had a problem. Value        
of dcolldsn is what is specified in DR10.  RC is the return code from a         
REXX EXECIO command.  Insure that the DCOLLECT JCL is using the same            
dataset for output that DR10 specifies.  Insure the DCOLLECT JCL has            
executed (possible EOF on first read, if RC=2).  Probable problem with          
the utility support files, contact your support.                                
:li.DRBACKUP: iagname AGGREGATE NOT FOUND IN DCOLLECT DSN dcoldsn               
:p.Read to end-of-file on DCOLLECT dataset and didn't match the                 
aggregate name on the DRBACKUP command to any in the DCOLLECT dataset.          
Possible problems are: DCOLLECT dataset records are not correct or              
current;  Aggregate Name is incorrect.  Insure the DCOLLECT JCL has             
executed or that the Aggregate Name is spelled correctly.                       
:li.DRBACKUP: Selection Dataset and input dataset are the same                  
    DRBACKUP: Selection Dataset : oputctl                                       
    DRBACKUP:     Input Dataset : idsn                                          
:p.The dataset specified on the Input Parameter to DRBACKUP matches             
the Selection Dataset defined for the aggregate.  This error prevents           
the execs from over-writing the input dataset.   It is required that            
these datasets have different names, The EXECS will read from the INPUT         
DSN and write to the Selection DSN.                                             
:li.DRBACKUP: Selection Dataset odsn ...msdsn                                   
:p.The exec has looked at the Catalog and Volume for the Selection              
DSN odsn, and found a problem.  The Nature of the problem is specified          
in the msdsn variable.                                                          
:LI.DRBACKUP: Allocation of Selection Dataset Unsuccessful oputctl              
:p.The exec has attempted allocation of the Selection Dataset (oputctl)         
with exclusive control many times.  Possible that someone or something          
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
:li.DRBACKUP: Log not from ABACKUP VERIFY                                       
    DRBACKUP: Check Automated Operations, wrong log actlog                      
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
by DRBACKUP prior to executing this exec), if not then the Console              
Automation scripts have been pulled from the system.                            
:li.DRBACKUP: Problem with agdsn why                                            
:p.The is the message produced when an DMS ARCIVE dataset is                    
encountered.  This is not an error.  Variable agdsn is the name of              
a dataset in the aggregate, and why is a string returned from the               
DR151 subroutine exec.                                                          
:li.'DRBACKUP: Candidate Datasets for backup:' smc1                             
:p.This message displays a count of the datasets included as a result           
of the INPUT dataset used for a ABACKUP ...Verify.   SMC1 is                    
the total datasets prior to looking for ARCIVE'd datasets                       
:li."DRBACKUP: Arcive'd Datasets Excluded:" smc2                                
:p.This message displays a count of the datasets excluded because they          
were archived (SMC2).                                                           
:li."DRBACKUP: Datasets Included:" smc3                                         
:p.This message displays a count of the datasets included after the             
archived datasets are removed (SMC3).  SMC1 = SMC2 + SMC3                       
:li.DRBACKUP: All datasets in aggregate have been eliminated                    
:p.This message stops DRBACKUP because the aggregate has no datasets            
to be included for backup (ABARS must have at least one include stmt).          
Use DRSCAN with this aggregate to insure that there will be datasets            
to be backed up.                                                                
:eol.                                                                           
:h3.ABARPOST                                                                    
:ol.                                                                            
:li.ABARPOST: no ABACKUP logs available for aggregate iagname                   
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
The ABACKUP activity log name is null.  Possible that this command was          
issued prior to DRBACKUP execution.                                             
:eol.                                                                           
:h3.ARECPROC                                                                    
:ol.                                                                            
:li.ARECPROC: no ARECOVER Parms Dataset for aggregate iagname                   
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
ARPARMS is the ARECOVER Parms dataset specified in DR10.  MDSN is text          
describing the problem after checking the Catalog and Volume for the            
dataset.                                                                        
:li.ARECPROC: Check Syslog; Contention for parms DSN ardsn                      
:p.The exec has attempted allocation of the PARMS Dataset (ardsn)               
with shared control many times.  Possible that someone or something             
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
:li.ARECPROC: no ARECOVER logs available for aggregate iagname                  
:p.IAGNAME is the aggregate name supplied as a parameter to the command.        
The ARECOVER activity log name is null.  Possible that the ARC60360I            
message wasn't trapped at the recovery site.  Insure that the Console           
Automation script is active/working.                                            
:li.ARECPROC: Mod to Log of Logs Dataset unsuccessful loglog                    
:p.The exec has attempted allocation of the LOG-of-Logs Dataset (loglog)        
with Disp=mod many times.  Possible that someone or something                   
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
:eol                                                                            
:h3.DRAUDIT                                                                     
:ol                                                                             
:LI.DRAUDIT: Allocation of LOGS dataset unsuccessful' loglog                    
:p.The exec has attempted allocation of the LOG-of-Logs Dataset (loglog)        
with Disp=shr many times.  Possible that someone or something                   
else has it allocated.  Check the SYSLOG for messages concerning                
dataset contention.                                                             
:li.DRAUDIT: No ARECOVER Parms Dataset for Aggregate iagname                    
:p.IAGNAME is the input aggregate name.                                         
Check the ARECOVER Parms dataset in DR10 to insure it's not null.               
:eol.                                                                           
:h3.DRSCAN:                                                                     
:ol.                                                                            
:LI.DRSCAN: INPUT DATASET input ...MSDSN                                        
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.                                  
:LI.DRSCAN: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                     
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know the Activity        
log has no datasets in it. .                                                    
:LI.DRSCAN: ERROR ALLOCATING LOG DSN actlog .  RC=rc                            
:p.The exec has attempted allocation of the Log Dataset (actlog).               
Possible that someone or something has it allocated or that the Console         
Automation script has problems. Check the SYSLOG for messages                   
concerning this dataset                                                         
:LI.DRSCAN: LOG NOT FROM ABACKUP VERIFY' LOGDSN                                 
    DRSCAN: CHECK AUTOMATED OPERATIONS, WRONG LOG actlog                        
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
by DRSCAN prior to executing this exec), if not then the Console                
Automation scripts may have been pulled from the system.                        
:eol                                                                            
:h3.DRSEO:                                                                      
:ol                                                                             
:LI.DRSEO: INPUT DATASET input ...msdsn                                         
:p.Checked the Catalog and Volume for the existence of the input                
dataset and it failed.  Insure the input dataset is spelled correctly           
and exists on the system the command executes.                                  
:LI.DRSEO: AGGREGATE VERIFY FAILED, CHECK REPORT IN logdsn                      
:p.Issued ABACKUP ...VERIFY command and received a non-zero return              
code.  Not much sense in continuing with execution, we know the Activity        
log has no datasets in it.  Message is generated by DRSEO exec.                 
:LI.DRSEO: ERROR ALLOCATING LOG DSN actlog .  RC=rc                             
:p.The exec has attempted allocation of the Log Dataset (actlog).               
Possible that someone or something has it allocated or that the Console         
Automation Script has problems. Check the SYSLOG for messages                   
concerning this dataset                                                         
:LI.DRSEO: LOG NOT FROM ABACKUP VERIFY LOGDSN                                   
    DRSEO: CHECK AUTOMATED OPERATIONS, WRONG LOG actlog                         
:p.The exec is reading the ABACKUP ...Verify Activity Log and found             
messages that could only be produced by a Execute Activity Log.                 
We should have the verify log available to us, (the command was issued          
by DRSEO prior to executing this exec), if not then the Console                 
Automation scripts may have been pulled from the system.                        
:eol                                                                            
:backm.                                                                         
:egdoc.                                                                         
 $$                                                                             
